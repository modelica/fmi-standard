=== Application Programming Interface [[co-simulation-api]]

This section contains the interface description to access the input/output data and status information of a Co-Simulation FMU from a C program.

==== Early Return [[early-return]]

:DOSTEP: fmi3DoStep()
:CBIU: fmi3CallbackIntermediateUpdate()

//=== Improving efficiency in multi-FMU environment when asynchronous mode is used

_[In the particular context of multi-FMU architectures, significant co-simulation speed-up may be obtained if the co-simulation algorithm can avoid waiting until the end of the slowest FMU step integration._
_If an FMU prematurely stops its current step integration computation due to an unpredictable internal event before the normal end of the step calculation, all other concurrently running FMUs may be stopped as soon as possible in order to minimize the time needed for the co-simulation algorithm to resynchronize all the FMUs at the same event time._

_In this context based on parallel multi-FMU calculations, <<figure-early-return>> illustrates different possibilities to synchronize FMUs at the same event time._

.Different possibilities to synchronize parallel FMUs at the same event time.
[[figure-early-return]]
image::images/earlyReturnFigure.png[width=100%, align="center"]

_Each FMU starts integration from communication point_ latexmath:[t_{i}] _to reach the next communication point_ latexmath:[t_{i+1}] _._
_Assuming an unexpected internal event is detected at_ latexmath:[t^{'}_{i+1}< t_{i+1}] _inside FMU~1~ , the FMU immediately informs the co-simulation algorithm and asks for an early return._
_Since all FMUs should be resynchronized at the event time which will be the next new communication point, the co-simulation algorithm would like to avoid other FMUs exceed the event time._

* _In the case of FMU~1~, the FMU waits to get pushed into the event mode to handle the event at_ latexmath:[t^{'}_{i+1}] _._
* _In the case of FMU~2~, since this FMU has already reached_ latexmath:[t_{i+1}] _, a complete rollback and a new co-simulation from_ latexmath:[t_{i}] _to_ latexmath:[t^{'}_{i+1}] _is necessary._
* _In the case of FMU~3~, computation is immediately interrupted and only a partial rollback is necessary to reach_ latexmath:[t^{'}_{i+1}] _time._
* _In the case of FMU~4~, the master immediately requests FMU~4~ an early return at_ latexmath:[t^{'}{i+1}] _and the current integration step will been interrupted at_ latexmath:[t^{'}{i+1}] _and no rollback is necessary for FMU~4~._

_Each ongoing FMU stops its integration either exactly at the interrupt time given by the co-simulation algorithm or immediately after its current intermediate step if this time is already out-of-date._
_Afterwards, a new step integration done on the FMU returns and signals the premature stop (early-return) to the co-simulation algorithm._

_Due to the early-return mechanism, the overall execution time of the simulation is reduced.]_


A Co-Simulation FMU is allowed to stop the execution of <<fmi3DoStep>> and return without reaching the predefined communication time, i.e. <<currentCommunicationPoint>> `+` <<communicationStepSize>>.
This mechanism is called "early return".

[[canReturnEarlyAfterIntermediateUpdate,`canReturnEarlyAfterIntermediateUpdate`]]
The Boolean capability flag <<canReturnEarlyAfterIntermediateUpdate>> in the <<modelDescription.xml>> file indicates whether the FMU supports the early-return feature.
The default value of this capability flag is `false`.

Each time an internal discontinuity or an event happens inside an FMU with capability flag <<canReturnEarlyAfterIntermediateUpdate,`canReturnEarlyAfterIntermediateUpdate = true`>>, the callback function <<fmi3CallbackIntermediateUpdate>> is called by the FMU.
The co-simulation algorithm can only use this early return functionality if it provides the <<fmi3CallbackIntermediateUpdate>> callback function pointer in the instantiate function.

With the early return feature, an FMU can signal <<outputClock>> events or internal state changes, i.e., discontinuity events to the co-simulation algorithm at any time (not only at the end of <<fmi3DoStep>> function calls).
When an internal event occurs inside the FMU at a time instant, it informs the co-simulation algorithm that a new communication point for the Co-Simulation can be created.
Note that an event signal is not seen in the narrow sense of solver induced discontinuity events but in the general sense of a simulation event that has to be handled by the co-simulation algorithm (e.g. state changes that require extended handling).

A second use of the early-return mechanism is the following:
In particular in multi-node architectures, significant co-simulation speed-up may be obtained if the co-simulation algorithm can avoid waiting until the end of the slowest <<fmi3DoStep>> when many FMUs are integrating in parallel and an event occurs.
To exploit such efficiency gains, the co-simulation algorithm can command the FMU to return early from the current communication step.
_[In this use case, early return is a simple form of cooperative multitasking.]_

Early return is even helpful if the FMU or the co-simulation algorithm do not support the advanced handling of events based on the <<co-simulation-api,Co-Simulation>> functionalities.
Multiple event types and also <<outputClock>> ticks or interrupts can be supported based on the early-return functionality and additional functionalities provided by <<co-simulation-api,Co-Simulation>>.


==== Intermediate Update of Variables [[intermediate-update]]

The *Intermediate Update Mode* was introduced to facilitate the following use cases:

* improve input accuracy between communication points when importer sets intermediate input values extracted with the same mechanism form another FMU (see below for details),
* allow for cooperative multitasking when FMU calls <<fmi3CallbackIntermediateUpdate>> with <<canReturnEarly, `canReturnEarly == fmi3True`>> (see <<scheduled-execution-api>>),
* allow for the FMU to return early from an <<fmi3DoStep>> because the importer detected an event between communication points (see <<Computation-in-Co-Simulation>>).

A Co-Simulation FMU can provide values for its <<output>> variables at intermediate points between two consecutive communication points, and is able to accept new values for <<input>> variables at these intermediate points.
This is typically required when the FMU uses a numerical solver to integrate the FMU's internal state between communication points in <<fmi3DoStep>>.
This numerical solver assumes that the inputs are continuous in the integration interval, dictated by <<fmi3DoStep>>.
In FMI 2.0 Co-simulation, the intermediate inputs are provided by the use of extrapolations.
The intermediate update functions allow FMUs to receive inputs, and provide outputs, directly to the co-simulation algorithm, in those intermediate time points.

Due to the way numerical solvers estimate and correct the approximation error, these intermediate <<output>> values may be tentative or may be final.
It is possible for the FMU to inform the co-simulation algorithm whether the internal solver is in a tentative state, meaning that the output values computed from that state are also tentative, or if the internal solver has successfully completed the integration step, meaning that the FMU's internal state is final, and will never be change by the normal in the current execution of <<fmi3DoStep>>.
If the internal integration step has successfully completed, the co-simulation algorithm can forward intermediate outputs to other FMUs, where they can be used, for e.g., for extrapolation, interpolation, filtering or asynchronous co-simulation.
_[For tentative output values, the co-simulation algorithm must keep in mind that these values may change for the same time point.]_

The FMU requests updated intermediate <<input>> values for continuous variables every time they are required by the internal solver.
This can be either at tentative solver states or after successful integration steps.

Combinations of the above use cases are also allowed.

Access to intermediate variables enables advanced Co-Simulation with interpolation/extrapolation techniques (such as polynomial extrapolation, TLM co-simulation, anti-alias filtering, smoothing of input) +
Moreover, this enables the same input approximation that was possible in FMI 2.0 with `fmi2SetInputDerivatives`, now evaluating the approximation polynomial and not within the FMU as in FMI 2.0.

The intermediate-update functionality can be used in FMI for Co-Simulation, if both, the FMU and the co-simulation algorithm, support it.
<<figure-intermediate-update>> summarizes the above description.
It illustrates that multiple intermediate internal solver steps, distinguishing between the final ones (with black-filled circles) and tentative ones (with white-filled circles). It distinguishes the level of trust that can be placed in the tentative outputs (with dashed arrows) and in final outputs (with solid arrows).

.Overview of solver states and intermediate update during a communication step
[#figure-intermediate-update]
image::images/intermediateupdate.svg[width=65%, align="center"]

If the co-simulation algorithm signals the support for intermediate update and an FMU has at least one variable with <<intermediateUpdateAttr,`intermediateUpdate = true`>>, the FMU can use the callback function <<fmi3CallbackIntermediateUpdate>> to communicate information back to the co-simulation algorithm:

[[fmi3CallbackIntermediateUpdate,`fmi3CallbackIntermediateUpdate`]]
[source, C]
----
include::../headers/fmi3FunctionTypes.h[tag=CallbackIntermediateUpdate]
----

[[intermediateUpdateTime,`intermediateUpdateTime`]]
* <<intermediateUpdateTime>> is the internal value of the <<independent>> variable _[typically simulation time]_ of the FMU at which the callback has been called.
If an event happens or an <<outputClock>> ticks, <<intermediateUpdateTime>> is the time of event or <<outputClock>> tick.
If the FMU returns with <<earlyReturn,`earlyReturn == fmi3True`>> from <<fmi3DoStep>> then <<intermediateUpdateTime>> is the internal simulation time of the FMU of the last <<fmi3CallbackIntermediateUpdate>> call that signaled <<canReturnEarly,`canReturnEarly == fmi3True`>>.
<<intermediateUpdateTime>> is also the value of the <<independent>> variable of intermediate steps of the internal FMU solver.
The FMU must not call the callback function <<fmi3CallbackIntermediateUpdate>> with an <<intermediateUpdateTime>> that is smaller than the <<intermediateUpdateTime>> given in a previous call of <<fmi3CallbackIntermediateUpdate>> with `intermediateStepFinished == fmi3True`.

[[clocksTickedIA,`clocksTicked`]]
* The <<clocksTickedIA>> parameter is only used in Scheduled Execution and is ignored in Co-Simulation.
When <<clocksTickedIA,`clocksTicked == fmi3True`>>, it means that <<fmi3GetClock>> function must be called for gathering all <<clock>> related information about ticking <<outputClock,`output clocks`>> at <<intermediateUpdateTime>> and then activate the given model partitions accordingly.

[[intermediateVariableSetRequested,`intermediateVariableSetRequested`]]
* If <<intermediateVariableSetRequested,`intermediateVariableSetRequested == fmi3True`>>, the co-simulation algorithm should provide intermediate <<input>> variables by calling `fmi3Set{VariableType}` for continuous variables with <<intermediateUpdateAttr,`intermediateUpdate = true`>>.
The set of variables for which the co-simulation algorithm can provide intermediate values is supplied through the <<requiredIntermediateVariables>> argument to <<fmi3Instantiate>>.
Note that if a co-simulation algorithm does not provide a new value for any of the variables contained in the set it registered, the last set value will be deemed to be the new value.

[[intermediateVariableGetAllowed,`intermediateVariableGetAllowed`]]
* If <<intermediateVariableGetAllowed,`intermediateVariableGetAllowed == fmi3True`>>, the co-simulation algorithm may collect intermediate output variables by calling `fmi3Get{VariableType}` for variables with <<intermediateUpdateAttr,`intermediateUpdate = true`>>.
The set of variables for which the co-simulation algorithm can get values is supplied through the <<requiredIntermediateVariables>> argument to <<fmi3Instantiate>>.

[[intermediateStepFinished,`intermediateStepFinished`]]
* If <<intermediateStepFinished, `intermediateStepFinished == fmi3False`>>, the intermediate outputs of the FMU that the co-simulation algorithm inquires with `fmi3Get{VariableTypes}` resulting from tentative interval solver states and may still change for the same <<intermediateUpdateTime>> (e.g., if the solver deems the tentative state to cause a too high approximation error, it may go back in time and try to re-estimate the state using smaller internal time steps).
_[These outputs shall for example not be communicated to other connected FMUs._
_The use case for this is to let the co-simulation algorithm do some calculations for the FMU even for unfinished solver steps._
_This is beneficial for example for Transmission Line (TLM) co-simulation, where this helps to keep the interface cleaner._
_Instead of FMUs exchanging hard-to-understand variables such as "wave variable" and "characteristic impedance", they can exchange intuitive variables like "force" and "speed".]_

* If <<intermediateStepFinished, `intermediateStepFinished == fmi3True`>>, intermediate outputs inquired by the co-simulation algorithm with `fmi3Get{VariableTypes}` correspond to accepted internal solver steps and will not change (if the co-simulation algorithm does not rollback the FMU).  +
_[So the co-simulation algorithm could for example_

- _use the values obtained with `fmi3Get{VariableTypes}` with <<intermediateStepFinished, `intermediateStepFinished == fmi3True`>> to create an interpolation for the intermediate inputs of other FMUs._
- _use this information for plotting.]_

[[canReturnEarly,`canReturnEarly`]]
* When <<canReturnEarly,`canReturnEarly == fmi3True`>> the co-simulation algorithm can request the FMU to return early at the current <<intermediateUpdateTime>> time instant by returning with <<earlyReturnRequested,`earlyReturnRequested == fmi3True`>> from the callback function <<fmi3CallbackIntermediateUpdate>>.
If <<canReturnEarly,`canReturnEarly == fmi3False`>> the FMU will not do the early return, regardless of the co-simulation algorithm request.

[[earlyReturnRequested,`earlyReturnRequested`]]
* `earlyReturnRequested == fmi3True` requests the FMU to end the <<fmi3DoStep>> at a Newtonian time instant and return early.
This is only allowed if <<canReturnEarly,`canReturnEarly == fmi3True`>>.

[[earlyReturnTime,`earlyReturnTime`]]
* `earlyReturnTime` is used to tell the FMU at what time to return early from the current <<fmi3DoStep>> (at the earliest), if the return value of <<earlyReturnRequested>> of <<fmi3CallbackIntermediateUpdate>> is `fmi3True`.
If the <<earlyReturnTime>> is greater than the last signaled <<intermediateUpdateTime>>, the FMU may integrate up to the time instant <<earlyReturnTime>>.

When providing intermediate inputs to the FMU, it is important that the co-simulation algorithm provides the same input value for the same variable, at the same <<intermediateUpdateTime>>. In other words, it is required that the calculation of inputs to the FMU be deterministic.
This is assumed by the internal solver.
If an input value changes for the same <<intermediateUpdateTime>>, the internal numerical solver may deem that re-estimate a state multiple times, without ever being able to decrease the approximation error.

Because the FMU intermediate outputs may be trusted when <<intermediateStepFinished,`intermediateStepFinished == fmi3True`>>, the FMU is not allowed to call <<intermediateUpdate>> for a simulation time point prior to or equal to a previous call whose argument <<intermediateStepFinished,`intermediateStepFinished == fmi3True`>>.

If the early return is conducted successfully by the FMU it must return with <<earlyReturn,`earlyReturn == fmi3True`>> from <<fmi3DoStep>>, indicating the current FMU time with <<lastSuccessfulTime>>.

The co-simulation algorithm can decide if a rollback of the FMU to reach the <<earlyReturnTime>> time is required or it may continue the simulation from <<lastSuccessfulTime>> for that FMU.
Note that *Event Mode* is not supported in Scheduled Execution.

The following code example shows an implementation of <<fmi3CallbackIntermediateUpdate>> that uses intermediate update to record a set of variables at every internal solver step:

[source, c]
----
include::Reference-FMUs/examples/bcs_intermediate_update.c[tag=IntermediateUpdateCallback]
----

==== Variables Access [[transfer-of-input-output-and-parameters]]

<<input,`Input`>> and <<output>> variables and other variables are accessed via the `fmi3Get{VariableType}` and `fmi3Set{VariableType}` functions, defined in <<get-and-set-variable-values>>.

In order to enable the co-simulation algorithm to interpolate the <<continuous>> floating point <<input,`inputs`>> between communication steps, the <<derivative,`derivatives`>> of the <<output,`outputs`>> with respect to time at the end of a communication step can be enquired by the co-simulation algorithm.
This is also possible for higher <<derivative,`derivatives`>> with respect to time.

_[The co-simulation algorithm is then able to extrapolate inputs using this information using <<intermediate-update>>._
_This enables the same functionality as with `fmi2SetInputDerivatives` in FMI1.0 and FMI2.0.]_

[[fmi3GetOutputDerivatives,`fmi3GetOutputDerivatives`]]
[source, C]
----
include::../headers/fmi3FunctionTypes.h[tags=GetOutputDerivatives]
----

With the arguments:

--
* `valueReferences` is a vector of value references that define the variables whose <<derivative,`derivatives`>> shall be retrieved.
If multiple derivatives of a variable shall be retrieved, list the value reference multiple times.

* `nValueReferences` is the dimension of the arguments `valueReferences` and `orders`.

* `orders` contains the orders of the respective <<derivative>> (1 means the first <<derivative>>, 2 means the second <<derivative>>, ..., 0 is not allowed).
If multiple derivatives of a variable shall be retrieved, provide a list of them in the `orders` array, corresponding to a multiply occurring value reference in the `valueReferences` array.

* `values` is a vector with the values of the <<derivative,`derivatives`>>. The order of the `values` elements is derived from a twofold serialization: the outer level corresponds to the combination of a value reference (e.g., `valueReferences[k]`) and order (e.g., `orders[k]`), and the inner level to the serialization of variables. The inner level does not exist for scalar variables.

* `nValues` is the size of the argument `values`. `nValues` only equals `nValueReferences` if all corresponding output variables are scalar variables.
--


<<fmi3GetOutputDerivatives>>::
Retrieves the n-th <<derivative>> of <<output>> values.
Restrictions on using the function are the same as for the `fmi3Get{VariableType}` function.
The returned <<output,`outputs`>> correspond to the current time of the FMU.
E.g. after a successful call to <<fmi3DoStep>> the returned values are related to the end of the communication step.

To allow interpolation/approximation of the floating point output variables between communication steps by the co-simulation algorithm, the <<derivative,`derivatives`>> of the <<output,`outputs`>> with respect to time can be read.
Whether the FMU is able to provide the <<derivative,`derivatives`>> of <<output,`output`>> is given by the unsigned integer capability flag `maxOutputDerivativeOrder`.
It delivers the maximum order of the <<output>> <<derivative, `derivatives`>>.
If the actual order is lower (because the order of integration algorithm is low), the retrieved value is 0.


_[ Example:_ +
_Assuming an FMU has outputs latexmath:[y_1][2*3] with value reference 1, latexmath:[y_2] with value reference 2, latexmath:[ y_3][2] value reference 3, latexmath:[y_4] with value reference 4 and `maxOutputDerivativeOrder`=2._ +
_With `valueReferences`= [1, 1, 3, 3, 4, 4], and `orders`= [1, 2, 1, 2, 1, 2], <<fmi3GetOutputDerivatives>> will provide first and second time derivatives of the outputs y1, y3, y4, which in `values` are serialized in the following way:_
_((array serialization of latexmath:[\dot y_1]), (array serialization of latexmath:[\ddot y_1]), (array serialization of latexmath:[\dot y_3]), (array serialization of latexmath:[\ddot y_3]), latexmath:[\dot y_4], latexmath:[\ddot y_4])_ +
_If the internal polynomial is of order 1 and the co-simulation algorithm inquires the second <<derivative>> of an <<output>>, the FMU will return zero.]_

==== Computation in Co-Simulation [[Computation-in-Co-Simulation]]

The importer requests the computation of the next time step with the following function:

[[fmi3DoStep,`fmi3DoStep`]]
[source, C]
----
include::../headers/fmi3FunctionTypes.h[tags=DoStep]
----

[[currentCommunicationPoint,`currentCommunicationPoint`]]
* `currentCommunicationPoint` is the current communication point of the co-simulation algorithm (latexmath:[t_i]) with the unit of the <<independent>> variable and

[[communicationStepSize,`communicationStepSize`]]
* `communicationStepSize` is the communication step size (latexmath:[h_i]) with the unit of the <<independent>> variable. `comunicationStepSize` must be latexmath:[> 0.0].

[[noSetFMUStatePriorToCurrentPoint,`noSetFMUStatePriorToCurrentPoint`]]
* `noSetFMUStatePriorToCurrentPoint == fmi3True` if `fmi3SetFMUState` will no longer be called for time instants prior to <<currentCommunicationPoint>> in this simulation run. _[The FMU can use this flag to flush a result buffer]_

[[eventEncountered,`eventEncountered`]]
* <<eventEncountered,`eventEncountered == fmi3True`>> indicates that an event was encountered at <<lastSuccessfulTime>> and the co-simulation algorithm has to call <<fmi3NewDiscreteStates>> to gather related information about the event.

[[clocksAboutToTick,`clocksAboutToTick`]]
* <<clocksAboutToTick,`clocksAboutToTick == fmi3True`>> indicates that one or more clocks will tick at <<lastSuccessfulTime>> and, after calling <<fmi3NewDiscreteStates>>, <<fmi3GetClock>> should be called to gather all information related to <<outputClock,`output clocks`>> that have the value `fmi3ClockActive`.

* `terminate` signals to the co-simulation algorithm that the FMU requests the end of the simulation for internal reasons.
This is not due to an error, but a natural limit to the simulation time has been reached inside the FMU.

[[earlyReturn,`earlyReturn`]]
* `earlyReturn` signals to the co-simulation algorithm that the FMU returns early from the <<fmi3DoStep>> at the time specified in <<lastSuccessfulTime>>.

[[lastSuccessfulTime,`lastSuccessfulTime`]]
* `lastSuccessfulTime` represents the internal time of the FMU when <<fmi3DoStep>> returns.

The FMU is expected to compute until time latexmath:[t_{i+1} = t_i + h_i], or <<lastSuccessfulTime>> `=` <<currentCommunicationPoint>> `+` <<communicationStepSize>>.

This is especially interesting, if <<fmi3DoStep>> returns with <<earlyReturn,`earlyReturn == fmi3True`>>.
In this case, the step did not compute until latexmath:[t_{i+1}], but stopped computation error free until <<lastSuccessfulTime>>.
However, even when the FMU returns from <<fmi3DoStep>> with <<fmi3OK>>, it is allowed that <<lastSuccessfulTime>> deviates from the expected <<currentCommunicationPoint>> `+` <<communicationStepSize>>.
_[An example is a fixed-step integrator inside the FMU that cannot possibly stop at exactly the requested time._
_Advanced co-simulation algorithms might be able to take this information into account._
_It is even possible that the <<lastSuccessfulTime>> is still equal to <<currentCommunicationPoint>> when <<earlyReturn,`earlyReturn == fmi3True`>> is returned (contrary to the possibly expected <<fmi3Discard>>) to indicate a changed internal state of the FMU, e.g. steps in super-dense time.]_

_[The calling environment defines the communication points and <<fmi3DoStep>> must synchronize to these points by always integrating exactly to latexmath:[t_i + h_i]._
_It is up to <<fmi3DoStep>> how to achieve this.]_

At the first call to <<fmi3DoStep>> after <<fmi3ExitInitializationMode>> was called <<currentCommunicationPoint>> must be equal to `startTime` as set with <<fmi3EnterInitializationMode>>.

_[Formally, argument <<currentCommunicationPoint>> is not needed._
_It is present in order to handle a mismatch between the co-simulation algorithm and the state of the FMU: The <<currentCommunicationPoint>> and the state of the FMU defined by former_ <<fmi3DoStep>> _or_ `fmi3SetFMUState` _calls have to be consistent with respect to each other._
_For example, if the FMU does not use the update formula for the <<independent>> variable as required above,_ latexmath:[t_{i+1} = t_i + h_i] _(using argument_ latexmath:[t_i] = <<currentCommunicationPoint>> _of_ <<fmi3DoStep>>) _but uses internally an own update formula, such as_ latexmath:[t_{s,i+1} = t_{s,i} + h_{s,i}] _then the FMU could use as time increment_ latexmath:[\text{h}_{s,i} := (t_i - t_{s,i}) + h_i] _(instead of_ latexmath:[\text{h}_{s,i} := h_i] _) to avoid a mismatch between the co-simulation algorithm time_ latexmath:[t_{i+1}] _and the FMU internal time_ latexmath:[t_{s,i+1}] _for large i.]_

It depends on the capabilities of the FMU which argument constellations and calling sequences are allowed (see <<fmi-for-co-simulation>>).

Only <<fmi3DoStep>> can change the time of a Co-Simulation FMU from the outside (time advances internally during a communication interval).

==== Communication of Event Time and Input and Output Values

The <<fmi3CallbackIntermediateUpdate>> callback described in <<intermediate-update>> is also used in order to communicate the <<input>> and <<output>> and, in particular, the event and <<clock>> time from the FMU to the co-simulation algorithm.
The <<fmi3CallbackIntermediateUpdate>> callback allows internal events (e.g. associated to <<outputClock>> ticks) to be signaled from an FMU to the co-simulation algorithm.
For the interface type Co-Simulation, the <<fmi3CallbackIntermediateUpdate>> callback must be defined in the instantiate function, i.e. NULL is not allowed.

The arguments of <<fmi3CallbackIntermediateUpdate>> are used to signal <<outputClock>> ticks and internal events to the co-simulation algorithm.
See <<intermediate-update>> for details of the function parameters.

[source, C]
----
include::../headers/fmi3FunctionTypes.h[tag=CallbackIntermediateUpdate]
----

Only the first discontinuity event at a Newtonian time instant shall be signaled using this function.
There may be an event iteration in *Event Mode* at a Newtonian time instant causing super-dense time instants.

Based on the information provided by <<fmi3CallbackIntermediateUpdate>>, additional information about the discontinuity at that time instant can be obtained by the co-simulation algorithm from the FMU by calling <<fmi3NewDiscreteStates>> and <<fmi3GetClock>>.

==== Handling Early Return and Events

If the FMU is successful in conducting an early return, <<fmi3DoStep>> returns with <<earlyReturn,`earlyReturn == fmi3True`>>.
If the FMU returns from <<fmi3DoStep>> with <<earlyReturn,`earlyReturn == fmi3True`>>, the co-simulation algorithm has to call <<fmi3EnterEventMode>> for that FMU.

[source, C]
----
include::../headers/fmi3FunctionTypes.h[tag=EnterEventMode]
----

The co-simulation algorithm can also call <<fmi3EnterEventMode>> at communication instants to handle input events, as will be discussed in following sections.

If an FMU provides the early-return capability that includes the handling of events in *Event Mode*,
the FMU signals this via <<canReturnEarlyAfterIntermediateUpdate>> in the <<modelDescription.xml>>.

The FMU stops computation at the first encountered internal event (if any) and the event time is provided through the output argument <<lastSuccessfulTime>>, along with the reason <<eventEncountered, `eventEncountered == fmi3True`>>.
The co-simulation algorithm will start event handling by calling <<fmi3EnterEventMode>> for that FMU to push the FMU into *Event Mode*.
In this mode the co-simulation algorithm is supposed to catch all events through the <<fmi3NewDiscreteStates>> function.

If an early-return request of the co-simulation algorithm is ignored by the FMU, then <<fmi3DoStep>> returns with <<earlyReturn,`earlyReturn == fmi3False`>>.
The co-simulation algorithm can start a resynchronization of FMUs at an event time, if the <<currentCommunicationPoint>> has passed the event time, the co-simulation algorithm can roll-back the FMU and repeat the step with a suitable <<communicationStepSize>> (if the FMU supports the roll-back).

[source, C]
----
include::../headers/fmi3FunctionTypes.h[tag=NewDiscreteStates]
----

In *Event Mode* and only after <<fmi3DoStep>> returned with <<earlyReturn,`earlyReturn == fmi3True`>>, and <<fmi3EnterEventMode>> was called, the function <<fmi3NewDiscreteStates>> may be called.
Only the following output arguments are defined by the FMU:

- When `newDiscreteStatesNeeded = true`, the co-simulation algorithm should stay in *Event Mode* and another call to <<fmi3NewDiscreteStates>> is required.

- When <<nextEventTime,`nextEventTimeDefined == fmi3True`>>, an event time is available and the value is given by <<nextEventTime>>.
This is the case when the model can report in advance the accurate time of the next predictable <<time event>>.

- When <<terminateSimulation,`terminateSimulation == fmi3True`>>, the model requested to stop integration and the co-simulation algorithm should call <<fmi3Terminate>>.

All other output arguments of <<fmi3NewDiscreteStates>> are undefined and have no meaning in Co-Simulation.

In *Event Mode* it is allowed to call `fmi3Get{VariableType}` after <<fmi3NewDiscreteStates>> has been called and it is allowed to call `fmi3Set{VariableType}` before calling <<fmi3NewDiscreteStates>>.
The FMU leaves *Event Mode* when the co-simulation algorithm calls <<fmi3EnterStepMode>>.

//The following pseudo-code example shows an implementation of <<fmi3CallbackIntermediateUpdate>> that uses <<earlyReturn>>, <<earlyReturnRequested>> and //<<earlyReturnTime>> to handle events inside the FMU:

//[source, c]
//----
//include::Reference-FMUs/examples/cs_early_return.c[tag=EventEarlyReturn]
//----

==== Co-Simulation with Clock Support [[api-clocked-co-simulation]]

In this section, signaling and retrieving <<clock>> ticks as well as the interface for supporting <<clock,`clocks`>> in FMI for Co-Simulation will be discussed.
If an FMU for Co-Simulation declares <<clock,`clocks`>> and clocked variables in the <<modelDescription.xml>> file, it supports <<clock,`clocks`>>.
Note, even if no <<clock>> is defined by an FMU in <<modelDescription.xml>>, the co-simulation algorithm can instantiate a Co-Simulation FMU to be able to use early return with event handling in *Event Mode*.

If an FMU provides <<clock,`clocks`>> and the co-simulation algorithm is using the interface type Co-Simulation, the co-simulation algorithm must handle these <<clock,`clocks`>> and early return requests by the FMU.
If the co-simulation algorithm does not support or does not want to support early-return or <<clock,`clocks`>>, it must set the interface type to Co-Simulation if supported by the FMU.
If the FMU provides the Co-Simulation interface and is instantiated with it, the FMU must internally handle all events during <<fmi3DoStep>>.

[[fmi3EnterStepMode,`fmi3EnterStepMode`]]
[source, C]
----
include::../headers/fmi3FunctionTypes.h[tag=EnterStepMode]
----

===== Transfer of Input and Output Values and Parameters [[transfer-of-input-output-and-parameters-clocked-co-simulation]]

If the co-simulation algorithm supports <<clock,`clocks`>>, all <<inputClock,`input clocks`>> of the model should be handled and <<inputClock>> events should be scheduled by the co-simulation algorithm.
If an <<outputClock>> will tick, the FMU returns from <<fmi3DoStep>> with <<clocksAboutToTick,`clocksAboutToTick == fmi3True`>>.
After calling <<fmi3NewDiscreteStates>>, the activation status of <<outputClock,`output clocks`>> can be retrieved with <<fmi3GetClock>>.
Then <<fmi3SetClock>> (and <<fmi3SetIntervalDecimal>> or <<fmi3SetIntervalFraction>> if necessary) should be invoked to enable the ticked <<inputClock,`input clocks`>>.
Each <<clock>>, that ticks outside of the FMU (i.e. <<inputClock>>), is activated for an FMU based on its <<clockReference>> and an associated <<fmi3SetClock>> in *Event Mode*.
<<fmi3SetClock>> can activate multiple <<clock,`clocks`>> with each call.
An event iteration is possible.
Once all <<clock>> events are handled for this time instant, the FMU should be pushed into *Step Mode* by calling <<fmi3EnterStepMode>>.
In *Step Mode*, the co-simulation algorithm can call <<fmi3DoStep>> for the time interval from the current event time instant until the next input event instant.
Note that <<fmi3DoStep>> may not reach the next input event instant because an early return may occur.

The co-simulation algorithm sets and gets <<clock>> variable values similar to the FMI for Model Exchange, as defined in <<fmi-api-setting-getting-clock-activation-state>>.

===== Computation in Co-Simulation [[computation-clocked-co-simulation]]

Similar to FMI for Model Exchange, in order to activate <<inputClock,`input clocks`>> of an FMU, it is required to push the FMU into *Event Mode* by calling <<fmi3EnterEventMode>>.
If <<fmi3DoStep>> returns with <<eventEncountered,`eventEncountered == fmi3True`>> or <<clocksAboutToTick,`clocksAboutToTick == fmi3True`>>, the FMU must be pushed into *Event Mode* and <<fmi3NewDiscreteStates>> must be called.

In order to retrieve the status of <<outputClock,`output clocks`>>, <<fmi3GetClock>> and <<fmi3GetIntervalDecimal>> or <<fmi3GetIntervalFraction>> need to be called in the *Event Mode*.
If the <<fmi3DoStep>> return value is <<fmi3OK>>, the calling of <<fmi3GetClock>>, <<fmi3GetIntervalDecimal>>, <<fmi3GetIntervalFraction>>, <<fmi3NewDiscreteStates>> is only meaningful after <<fmi3SetClock>> in the case of super-dense time iterations are desired.

Similar to the Model Exchange case, the allowed call order is <<fmi3GetClock>>, <<fmi3GetIntervalDecimal>>, <<fmi3GetIntervalFraction>>, `fmi3Get{VariableType}`, `fmi3Set{VariableType}`.
Function calls of this call order can be omitted.

The handling of return values of function calls is identical to Co-Simulation.

If <<terminateSimulation,`terminateSimulation`>> becomes `fmi3True` after calling <<fmi3NewDiscreteStates>> then the co-simulation should be terminated by calling <<fmi3Terminate>>.
Once handling of the <<clock>> events finished, the co-simulation algorithm calls <<fmi3EnterStepMode>> for that FMU to push it into *Step Mode*.
Note that it is not allowed to call <<fmi3EnterEventMode>> or <<fmi3EnterStepMode>> in Scheduled Execution.

_[Usually the co-simulation algorithm should be able to derive (but is not forced to do so) the correct communication point times for <<inputClock,`input clocks`>> in advance and thus it should be able to set the proper <<communicationStepSize>> for <<fmi3DoStep>>._
_This might not be possible if an <<periodic,aperiodic>> <<inputClock>> of an FMU depends on the ticking of an <<periodic,aperiodic>> <<outputClock>> of another FMU or other <<periodic,aperiodic>> tick sources.]_

==== State Machine for Co-Simulation [[state-machine-co-simulation]]

The state machine in <<figure-co-simulation-state-machine>> defines the supported calling sequences.

.Calling sequence of Co-Simulation C functions.
[#figure-co-simulation-state-machine]
image::images/state-machine-co-simulation.svg[width=80%, align="center"]

Each state of the state machine corresponds to a certain phase of a simulation.
Common states are defined in <<state-machine-and-common-states>>, such as super states <<FMUStateSetable,*FMU State Setable*>>, <<UnderEvaluation,*Under Evaluation*>> and  <<Initialized,*Initialized*>>, states <<Instantiated,*Instantiated*>>, <<ConfigurationMode,*Configuration Mode*>>, <<ReconfigurationMode,*Reconfiguration Mode*>>, <<InitializationMode,*Initialization Mode*>>, <<Terminated,*Terminated*>> and <<IntermediateUpdateMode,*Intermediate Update Mode*>>.

===== State: Step Mode [[state-step-mode-co-simulation]]

This state is used by the co-simulation algorithm to progress simulation time.

Allowed Function Calls::
<<fmi3GetDirectionalDerivative>>, <<fmi3GetOutputDerivatives>>, `fmi3Get{VariableType}`, <<fmi3Terminate>>

<<fmi3EnterConfigurationMode>>::
With this function call the *Reconfiguration Mode* is entered.
This function must not be called if the FMU contains no <<tunable>> <<structuralParameter,`structural parameters`>> (i.e. with <<causality>>= <<structuralParameter>> and <<variability>> = <<tunable>>).

<<fmi3EnterEventMode>>::
With this function call the *Event Mode* is entered.
This function must not be called, if the co-simulation algorithm signaled `eventModeUsed = fmi3False` during instantiation.

<<fmi3DoStep>>::
Within <<fmi3DoStep>> the FMU may call <<fmi3CallbackIntermediateUpdate>>
* If the function returns with <<fmi3OK>> or <<fmi3Warning>> the FMU stays in this state.
* The co-simulation algorithm must call <<fmi3DoStep>> with <<communicationStepSize, `communicationStepSize > 0.0`>>.
* If the function returns with <<earlyReturn,`earlyReturn == fmi3True`>> the FMU will change to states depending on the flags of <<fmi3CallbackIntermediateUpdate>>.
* The FMU may return immediately from <<fmi3DoStep>> with <<lastSuccessfulTime,`lastSuccessfulTime == currentCommunicationPoint`>> if an event was detected immediately at the <<currentCommunicationPoint>>.
Such an event might be caused by the change of an input during the communication point, or may be pending after the initialization.

`fmi3Set{VariableType}`::
For variables with:
* <<causality>> = <<input>>, or
* <<causality>> = <<parameter>> and <<variability>> = <<tunable>>

It is not allowed to call `fmi3Get{VariableType}` functions after `fmi3Set{VariableType}` functions without an <<fmi3DoStep>> call in between.

_[The reason is to avoid different interpretations of the caching, since contrary to FMI for Model Exchange, <<fmi3DoStep>> will perform the actual calculation instead of `fmi3Get{VariableType}`, and therefore, dummy algebraic loops at communication points cannot be handled by an appropriate sequence of `fmi3Get{VariableType}` and, `fmi3Set{VariableType}` calls as for Model Exchange._

_Examples:_

[cols="3,4",options="header"]
|====
|_Correct calling sequence_
|_Wrong calling sequence_

|_fmi3Set{VariableType} on inputs_ +
_fmi3DoStep_ +
_fmi3Get{VariableType} on outputs_ +
_fmi3Set{VariableType} on inputs_ +
_fmi3DoStep_ +
_fmi3Get{VariableType} on outputs_ +

|_fmi3Set{VariableType} on inputs_ +
_fmi3DoStep_ +
_fmi3Get{VariableType} on outputs_ +
_fmi3Set{VariableType} on inputs_ +
_fmi3Get{VariableType} on outputs // not allowed_ +
_fmi3DoStep_ +
_fmi3Get{VariableType} on outputs_ +
|====
_]_

===== State: Event Mode

The co-simulation algorithm and the FMU enter this state when the co-simulation algorithm calls <<fmi3EnterEventMode>> in state *Step Mode*, in order to handle discrete events and <<clock>> ticks.
If the co-simulation algorithm signals `eventModeUsed == fmi3False` during instantiation, the co-simulation algorithm is not allowed to call <<fmi3EnterEventMode>>.

Allowed Function Calls::
<<fmi3Terminate>>::
Upon return of <<fmi3NewDiscreteStates>>, if <<terminateSimulation,`terminateSimulation == fmi3True`>>, the co-simulation algorithm should finish the Co-Simulation by calling `fmi3Terminate` on all FMU instances.

<<fmi3NewDiscreteStates>>::
In order to handle discrete events <<fmi3NewDiscreteStates>> is called.
When the output argument `newDiscreteStatesNeeded == fmi3True`, the FMU should stay in *Event Mode* and another call to <<fmi3NewDiscreteStates>> is required.

<<fmi3EnterStepMode>>::
Once all events are handled and `newDiscreteStatesNeeded == fmi3False`, the FMU should be pushed to *Step Mode* by calling <<fmi3EnterStepMode>>, unless it requests to terminate the Co-Simulation by setting  <<terminateSimulation,`terminateSimulation`> to `fmi3True`.
In this case, a new step can be started from the current communication point time.

<<fmi3GetClock>>::
The status of <<outputClock,`output clocks`>> and <<localClock,`local clocks`>> can be inquired by this function during *Event Mode* and *Intermediate Update Mode*.

<<fmi3SetClock>>::
For <<inputClock,`input clocks`>>, <<fmi3SetClock>> is called after entering *Event Mode* to set the activation status of <<clock,`clocks`>>.
This function can be called several times, only if recomputations of clock state are needed during *Event Mode*.

<<fmi3GetIntervalDecimal>> & <<fmi3GetIntervalFraction>>::
For <<outputClock,`output clocks`>> and <<localClock,`local clocks`>> it is allowed to call these functions during *Event Mode* and *Intermediate Update Mode*.
These functions can be called only at the first activation of <<periodic>> <<outputClock,`output clocks`>>.
For <<periodic,`aperiodic`>> <<outputClock,`output clocks`>>, these functions must be called at every activation _[to inquire when triggered <<inputClock,`input clocks`>> must tick]_.

<<fmi3SetIntervalDecimal>> & <<fmi3SetIntervalFraction>>::
These functions can be called only at the first activation of <<periodic>> <<inputClock,`input clocks`>>.
These functions can be called for every activation of <<periodic,`aperiodic`>> <<inputClock,`input clocks`>>.

==== Code Example for Co-Simulation

In the following example, the usage of the FMI functions is sketched in order to clarify the typical calling sequence of the functions in a simulation environment.
We consider two FMUs, where both have one <<continuous>> floating point <<input>> and one <<continuous>> floating point <<output>> which are connected in the following way:

.Connection graph of FMUs.
image::images/co-simulation-connection-of-FMUs.svg[width=30%, align="center"]

We assume no algebraic dependency between input and <<output>> of each FMU.
The code demonstrates the simplest co-simulation algorithm as shown in <<math-co-simulation>>:

- Constant communication step size.
- No repeating of communication steps.
- The error handling is implemented in a very rudimentary way.

[source, C]
----
include::Reference-FMUs/examples/co_simulation.c[tags=CoSimulation]
----

==== Code Example for Clocks [[code-example-clocked-co-simulation]]

In the following example, the usage of the FMI functions is sketched in order to clarify the typical calling sequence of the functions in a simulation environment.
We consider ...

// TODO: Description of code example. Explained once validated, after examples are ready?

The error handling is implemented in a very rudimentary way.

// TODO: add code example

[source, C]
----
//include::examples/c-code/co_simulation_clocked.c[tags=CoSimulation]
----
