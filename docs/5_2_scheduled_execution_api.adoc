=== State Machine for Scheduled Execution [[state-machine-scheduled-execution]]

This section contains the description of the Scheduled Execution interface for a C program.

The direct scheduling of model partitions based on <<clock>> ticks requires an additional handling mode for FMUs.
The FMU signals its support for direct model partition scheduling in the <<modelDescription.xml>> via the element `<fmiModelDescription><ScheduledExecution>`.
The simulation algorithm signals to the FMU that it supports and has recognized the <<clock>> and model partition scheduling capabilities of the FMU by instantiating it as Scheduled Execution.

Error, reset or terminate information is a global state of the FMU.
If e.g. an function returns <<fmi3Discard>> or <<fmi3Error>> this is also assumed for all active or preempted model partitions.
In case of <<fmi3Discard>> or <<fmi3Error>> no repetition of the step is possible, the only possible way to go forward is to enter the *Terminated* state and to end or to reset the simulation or - if supported - to set the FMU back to a former state.

This section summarizes the available states and the allowed function calls in the respective states.

.Calling sequence of Scheduled Execution C functions.
[#figure-scheduled-execution-state-machine]
image::images/state-machine-scheduled-execution.svg[width=80%, align="center"]

If the simulation algorithm intends to enter the state *Terminated* it must ensure that all tasks related to model partitions of the FMU have ended.
Hence if in states *Clock Activation Mode*, *Intermediate Update Mode*, or *Reconfiguration Mode* a function returns <<fmi3Fatal>> the simulation algorithm may prematurely end all tasks related to the computation of model partitions of this FMU.
If in these states a function returns <<fmi3Discard>> or <<fmi3Error>> the simulation algorithm may wait until all other tasks of the model partitions of this FMU have ended, but new tasks must not be started.

Each state of the state machine corresponds to a certain phase of a simulation.
Common states are defined in <<common-state-machine>>, such as super states <<FMUStateSetable,*FMU State Setable*>> and  <<Initialized,*Initialized*>>, states <<Instantiated,*Instantiated*>>, <<ConfigurationMode,*Configuration Mode*>>, <<ReconfigurationMode,*Reconfiguration Mode*>>, <<InitializationMode,*Initialization Mode*>>, <<Terminated,*Terminated*>> and <<IntermediateUpdateMode,*Intermediate Update Mode*>>.

==== Super State: Initialized [[Initialized-SE]]

Special to Scheduled Execution, the following additional constrains apply to the state *Initialized* (see <<Initialized>>).
The FMU enters state *Terminated* only after all other tasks related to the computation of model partitions of this FMU have ended.
After <<fmi3Terminate>> has been called no new tasks can be started (e.g. related to <<outputClock>> ticks) and all other function calls for this FMU must return <<fmi3Error>> until the state *Terminated* is reached.

==== State: Clock Activation Mode

The FMU enters this state when the simulation algorithm calls <<fmi3ExitInitializationMode>> in state *Initialization Mode* or <<fmi3ExitConfigurationMode>> in state *Reconfiguration Mode*.

In this state the simulation algorithm can create multiple concurrent tasks related to an FMU and in each task the simulation algorithm can activate one or multiple <<inputClock,`input clocks`>> of an FMU based on the defined <<clock>> properties via a <<fmi3ActivateModelPartition>> call for each <<clock>>.

Allowed Function Calls::

[[fmi3ActivateModelPartition, `fmi3ActivateModelPartition`]]
<<fmi3ActivateModelPartition>>::

Each <<fmi3ActivateModelPartition>> call is now associated to the computation of a (publicly disclosed, externally controlled) model partition of the model and therefore to a single defined <<inputClock>>.

[source, C]
----
include::../headers/fmi3FunctionTypes.h[tag=ActivateModelPartition]
----

The <<fmi3ActivateModelPartition>> function has the following arguments:

- `fmi3Instance instance`: same meaning as for other `fmi3*` functions

- `fmi3ValueReference` <<clockReference>>: <<valueReference>> of an <<inputClock>> variable defined in the <<modelDescription.xml>> which shall be activated

- `size_t` <<clockElementIndex>>:: The element index of the <<inputClock>> variable which shall be activated.
For a scalar <<clock>> variable this must be 0; for array <<clock>> variables, the element clock to activate is specified using the 1-based element index.
Using the element index 0 means all elements of the <<clock>> variable.
(Note: If an array has more than one dimension the indices are serialized in the same order as defined for values in <<serialization-of_variables>>).

[[activationTime, `activationTime`]]
- `fmi3Float64 activationTime`: value of the <<independent>> variable of the assigned <<inputClock>> tick time latexmath:[t_i] _[typically: simulation (i.e. virtual) time]_ (which is known to the simulation algorithm).

The importer schedules calls of <<fmi3ActivateModelPartition>> for each FMU.
Calls are based on activations of <<inputClock,`input clocks`>>.
These <<inputClock>> activations can be based on <<clock>> activations from FMU external sources (e.g. <<outputClock,`output clocks`>> of other FMUs).
The <<inputClock>> activations can also be based on <<outputClock>> ticks of the same FMU.
The <<fmi3ActivateModelPartition>> function must not be called on <<outputClock,`output clocks`>> of an FMU.

Note that this is a different timing concept compared to <<fmi3DoStep>> calls for Co-Simulation FMUs or the <<fmi3SetTime>> for Model Exchange FMUs.
An <<fmi3ActivateModelPartition>> call will compute the results of the model partition defined by <<clockReference>> and <<clockElementIndex>> (i.e. <<valueReference>> of the variable that defines a <<clock>> and an element index into that for arrays) for the current <<clock>> tick latexmath:[t_i].

If required, the FMU can internally derive the <<clock>> interval latexmath:[\mathbf{T}_\mathit{interval, i}] based on the last <<clock>> tick time latexmath:[t_{i-1}] i.e. last `activationTime` for this <<clockReference>> and <<clockElementIndex>> (based on last <<fmi3ActivateModelPartition>> call).

Consecutive calls to <<fmi3ActivateModelPartition>> for a <<clockReference>> and <<clockElementIndex>> (i.e. <<valueReference>> of <<clock>> variable and element index into that for arrays) must have strictly monotonically increasing `activationTime` latexmath:[t_i].

Function <<get-and-set-variable-values,`fmi3Set{VariableType}`>>::
This function can be called before scheduling a model partition for variables assigned to that model partition via its associated <<clock>> and all variables not associated to a <<clock>> (global variables).

Function <<get-and-set-variable-values,`fmi3Get{VariableType}>>`, `fmi3GetOutputDerivatives`, <<fmi3GetDirectionalDerivative>>::
These functions can be called after the computation of a model partition for variables assigned to that model partition via its associated <<clock>> and all variables not associated to a <<clock>> (global variables).

Set/get operations must be atomic for a single variable.

_[Because of real-time constraints, the computational effort has to be predictable for all operations in Scheduled Execution._
_Therefore, all computationally expensive operations to compute a model partition have to be contained within the <<fmi3ActivateModelPartition>> function._
_The simulation algorithm can assume that `fmi3Get{VariableType}` and `fmi3Set{VariableType}` operations are not computationally expensive._
_It is recommended, to call `fmi3Set{VariableType}` and `fmi3Get{VariableType}` in the same task as <<fmi3ActivateModelPartition>>.]_

The restrictions related to variable <<causality>> and <<variability>> defined for *Step Mode* in <<fmi-for-co-simulation,`Co-Simulation`>> apply.

It is not allowed to call `fmi3Get{VariableType}` functions after `fmi3Set{VariableType}` functions without an <<fmi3ActivateModelPartition>> call in between.

_[The reason is to avoid different interpretations of the caching, since contrary to <<fmi-for-model-exchange, `FMI for Model Exchange`>>, <<fmi3ActivateModelPartition>> will perform the actual calculation instead of `fmi3Get{VariableType}`, and therefore, dummy algebraic loops at communication points cannot be handled by an appropriate sequence of `fmi3Get{VariableType}` and `fmi3Set{VariableType}` calls as for Model Exchange._

_Example:_

.Example calling sequences.
[[table-example-calling-sequence-SE]]
[cols="3,4",options="header"]
|====
|_Correct calling sequence for a model partition_
|_Illegal calling sequence_

|_fmi3Set{VariableType} on inputs_ +
fmi3ActivateModelPartition +
_fmi3Get{VariableType} on outputs_ +
_fmi3Set{VariableType} on inputs_ +
fmi3ActivateModelPartition +
_fmi3Get{VariableType} on outputs_ +

|_fmi3Set{VariableType} on inputs_ +
fmi3ActivateModelPartition +
_fmi3Get{VariableType} on outputs_ +
_fmi3Set{VariableType} on inputs_ +
_fmi3Get{VariableType} on outputs // not allowed_ +
fmi3ActivateModelPartition +
_fmi3Get{VariableType} on outputs_ +
|====

_]_

Function <<fmi3CallbackIntermediateUpdate>>::
<<fmi3CallbackIntermediateUpdate>> switches the FMU itself into the *Intermediate Update Mode*.
The callback may be called from concurrent tasks within <<fmi3ActivateModelPartition>>.

Functions <<fmi3GetFMUState>>, <<fmi3SetFMUState>>, <<fmi3FreeFMUState>>, <<fmi3SerializedFMUStateSize>>, <<fmi3SerializeFMUState>>, <<fmi3DeSerializeFMUState>>::
These functions must not be called if any model partition is currently active or preempted.
_[This is because these functions apply to the whole FMU and not only to a specific model partition.]_
