=== State Machine for Scheduled Execution [[state-machine-scheduled-execution]]

The FMU signals its support for scheduling execution in the <<modelDescription.xml>> via the element `<fmiModelDescription><ScheduledExecution>`.
The simulation algorithm signals to the FMU that it supports and has recognized the <<Clock,Clocks>> and model partition scheduling capabilities of the FMU by instantiating it as Scheduled Execution.

Error, reset or terminate information is a global state of the FMU.
If any function call returns <<fmi3Discard>> or <<fmi3Error>>, all active or preempted model partitions are in the same state.
In case of <<fmi3Discard>> or <<fmi3Error>> no repetition of the step is possible, the only possible way to continue is to enter the <<Terminated>> state and to end or to reset the simulation or - if supported by the FMU - to set the FMU back to a previous state.

The state machine in <<figure-scheduled-execution-state-machine>> defines the allowed calling sequences for FMI for Co-Simulation.

.Calling sequence of Scheduled Execution C functions.
[#figure-scheduled-execution-state-machine]
image::images/state-machine-scheduled-execution.svg[width=80%, align="center"]

If the simulation algorithm intends to enter the state <<Terminated>>, it must ensure that all computations related to model partitions of the FMU have ended.
Hence, if in states <<ClockActivationMode>>, <<IntermediateUpdateMode>>, or <<ReconfigurationMode>> a function returns <<fmi3Fatal>>, the simulation algorithm may prematurely end all computations of model partitions of this FMU.
If in these states a function returns <<fmi3Discard>> or <<fmi3Error>> the simulation algorithm may wait until all other model partitions of this FMU have ended, but new model partitions must not be started.

Each state of the state machine corresponds to a certain phase of a simulation.
Common states are defined in <<common-state-machine>>, such as super states <<FMUStateSetable>> and  <<Initialized>>, states <<Instantiated>>, <<ConfigurationMode>>, <<ReconfigurationMode>>, <<InitializationMode>>, <<Terminated>> and <<IntermediateUpdateMode>>.

==== Super State: Initialized [[Initialized-SE,*Initialized*]]

The following specific constraints apply to the state <<Initialized>> of Scheduled Execution.
The FMU enters state <<Terminated>> only after all computations of model partitions of this FMU have ended.
After <<fmi3Terminate>> has been called, no new model partitions can be started (e.g. related to <<countdown, `countdown Clock`>> ticks) and all other function calls for this FMU must return <<fmi3Error>> until the state <<Terminated>> is reached.

==== State: Clock Activation Mode [[ClockActivationMode,*Clock Activation Mode*]]

The FMU enters this state when the simulation algorithm calls <<fmi3ExitInitializationMode>> in state <<InitializationMode>> or <<fmi3ExitConfigurationMode>> in state <<ReconfigurationMode>>.

In this state the simulation algorithm can create multiple concurrent tasks related to an FMU. In each task, the simulation algorithm can activate one or multiple model partitions of an FMU based on the defined <<inputClock,input Clocks>> properties via a <<fmi3ActivateModelPartition>> call for each Clock.
#TODO: still unclear for me: what is the relation between a task and model partition, 1:1 or 1:n?#

[cols="2,1",options="header",]
|====
|<<each-state-description,Equations and Actions>>
|Functions Influencing Equations

|Set <<tunable>> <<parameter,`parameters`>> latexmath:[\mathbf{p}_{\mathit{variability == tunable}}] .
|<<get-and-set-variable-values,`fmi3Set{VariableType}`>>

|Set discrete-time <<input,`inputs`>> latexmath:[\mathbf{u}_{d}(\mathbf{t})].
|<<get-and-set-variable-values,`fmi3Set{VariableType}`>>

|Get values of variables latexmath:[\mathbf{v}(\mathbf{t})].
|<<get-and-set-variable-values,`fmi3Get{VariableType}`>>

a|When an input Clock latexmath:[\mathbf{k}_i] ticks, activate the corresponding model partition:

* latexmath:[(\mathbf{y}_\mathit{d,k_i}, \mathbf{x}_\mathit{d,k_i}, \mathbf{w}_\mathit{d,k_i}) := \mathbf{f}_{\mathit{activate}}({}^{\bullet}\mathbf{x}_\mathit{d}, \mathbf{w}_d, \mathbf{u}_\mathit{d}, \mathbf{p}, \mathbf{k_i})] +
* Update previous values of discrete states of the corresponding model partition: latexmath:[{}^\bullet\mathbf{x}_\mathit{d,k_i}:=\mathbf{x}_\mathit{d,k_i}].
|<<fmi3ActivateModelPartition>>

|latexmath:[(\mathbf{v}_{u}) := \mathbf{f}_{\mathit{inter}}({}^{\bullet}\mathbf{x}_d, \mathbf{u}_{d}, {}^{\bullet}\mathbf{u}_{u}, \mathbf{p} )]
|<<fmi3CallbackIntermediateUpdateSE>>

|====

Allowed Function Calls::

Function <<get-and-set-variable-values,`fmi3Set{VariableTypeExclClock}`>>::
This function can be called before scheduling a model partition for variables assigned to that model partition via its associated <<Clock>> and all variables not associated with any <<Clock>>.

Function <<get-and-set-variable-values,`fmi3Get{VariableTypeExclClock}`>>::
These functions can be called after the computation of a model partition for variables assigned to that model partition via its associated <<Clock>> and all variables not associated with any <<Clock>>.

Because of real-time constraints, the computational effort has to be predictable for all operations in Scheduled Execution.
Therefore, all computationally expensive operations to compute a model partition have to be contained within the <<fmi3ActivateModelPartition>> function.
The simulation algorithm can assume that <<get-and-set-variable-values,`fmi3Get{VariableTypeExclClock}`>> and <<get-and-set-variable-values,`fmi3Set{VariableTypeExclClock}`>> operations are not computationally expensive.

The restrictions related to variable <<causality>> and <<variability>> defined for <<StepMode>> in <<fmi-for-co-simulation,`Co-Simulation`>> apply.

It is not allowed to call <<get-and-set-variable-values,`fmi3Get{VariableTypeExclClock}`>> functions after <<get-and-set-variable-values,`fmi3Set{VariableTypeExclClock}`>> functions without an <<fmi3ActivateModelPartition>> call in between.
_[It is recommended, to call <<get-and-set-variable-values,`fmi3Set{VariableTypeExclClock}`>>, <<fmi3ActivateModelPartition>> and <<get-and-set-variable-values,`fmi3Get{VariableTypeExclClock}`>> in a sequence._
_The reason is to avoid different interpretations of the caching, since contrary to <<fmi-for-model-exchange, `FMI for Model Exchange`>>, <<fmi3ActivateModelPartition>> will perform the actual calculation instead of <<get-and-set-variable-values,`fmi3Get{VariableTypeExclClock}`>>, and therefore, dummy algebraic loops at communication points cannot be handled by an appropriate sequence of <<get-and-set-variable-values,`fmi3Get{VariableTypeExclClock}`>> and <<get-and-set-variable-values,`fmi3Set{VariableTypeExclClock}`>> calls as for Model Exchange.]_

[[fmi3ActivateModelPartition, `fmi3ActivateModelPartition`]]
Function `fmi3ActivateModelPartition`::

Each <<fmi3ActivateModelPartition>> call is associated with the computation of a exposed model partition of the FMU and therefore to an <<inputClock>>.
+
[source, C]
----
include::../headers/fmi3FunctionTypes.h[tag=ActivateModelPartition]
----
+
The <<fmi3ActivateModelPartition>> function has the following arguments:

* [[clockReference,`clockReference`]] `clockReference`: <<valueReference>> of the <<inputClock>> associated to the model partition which shall be activated.

* [[clockElementIndex,`clockElementIndex`]] `clockElementIndex`: The element index of the <<Clock>> variable associated with the model partition which shall be activated.
For a scalar <<Clock>> variable the index must be 0; for an array <<Clock>> variable, the index is 1-based.
Using the element index 0 means all elements of the <<Clock>> variable.
(Note: If an array has more than one dimension the indices are serialized in the same order as defined for values in <<serialization-of_variables>>).

* [[activationTime, `activationTime`]] `activationTime`: value of the <<independent>> variable of the assigned <<Clock>> tick time latexmath:[\mathbf{t}_i] _[typically: simulation (i.e. virtual) time]_ (which is known to the simulation algorithm).

+
The importer schedules calls of <<fmi3ActivateModelPartition>> for each FMU.
These calls are based on ticks of <<inputClock,input Clocks>>.
The <<fmi3ActivateModelPartition>> function must not be called on <<outputClock,output Clocks>> of an FMU.

+
This is a different timing concept compared to <<fmi3DoStep>> calls for Co-Simulation FMUs or the <<fmi3SetTime>> for Model Exchange FMUs.
#TODO: why is this a different timing concept? and it is redundant#
An <<fmi3ActivateModelPartition>> call will compute the results of the model partition defined by <<clockReference>> and <<clockElementIndex>> (i.e. <<valueReference>> of the variable that defines a <<Clock>> and an element index into that for arrays) for the current <<Clock>> tick latexmath:[\mathbf{t}_i].

+
If required, the FMU can internally derive the <<Clock>> interval latexmath:[\mathbf{T}_\mathit{interval, i}] based on the last <<Clock>> tick time latexmath:[\mathbf{t}_\mathit{i-1}] i.e. last `activationTime` for this <<clockReference>> and <<clockElementIndex>> (based on last <<fmi3ActivateModelPartition>> call).
#TODO: non-normative but why is this mentioned here at all?#

+
Consecutive calls to <<fmi3ActivateModelPartition>> for a <<clockReference>> and <<clockElementIndex>> (i.e. <<valueReference>> of <<Clock>> variable and element index into that for arrays) must have strictly monotonically increasing `activationTime` latexmath:[\mathbf{t}_i].

[[fmi3CallbackIntermediateUpdateSE,`fmi3CallbackIntermediateUpdate`]]
Function `fmi3CallbackIntermediateUpdate`::
<<fmi3CallbackIntermediateUpdate>> switches the FMU itself into the <<IntermediateUpdateMode>>.
The callback may be called from concurrent tasks within <<fmi3ActivateModelPartition>>.
#TODO: what is a concurrent tasks within ActivateModelPartion?
The callback may be called by FMU while executing a ActivateModelPartition call.#

Functions <<fmi3GetFMUState>>, <<fmi3SetFMUState>>, <<fmi3FreeFMUState>>, <<fmi3SerializedFMUStateSize>>, <<fmi3SerializeFMUState>>, <<fmi3DeSerializeFMUState>>::
These functions must not be called if any model partition is currently active or preempted.
_[This is because these functions apply to the whole FMU and not only to a specific model partition.]_
