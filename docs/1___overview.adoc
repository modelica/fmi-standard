== Introduction

=== What is new in FMI 3.0 [[fmi-whats-new]]

The FMI Design Community has improved the FMI standard to react to new requirements from the system simulation community.

Especially the ability to package control code into FMUs required some workarounds in FMI 2.0.
With FMI 3.0, virtual electronic control units (vECUs) can be exported as FMU in a more natural way.
Concrete features to support vECU export are:

* introduction of <<definitionOfTerminals,terminals>> to group variables semantically to ease connecting compatible signals,

* introduction of <<graphicalRepresentation,icons>> to define a graphical representation of the FMU and its terminals,

* introduction of <<Clock,Clocks>> to more exactly control timing of events and evaluation of model partitions across FMUs,

* introduction of more integer types and a 32-bit float type (see <<fmi-description-schema>>) to communicate native controller types to the outside,

* introduction of a binary type to support non-numeric data handling, such as complex sensor data interfaces,

* extension of variables to arrays for more efficient and natural handling of non-scalar variables,

* introduction of structural parameters that allow description and changing of array sizes, even during runtime to support advanced online calibration of control code, and

* addition of the new interface type FMI for Scheduled Execution (see <<fmi-for-scheduled-execution>>) that allows activation of individual model partitions (or tasks) from an external scheduler.

A second need of the simulation community was address by introducing the more advanced co-simulation interface <<fmi-for-co-simulation,FMI for Co-Simulation>>.
New features, like

* <<early-return,early return>> from a <<fmi3DoStep>> call,

* the <<IntermediateUpdateMode, intermediate update>>, or

* <<Clocks,Clocks and clocked variables>>,

allow implementation of more robust and efficient co-simulation algorithms to handle the growing system simulations the community is facing.

Parallel to the new standard features, the FMI Design Community has worked on improving the standard quality by:

* modernizing the development methodology (e.g. moving to github) and a text-based source format,

* publishing the FMI Standard now primarily as html to support easier navigation within the document and viewing on a wider range of devices,

* supplying a large set of continuously validated Reference FMUs, and

* integrating within the FMI Standard only validated C-code, XML and XSD snippets to reduce redundancy and ensure correctness.

While a number of desirable features had to be postponed, the resulting FMI 3.0 is certainly a significant step forward towards meeting the most important requirements of the system simulation community for the years to come.

The asynchronous mode for FMUs known from FMI 2.0 has been removed since this mode was not supported by tools and it can be suitably replaced by Co-Simulation implementations that control the asynchronous computation of FMUs via separate tasks/threads created for each FMU.

=== Overview

The FMI (Functional Mock-Up Interface) defines an interface to be implemented by an executable called an FMU (Functional Mock-Up Unit).
The FMI functions are used (called) by a simulation environment to create one or more instances of the FMU and to simulate them, typically together with other models.
An FMU may either have its own solvers (<<fmi-for-co-simulation,FMI for Co-Simulation>>), or require the simulation environment to perform numerical integration (<<fmi-for-model-exchange,FMI for Model Exchange>>), or require the simulation environment to trigger model partition execution (<<fmi-for-scheduled-execution,FMI for Scheduled Execution>>).
The goal of this interface is that the calling of an FMU in a simulation environment is reasonably simple.
This document does not describe how to generate an FMU from a modeling environment.

The interfaces have large parts in common, defined in <<fmi-common-concepts,Common Concepts>>.
In particular:

* FMI Application Programming Interface \(C) -- <<general-mechanisms>> +
All required equations or tool coupling computations are evaluated by calling standardized C functions.
C is used because it is the most portable programming language today and is the only programming language that can be utilized in all embedded control systems.

* FMI Description Schema (XML) -- <<fmi-description-schema>> +
The schema defines the structure and content of an XML file generated by a modeling environment.
This XML file contains the definition of all variables of the FMU in a standardized way.
It is then possible to run the C code in an embedded system without the overhead of the variable definition (the alternative would be to store this information in the C code and access it via function calls, but this is neither practical for embedded systems nor for large models).
Furthermore, the variable definition is a complex data structure and tools should be free to determine how to represent this data structure in their programs.
The selected approach allows a tool to store and access the variable definitions (without any memory or efficiency overhead of standardized access functions) in the programming language of the simulation environment.

* FMU Distribution (ZIP) -- <<fmu-distribution>> +
An FMU is distributed in one ZIP file.
The ZIP file contains the FMI Description file (XML), the binaries and libraries required to execute the FMI functions (.dll or .so files), the sources of the FMI functions (optional), and other data used by the FMU (e.g., tables or maps).
It is possible for an FMU to hide the source code to secure the contained know-how or to allow a fully automatic import of the FMU in another simulation environment.

==== FMI for Model Exchange (ME)

The Model Exchange interface exposes an ODE to an external solver of an importing tool.
Models are described by differential, algebraic and discrete equations with time-, state- and step-events.
That integration algorithm of the importing tool, usually a DAE solver, is responsible for advancing time, setting states, handling events, etc.
(See <<fmi-for-model-exchange>>.)

.Schematic view of data flow between user, the solver of the importer and the FMU for Model Exchange
[#figure-model-exchange-data-flow]
image::images/model-exchange-data-flow.svg[width=40%, align="center"]

==== FMI for Co-Simulation (CS)

The FMI for Co-Simulation interface is designed both for the coupling of simulation tools, and the coupling of subsystem models, exported by their simulators together with its solvers as runnable code.
(See <<fmi-for-co-simulation>>.)

.Schematic view of data flow between user, the co-simulation algorithm of the importer and the FMU for Co-Simulation
[#figure-co-simulation-data-flow]
image::images/co-simulation-data-flow.svg[width=40%, align="center"]

==== FMI for Scheduled Execution (SE)

The Scheduled Execution interface exposes individual model partitions (e.g. tasks of a control algorithm), to be called by a scheduler that acts as external scheduler.
The scheduler is responsible for advancing the overall simulation time, triggering of time-based and triggered <<Clock,Clocks>> for all exposed model partitions of a set of FMUs, and handling events (e.g. clock ticks) signaled by the FMUs.

In many ways, the Scheduled Execution interface is the equivalent of the Model Exchange interface: the first externalizes a scheduling algorithm usually found in a controller algorithm and the second interface externalizes the ODE solver.
(See <<fmi-for-scheduled-execution>>.)

.Schematic view of data flow between user, the scheduler of the importer and tasks of the FMU for Scheduled Execution
[#figure-scheduled-execution-data-flow]
image::images/scheduled-execution-data-flow.svg[width=40%, align="center"]

==== Feature Overview of FMI Interface Types

image::images/fmi-types-overview.svg[width=50%, align="center"]

<<table-overview-features>> gives an overview of the features of the different interfaces.

.Overview of features per interface.
[[table-overview-features]]
[cols=",^,^,^",options="header"]
|====
|Feature
|Model Exchange
|Co-Simulation
|Scheduled Execution

|Advancing Time
|Call <<fmi3SetTime>>
|Call <<fmi3DoStep>> and monitor argument <<lastSuccessfulTime>>
|Call <<fmi3ActivateModelPartition>>

|Solver Included
|icon:times[]
|icon:check[]
|Not applicable

|Scheduler Included
|Not applicable
|icon:check[]
|icon:times[]

|Event Indicators
|icon:check[]
|icon:times[]
|icon:times[]

|<<early-return,Early Return>>
|Includes similar or better mechanism
|icon:check[]
|icon:times[]

|<<IntermediateUpdateMode,Intermediate Update>>
|Includes similar or better mechanism
|icon:check[]
|Signal output <<Clock>> ticks: icon:check[] +
Inputs/Outputs: icon:times[]

|<<Clock,Clocks>>
|icon:check[]
|icon:check[]
|icon:check[]

|Direct Feedthrough
|icon:check[]
|At events: icon:check[] +
Else: icon:times[]
|icon:times[]
|====

=== Properties and Guiding Ideas

In this section, properties are listed and some principles are defined that guided the low-level design of the FMI.
This shall increase self consistency of the FMI functions.
The listed issues are sorted, starting from high-level properties to low-level implementation issues.

Expressivity::
The FMI provides the necessary features to package models of different domains, such as multibody and virtual ECUs, into an FMU.

Stability::
The FMI is expected to be supported by many simulation tools worldwide.
Implementing such support is a major investment for tool vendors.
Stability and backwards compatibility of the FMI has therefore high priority.
To support this, the FMI defines "capability flags" that will be used by future versions of the FMI to extend and improve the FMI in a backwards compatible way, whenever feasible.

Implementation::
FMUs can be written manually or can be generated automatically from a modeling environment.
Existing manually coded models can be transformed manually to a model according to the FMI standard.

Processor independence::
It is possible to distribute an FMU without knowing the target processor.
This allows an FMU to run on a PC, a Hardware-in-the-Loop simulation platform or as part of the controller software of an ECU.
Keeping the FMU independent of the target processor increases the usability of the FMU.
To be processor independent, the FMU must include its C (or C++) sources.

Simulator independence::
It is possible to compile, link and distribute an FMU without knowing the environment in which the FMU will be loaded.
+
Reason: The standard would be much less attractive otherwise, unnecessarily restricting the later use of an FMU at compile time and forcing users to maintain simulator specific variants of an FMU.
To be simulator independent, the FMU must export its implementation in self-contained binary form.
This requires that the target operating system and processor be known.
Once exported with binaries, the FMU can be executed by any simulator running on the target platform (provided the necessary licenses are available, if required from the model or from the used run-time libraries).

Semantic versioning::
The FMI standard uses semantic version numbers, as defined in <<PW13>>, where the standard version consists of a triple of version numbers, consisting of major version, minor version, and patch version numbers, see <<VersioningLayered>>.

Version independence::
FMUs with a specific major and minor version number are valid FMUs w.r.t. the same major version and any minor version because features of minor versions are optional and ignorable.
+
Reason: A tool can always export the greatest minor version it supports.
Such an FMU can be imported into all tools supporting this major version and arbitrary minor versions.
This achieves maximal longevity of FMUs protecting its value for users.

Small run-time overhead::
Communication between an FMU and an importer through the FMI does not introduce significant run-time overhead.
This can be achieved by enabling caching of the FMU outputs and by exchanging multiple quantities with one call.

Small footprint::
A compiled FMU binary requires little memory.
+
Reason: An FMU may run on an ECU (Electronic Control Unit, for example, a microprocessor), and ECUs have strong memory limitations.
This is achieved by storing variable attributes (`name`, `unit`, etc.) and all other static information not needed for model evaluation in a separate text file (= Model Description File) that is not needed on the microprocessor where the executable might run.

Hide data structure::
The FMI for Model Exchange does not prescribe a data structure (e.g., a C struct) to represent a model.
+
Reason: the FMI standard shall not unnecessarily restrict or prescribe a certain implementation of FMUs or simulators (whichever contains the model data) to ease implementation by different tool vendors.

Support many and nested FMUs::
A simulator may run many FMUs in a single simulation run and/or multiple instances of one FMU.
The inputs and outputs of these FMUs can be connected with direct feedthrough.
Moreover, an FMU may contain nested FMUs.

Numerical Robustness::
The FMI standard allows problems which are numerically critical (for example, <<time event,`time`>> and <<state event,`state events`>>, multiple sample rates, stiff problems) to be treated in a robust way.

Hide cache::
A typical FMU will cache computed results for later reuse.
To simplify usage and to reduce error possibilities by a simulator, the caching mechanism is hidden from the usage of the FMU.
+
Reason: First, the FMI should not force an FMU to implement a certain caching policy.
Second, this helps to keep the FMI simple.
To help implement this cache, the FMI provides explicit methods (called by the FMU environment) for setting properties that invalidate cached data.
An FMU that chooses to implement a cache may maintain a set of "dirty" flags, hidden from the simulator.
A get method, for example to a state, will then either trigger a computation, or return cached data, depending on the value of these flags.

Support numerical solvers::
A typical importer will use numerical solvers.
These solvers require vectors for <<state,`states`>>, <<derivative,`derivatives`>> and zero-crossing functions.
The FMU directly fills the values of such vectors provided by the solvers.
+
Reason: minimize execution time.
The exposure of these vectors conflicts somewhat with the "hide data structure" requirement, but the efficiency gain justifies this.

Explicit signature::
The intended operations, arguments, and return types are made explicit in the signature.
For example, an operator (such as `compute_derivatives`) is not passed as an int argument but a special function is called for this.
The `const` prefix is used for any pointer that should not be changed, including `const char*` instead of `char*`.
+
Reason: the correct use of the FMI can be checked at compile time and allows calling of the C code in a C++ environment (which is much stricter on `const` than C is).
This will help to develop FMUs that use the FMI in the intended way.

Few functions::
The FMI consists of a few, "orthogonal" functions, avoiding redundant functions that could be defined in terms of others.
+
Reason: This leads to a compact, easy-to-use, and hence attractive API with a compact documentation.

Error handling::
All FMI methods use a common set of methods to communicate errors.

Allocator must free::
All memory (and other resources) allocated by the FMU are freed (released) by the FMU.
Likewise, resources allocated by the importer are released by the importer.
+
Reason: this helps to prevent memory leaks and run-time errors due to incompatible run-time environments for different components.

Immutable strings::
All strings passed as arguments or returned are read-only and must not be modified by the receiver.
+
Reason: This eases the reuse of strings.

Named list elements::
All lists defined in the `fmi3ModelDescription.xsd` XML schema file have a string attribute `name` to a list element.
This attribute must be unique with respect to all other `name` attributes of the same list.

Use C::
The FMI is encoded using C, not C++.
Reasons: Avoid problems with compiler and linker dependent behavior, and run the FMU on embedded systems.

This version of the FMI standard does not have the following desirable properties.
They might be added in a future version.

* The FMI for Model Exchange is for ordinary differential equations (ODEs) in state space form.
It is not for a general differential-algebraic equation system.
However, algebraic equation systems inside the FMU are supported (for example, the FMU can report to the environment to re-run the current step with a smaller step size since a solution could not be found for an algebraic equation system).

* Special features that might be useful for multibody system programs are not included.

* The interface is for simulation and for embedded systems.
Properties that might be additionally needed for trajectory optimization, for example, derivatives of the model with respect to parameters during continuous integration are not included.

* No explicit definition of the variable hierarchy in the XML file.

=== How to Read This Document

The core of this document is the description of the state machines and their states for each of the three FMI interface types, each interface type in its own section.
Each state description starts with a brief state's purpose, then the mathematical model in a table linking formulas with C-API functions, and finally descriptions of all allowed functions for this particular state.

To keep the descriptions brief and redundancy low, <<fmi-common-concepts,common concepts>> are described in the central section, including <<common-state-machine,common parts of the state machines>>, <<fmi-description-schema,XML schema>> and <<fmu-distribution,ZIP-file content description>>.

The standard document is in HTML allowing heavy use of in-document links: all state names, function names, many function arguments, XML elements and attributes are links to definitions or descriptions.
By pressing "t", the table of contents can be displayed on the left side or hidden.

Conventions used in this document:

* Non-normative text is given in square brackets in italic font: _[Especially examples are defined in this style.]_

* The key words *MUST*, *MUST NOT*, *REQUIRED*, *SHALL*, *SHALL NOT*, *SHOULD*, *SHOULD NOT*, *RECOMMENDED*, *NOT RECOMMENDED*, *MAY*, and *OPTIONAL* in this document are to be interpreted as described in https://tools.ietf.org/html/rfc2119[RFC 2119].

[[VariableType,`{VariableType}`]]
* `{VariableType}` is used as a placeholder for all variable type names without the `fmi3` prefix (e.g. <<get-and-set-variable-values,`fmi3Get`>><<VariableType,`VariableType`>> stands for `fmi3GetUInt8`, `fmi3GetBoolean`, `fmi3GetFloat64`, `fmi3GetClock`, `fmi3GetBinary`, etc.).

[[VariableTypeExclClock,`{VariableTypeExclClock}`]]
* `{VariableTypeExclClock}` is used just like <<VariableType>>, except does not include functions on `fmi3Clock`.

* State machine states are formatted as *bold* link, e.g. <<InitializationMode>>.
