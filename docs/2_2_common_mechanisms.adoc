=== General Mechanisms [[general-mechanisms]]

This section contains the common interface definitions that allow a C program to invoke the FMU functions.

Note that the following general properties hold for an FMU:

- FMI functions of one instance do not need to be thread-safe. +
_[For example, if the functions of one instance of an FMU are accessed from more than one thread;
the multi-threaded simulation environment that uses the FMU must guarantee that there are no race conditions while invoking the FMI functions.
The FMU itself does not implement any services to support this.]_

- FMI functions must not change global settings which affect other processes/threads.
An FMI function may change settings of the thread in which it is called (such as floating point control registers), provided these changes are restored before leaving the function or before a callback function is called. +
_[This property ensures that functions of different FMU instances can be called safely in any order._
_Additionally, they can be called in parallel provided the functions are called in different processes._
_If an FMI function changes for example the floating point control word of the CPU, it must restore the previous value before return of the function._
_For x86 CPUs, the floating point control word is set using the `fldcw` instruction._
_This can be used to switch on additional exceptions such as floating point division by zero._
_An FMU might temporarily change the floating point control word and get notified on floating point exceptions internally, but has to restore the flag and clear the floating point status word before return of the respective FMI function.]_

- In general, FMI function arguments are not allowed to be NULL, unless explicitly allowed by the standard document where NULL will be assigned a specific semantic. +
_[For an example of NULL being explicitly allowed see <<resourceLocation>>._
_Careful implementations should still guard against NULL pointers.]_

- The FMI Standard does not provide a run-time platform or portability layer.
Access to operating system resources and services, such as memory and file system, must be implemented with special care because the availability of such resources and services is not guaranteed.
If some resource is required by the FMU but is not available, the FMU must log what resource failed and return with error.

==== Header Files and Naming of Functions [[header-files-and-naming-of-functions]]

Three header files are provided that define the interface of an FMU.
In all header files the convention is used that all C function and type definitions start with the prefix `fmi3`:

`fmi3PlatformTypes.h`::
contains the type definitions of the input and output arguments of the functions as well as some C preprocessor macro definitions for constants.
This header file must
be used both by the FMU and by the importer.
_[Example of a definition in this header file:_
+
[source, C]
----
typedef double fmi3Float64;
----
+
_]_

`fmi3FunctionTypes.h`::
contains `typedef` definitions of all function prototypes of an FMU as well as enumerations for constants.
This header file includes `fmi3PlatformTypes.h`.
When dynamically loading an FMU, these definitions can be used to type-cast the function pointers to the respective function definition.
For simplicity, the function type for each function is composed of the function name itself with the suffix `TYPE`.
+
_[Example of a definition in this header file:_
+
[source, C]
----
typedef fmi3Status fmi3SetTimeTYPE(fmi3Instance, fmi3Float64);
----
+
_]_

`fmi3Functions.h`::
contains the function prototypes of an FMU that can be accessed in simulation environments.
+
This header file includes `fmi3PlatformTypes.h` and `fmi3FunctionTypes.h`.
The header file version number for which the model was compiled, can be inquired by the importer with <<fmi3GetVersion>> (see <<inquire-version-number>>). +
+
_[Example of a definition in this header file:_
+
[source, C]
----
FMI3_Export fmi3SetTimeTYPE fmi3SetTime;
----
+
_For Microsoft and Cygwin compilers `FMI3_Export` is defined as_ `pass:[__]declspec(dllexport)` _and for Gnu-Compilers as_ `pass:[__]attribute__ ( ( visibility("default") ) )` _in order to export the name for dynamic loading._
_Otherwise it is an empty definition.]_

The goal is that both source code and binary representations of FMUs are supported and that several FMUs might be present at the same time in an executable (for example, FMU A may use an FMU B).
In order for this to be possible, the names of the functions in different FMUs must be different, or function pointers must be used.
To support the source code representation of FMUs, macros are provided in `fmi3Functions.h` to build the actual function names by using a function prefix that depends on how the FMU is shipped.

_[These macros can be defined differently in a target specific variant of `fmi3Functions.h` to adjust them to the requirements of the supported compilers and platforms of the importing tool.]_

An FMU C-file must include at the beginning a `define` of `FMI3_FUNCTION_PREFIX` with the same value as the value of the `modelIdentifier` attribute defined in `<fmiModelDescription><ModelExchange>`, `<fmiModelDescription><CoSimulation>` or `<fmiModelDescription><ScheduledExecution>` together with `pass:[_]` at the end (see <<model-exchange-schema>>, <<co-simulation-schema>>, <<scheduled-execution-schema>>).

This `define` must be directly followed with an `#include "fmi3Functions.h"` statement.

Typically, FMU functions are used as follows:

[source, C]
----
// FMU is shipped with C source code, or with static link library
#define FMI3_FUNCTION_PREFIX MyModel_
#include "fmi3Functions.h"
< usage of the FMU functions e.g. MyModel_fmi3SetTime >

// FMU is shipped with DLL/SharedObject
#include "fmi3FunctionTypes.h"
fmi3SetTimeTYPE *myname_setTime = < load symbol "fmi3SetTime" from DLL/SharedObject >;
< usage of the FMU function pointers, e.g. myname_setTime >
----

A function that is defined as `fmi3GetFloat64` is changed by the macros to a function name as follows:

- If the FMU is shipped with C source code or with static link library: +
The constructed function name is `MyModel_fmi3GetFloat64`.
In other words the function name is prefixed with the model name and an `pass:[_]`.
A simulation environment can therefore construct the relevant function names by generating code for the actual function call.
In case of a static link library, the name of the library is `MyModel.lib` on Windows and `libMyModel.a` on Linux; in other words the `modelIdentifier` attribute is used to create the library name.

- If the FMU is shipped with DLL/SharedObject: +
The constructed function name is `fmi3GetFloat64`, in other words, it is not changed.
_[This can be realized in the case of a source code FMU with a target-specific version of `fmi3Functions.h` that does not use FMI3_FUNCTION_PREFIX to construct the function names.]_
A simulation environment will then dynamically load this library and will explicitly import the function symbols by providing the FMI function names as strings.
The name of the library is `MyModel.dll` on Windows or `MyModel.so` on Linux; in other words the `modelIdentifier` attribute is used as library name.

_[An FMU can be optionally shipped so that it basically contains only the communication to another simulation tool (`needsExecutionTool = true`, see <<fmi-for-co-simulation>>)._
_This is particularly common for co-simulation tasks._
_In this tool coupling case one DLL/Shared Object can be used for all models due to no function prefixing.]_

Since `modelIdentifier` is used as prefix of a C-function name it must fulfill the restrictions on C-function
names (only letters, digits and/or underscores are allowed).
_[For example, if `modelName = "A.B.C"`, then `modelIdentifier` might be "A_B_C".]_
Since `modelIdentifier` is also used as name in a file system, it must also fulfill the restrictions of the targeted operating system.
Basically, this means that it should be short.
These restrictions apply to all interface types and for binary and source-code FMUs.
_[For example, the Windows API only supports full path-names of a file up to 260 characters (see: http://msdn.microsoft.com/en-us/library/aa365247%28VS.85%29.aspx).]_

==== Platform Dependent Definitions

To simplify porting, no C types are used in the function interfaces, but the alias types are defined in this section.
All definitions in this section are provided in the header file `fmi3PlatformTypes.h`.
It is required to use this definition for all binary FMUs.

[source, C]
----
include::../headers/fmi3PlatformTypes.h[tags=Component]
----

This is a pointer to an FMU specific data structure that contains the information needed to process the model equations or to process the co-simulation of the model/subsystem represented by the FMU.

[source, C]
----
include::../headers/fmi3PlatformTypes.h[tags=ComponentEnvironment]
----

This is a pointer to a data structure in the importer.
Using this pointer, data can be transferred between the importer and callback functions it provides (see <<FMUStateSetable>>).

[source, C]
----
include::../headers/fmi3PlatformTypes.h[tags=FMUState]
----

This is a pointer to a data structure in the FMU that saves the internal FMU state of the actual or a previously saved time instant.
This allows to restart a simulation from a saved FMU state (see <<get-set-fmu-state>>).

[source, C]
----
include::../headers/fmi3PlatformTypes.h[tags=ValueReference]
----

This is a handle to a (base type) variable value of the model.
A `fmi3ValueReference` uniquely identifies the value and other properties of a variable, except for the variable name and the display unit that may differ for <<alias>> variable definitions.

Structured entities, such as records, must be flattened into a set of values (scalars or arrays) of type `fmi3Float64`, `fmi3Int32`, etc.
Arrays may be flattened into a set of scalars or represented directly as array values.
An `fmi3ValueReference` references one such value (scalar or array).
The coding of `fmi3ValueReferences` is a "secret" of the environment that generated the FMU.
The interface to the equations only provides access to variable values via `fmi3ValueReferences`.
Extracting concrete information about a variable can be done by reading the <<modelDescription.xml>> in which the `fmi3ValueReferences` are defined.
If a function in the following sections is called with a wrong `fmi3ValueReference` value _[for example, setting a constant with a call to `fmi3SetFloat64`]_, then the function must return with an error ( <<fmi3Error,`fmi3Status == fmi3Error`>>, see <<status-returned-by-functions>>).

Listing <<code-base-types>> shows the base types used in the interfaces of the C functions.

.Base types
[[code-base-types]]
[source, C]
----
include::../headers/fmi3PlatformTypes.h[tags=VariableTypes]
----

==== Status Returned by Functions [[status-returned-by-functions]]

This section defines the `status` flag (an enumeration of type `fmi3Status` defined in file `fmi3FunctionTypes.h` ) that is returned by all functions to indicate the success of the function call:

[source, C]
----
include::../headers/fmi3FunctionTypes.h[tags=Status]
----

The status has the following meaning:

[[fmi3OK,`fmi3OK`]]
`fmi3OK`::
The call was successful.
The output argument values are defined.

[[fmi3Warning,`fmi3Warning`]]
`fmi3Warning`::
A non-critical problem was detected, but the computation can continue.
The output argument values are defined.
Function <<logMessage>> was called by the FMU and the user is expected to handle the problem.
_[In certain applications, e.g. in a prototyping environment, warnings may be acceptable._
_For production environments warnings should be treated like errors unless they can be safely ignored.]_

[[fmi3Discard,`fmi3Discard`]]
`fmi3Discard`::
The call was not successful and the FMU is in the same state as before the call.
The output argument values are not defined, but the computation can continue.
When debug logging is enabled (`loggingOn == fmi3True`) the function <<logMessage>> was called by the FMU.
Advanced simulation algorithms can try alternative approaches to drive the simulation by calling the function with different arguments or calling another function.
Otherwise the simulation algorithm has to treat this return code like <<fmi3Error>> and has to terminate the simulation.

[[fmi3Error,`fmi3Error`]]
`fmi3Error`::
The call failed.
The output argument values are undefined and the simulation cannot be continued.
Function <<logMessage>> was called by the FMU and the FMU is in state **Terminated**.
If a function returns <<fmi3Error>>, it is possible to restore a previously retrieved FMU state by calling <<fmi3SetFMUState>>.
Otherwise <<fmi3FreeInstance>> or <<fmi3Reset>> must be called.
When detecting illegal arguments or a wrong function call at the current FMU state, the FMU must return <<fmi3Error>>.
Other instances of this FMU are not affected by the error.

[[fmi3Fatal,`fmi3Fatal`]]
`fmi3Fatal`::
The state of all instances of the model is irreparably corrupted.
_[For example, due to a run-time exception such as access violation or integer division by zero during the execution of an FMI function.]_
Function <<logMessage>> was called by the FMU.
It is not allowed to call any other function for any instance of the FMU.

==== Inquire Version Number of Header Files [[inquire-version-number]]

[[fmi3GetVersion,`fmi3GetVersion`]]
[source, C]
----
include::../headers/fmi3FunctionTypes.h[tags=GetVersion]
----

This function returns `fmi3Version` of the `fmi3Functions.h` header file which was used to compile the functions of the FMU.
This function call is allowed always and in all interface types.

The standard header file as documented in this specification has version `"3.0"`, so this function returns `"3.0"`.

==== Advancing Time [[advancing-time]]

This section highlights the differences of the concept of time (in general the independent variable) for the three different FMI types, ME, CS and SE.

In Model Exchange, time is under the sole control of the importer and its integration algorithm.
The model itself receives the current time to be used in its computation with <<fmi3SetTime>>.
In fact, time is not necessarily advancing linearly as solvers might need to jump back and forth in time to localize events using zero-crossings of <<eventIndicator, event indicators>>.

In Co-Simulation, time advances in (possibly variable) steps negotiated between the co-simulation algorithm of the importer and the FMU.
The importer calls <<fmi3DoStep>> with the <<currentCommunicationPoint>> and a target <<communicationStepSize>> (required to be larger than 0.0).
During this <<fmi3DoStep>>, both importer and FMU might encounter events (or other situations) that require reduction of the <<communicationStepSize>> (potentially even down to 0.0).
The FMU may use <<earlyReturn>> argument of the <<fmi3DoStep>> function to tell the import that the FMU needs to return earlier, and the importer may use the callback <<fmi3CallbackIntermediateUpdate>> to signal the FMU that the later should return earlier.
The output argument <<lastSuccessfulTime>> of <<fmi3DoStep>> allows the FMU to signal the importer its current internal time.

In Scheduled Execution, time has a more discrete form.
The scheduler of the importer activates specific tasks according to the time of the importer.
The time itself is communicated to the FMU as <<activationTime>> argument of <<fmi3ActivateModelPartition>>.

Depending on the instantiated FMI type, the importer is restricted in what functions it is allowed to call in order to drive the simulation.

==== Variables [[fmu-variables]]

FMU and importer use variables to exchange information.
All variables are listed in the <<definition-of-model-variables,`modelDescription.xml`>> as elements of `<fmiModelDescription><ModelVariables>`.

They are identified with a unique handle called <<valueReference, value reference>>.

The attribute <<causality>> defines the direction of the information flow with respect to the FMU (e.g. <<input>>, <<output>>, <<parameter>>).

A variable can be a scalar or an multi-dimensional array.

===== Serialization of Array Variables [[serialization-of_variables]]

When getting or setting the values of array variables, the serialization of array variable values used in C-API function calls, as well as in the XML <<start>> attributes, is defined as row major, i.e., dimension order from left to right for the C-API (e.g. `array[dim1][dim2]...[dimN]`), and the document order in the XML attributes for the respective dimensions.
For this serialization of array variables the sparsity pattern of the array is not taken into account.
All elements of the array, including structural zeros, are serialized.

_[Example: A 2D matrix_
[latexmath]
++++
A = \left( \begin{array}{cc} a_{11}&a_{12}\\
                             a_{21}&a_{22}\\
                             a_{31}&a_{32}\\
            \end{array} \right)
++++
_is serialized as follows:_
[frame="none",grid="none"]
|========================================
|_A[0][0]=a11_ | _memory  address: A_   |
|_A[0][1]=a12_ | _memory  address: A+1_ |
|_A[1][0]=a21_ | _memory  address: A+2_ |
|_A[1][1]=a22_ | _memory  address: A+3_ |
|_A[2][0]=a31_ | _memory  address: A+4_ |
|_A[2][1]=a32_ | _memory  address: A+5_ |
|========================================
_]_


===== Getting and Setting Variable Values [[get-and-set-variable-values]]

Restrictions for setting and getting of variables with certain types, causalities and variabilities are described in the state machine and state descriptions (see <<common-state-machine>>, <<state-machine-model-exchange>> in case of Model Exchange, <<state-machine-co-simulation>> for Co-Simulation and <<state-machine-scheduled-execution>> for Scheduled Execution).

The value of a variable may only be accessed with the respective `fmi3Get/Set{VariableType}` for its type.

The current values of the variables can be inquired with the following functions:

[source, C]
----
include::../headers/fmi3FunctionTypes.h[tags=Getters]
----

* `valueReferences` is a vector of `nValueReferences` value handles that define the variables that shall be inquired.

* `values` is a vector with the actual values of these variables.

* `sizes` is a vector with the actual sizes of the values for binary variables.

* `nValues` provides the number of values in the `values` vector (and `sizes` vector, where applicable) which is only equal to `nValueReferences` if all <<valueReference>>pass:[s] point to scalar variables.

The strings returned by `fmi3GetString`, as well as the binary values returned by `fmi3GetBinary`, must be copied by the importer because the allocated memory for these strings might be deallocated or overwritten by the next call of an FMU function.

It is possible to set the values of variables using the following functions:

[source, C]
----
include::../headers/fmi3FunctionTypes.h[tags=Setters]
----

* `valueReferences` is a vector of `nValueReferences` value handles that define the variables that shall be set.

* `values` is a vector with the actual values of these variables.

* `sizes` is a vector with the actual sizes of the values of binary variables.

* `nValues` provides the number of values in the `values` vector (and `sizes` vector, where applicable) which is only equal to `nValueReferences` if all <<valueReference>>pass:[s] point to scalar variables.

With two exceptions, all variables that are allowed to be set with `fmi3Set{VariableType}` keep their respective values until the next call to `fmi3Set{VariableType}`.
Exceptions:

. Variables of type clock must be deactivated during <<fmi3UpdateDiscreteStates>> by the FMU.
. By setting the complete <<get-set-fmu-state,FMU state>> using <<fmi3SetFMUState>>, all variables are potentially changed.

All strings passed as arguments to `fmi3SetString`, as well as all binary values passed as arguments to `fmi3SetBinary`, must be copied during these function calls, because there is no guarantee of the lifetime of strings or binary values, when these functions return.

===== Getting and Setting the Complete FMU State [[get-set-fmu-state]]

--
The FMU has an internal state consisting of all values that are needed to continue a simulation.
This internal state consists especially of the values of the continuous-time states, iteration variables, <<parameter>> values, <<input>> values, delay buffers, file identifiers, and FMU internal status information.
With the functions of this section, the internal FMU state can be copied and the pointer to this copy is returned to the environment.
The FMU state copy can be set as actual FMU state, in order to continue the simulation from it.

_[Examples for using this feature:_

_For variable step-size control of co-simulation algorithms (get the FMU state for every accepted communication step; if the follow-up step is not accepted, restart co-simulation from this FMU state)._

_For nonlinear Kalman filters (get the FMU state just before initialization; in every sample period, set new continuous states from the Kalman filter algorithm based on measured values; integrate to the next sample instant and inquire the predicted continuous states that are used in the Kalman filter algorithm as basis to set new continuous states)._

_For nonlinear model predictive control (get the FMU state just before initialization; in every sample period, set new continuous states from an observer, initialize and get the FMU state after initialization._
_From this state, perform many simulations that are restarted after the initialization with new input variables proposed by the optimizer).]_

Furthermore, the FMU state can be serialized and copied in a byte vector.
_[This can be, for example, used to perform an expensive steady-state initialization, copy the received FMU state in a byte vector and store this vector on file._
_Whenever needed, the byte vector can be loaded from file and deserialized, and the simulation can be restarted from this FMU state, in other words, from the steady-state initialization.]_

[[fmi3GetFMUState, `fmi3GetFMUState`]]
Function <<fmi3GetFMUState>>::

[source, C]
----
include::../headers/fmi3FunctionTypes.h[tags=GetFMUState]
----

This function makes a copy of the internal FMU state and returns a pointer to this copy (`FMUState`).
If on entry `*FMUState == NULL`, a new allocation is required.
If `*FMUState != NULL`, then `*FMUState` points to a previously returned `FMUState` that has not been modified since.
In particular, <<fmi3FreeFMUState>> had not been called with this `FMUState` as an argument.
_[Function <<fmi3GetFMUState>> typically reuses the memory of this `FMUState` in this case and returns the same pointer to it, but with the actual `FMUState`.]_

[[fmi3SetFMUState, `fmi3SetFMUState`]]
Function <<fmi3SetFMUState>>::

[source, C]
----
include::../headers/fmi3FunctionTypes.h[tags=SetFMUState]
----

This function copies the content of the previously copied `FMUState` back and uses it as actual new FMU state.
The `FMUState` copy still exists.
_[The simulation is restarted at this state, when calling <<fmi3SetFMUState>> with `FMUState`.]_

[[fmi3FreeFMUState, `fmi3FreeFMUState`]]
Function <<fmi3FreeFMUState>>::

[source, C]
----
include::../headers/fmi3FunctionTypes.h[tags=FreeFMUState]
----

This function frees all memory and other resources allocated with the <<fmi3GetFMUState>> call for this `FMUState`.
The argument to this function is the `FMUState` to be freed.
If a null pointer is provided, the call is ignored.
The function returns a null pointer in argument `FMUState`.

These functions can be called, if the optional capability flag <<canGetAndSetFMUState>> is set to `true`.

[[fmi3SerializedFMUStateSize,`fmi3SerializedFMUStateSize`]]
Function <<fmi3SerializedFMUStateSize>>::

[source, C]
----
include::../headers/fmi3FunctionTypes.h[tags=SerializedFMUStateSize]
----

This function returns the `size` of the byte vector, in order that `FMUState` can be stored in it.
With this information, the environment has to allocate an `fmi3Byte` vector of the required length `size`.

[[fmi3SerializeFMUState,`fmi3SerializeFMUState`]]
Function <<fmi3SerializeFMUState>>::

[source, C]
----
include::../headers/fmi3FunctionTypes.h[tags=SerializeFMUState]
----

This function serializes the data which is referenced by pointer `FMUState` and copies this data in to the byte vector `serializedState` of length `size`, that must be provided by the environment.

[[fmi3DeSerializeFMUState,`fmi3DeSerializeFMUState`]]
Function <<fmi3DeSerializeFMUState>>::

[source, C]
----
include::../headers/fmi3FunctionTypes.h[tags=DeSerializeFMUState]
----

This function deserializes the byte vector `serializedState` of length `size`, constructs a copy of the FMU state and returns `FMUState`, the pointer to this copy.

These functions are only supported by the FMU, if the optional capability flags `canGetAndSetFMUState` and `canSerializeFMUState` in `<fmiModelDescription><ModelExchange|CoSimulation|ScheduledExecution>` in the XML file are explicitly set to `true` (see <<fmi-for-model-exchange>>, <<fmi-for-co-simulation>>, <<fmi-for-scheduled-execution>>).
--

==== Clocks [[clocks]]

FMI 3.0 specifies clearly the behavior of a clocked FMU.
FMI 3.0 does not specify how the importer uses this functionality.
This allows different use cases to be implemented with different semantics.

===== Motivation

Clock variables synchronize events between importer and across FMUs, by

. communicating exactly which specific event happens and
. exactly at which time instant, independent from continuous time specified by the arguments of `fmi3SetTime` or `fmi3DoStep`.

The first point solves the issue that an FMU must know exactly which event happens during an *Event Mode* if several events are very close to one another.

The second point solves the issue that computing exactly when an event happens is impossible to guarantee across importer and FMUs when using floating point computations.

===== Concepts

// TODO: add references to Modelica clocks paper PC06 MSL12
// TODO: remove clockReference - clocks are variables, dependencies can be used just like for other variables

This section introduces concepts related to FMI clocks.
<<table-overview-clocks>> shows how these concepts relate.
These concepts are described in detail after the table.

// TODO: mark table as non-normative
_[_

.Overview of Clocks.
[[table-overview-clocks]]
[cols="10,10,15,10,40,40",options="header"]
|====
2+|Clock Type
|Attribute <<causality>>
|Attribute <<interval>>
|Related API Calls and Arguments
|Example

.6+|time-based
.4+|[[periodic]]periodic clock
.4+|`input`
|`constant`
|[[constantClock,`constant`]]<<fmi3SetClock>> in *Event Mode*,
<<fmi3GetInterval>> and <<fmi3GetShift>> in *Initialization Mode*
|clocked PI-controller with a defined constant interval

|`fixed`
|[[fixedClock,`fixed`]]<<fmi3SetClock>> in *Event Mode*,
<<fmi3SetInterval>> in *Initialization Mode*
|clocked PI-controller with an adaptable interval

|`calculated`
|[[calculateClock,`calculated`]]<<fmi3SetClock>> in *Event Mode*,
<<fmi3GetInterval>> and <<fmi3GetShift>> in *Initialization Mode*
|clocked PI-controller with interval defined by fixed parameter(s) of the FMU

|`tunable`
|[[tunableClock,`tunable`]]<<fmi3SetClock>> in *Event Mode*,
<<fmi3GetShift>> in *Initialization Mode*,
<<fmi3GetInterval>> in *Event Mode*
|clocked PI-controller with interval defined by tunable parameter(s) of the FMU

// TODO should we rename aperiodic clocks to variable clocks to align keyword and name?
|[[aperiodic]]aperiodic clock
|`input`
|`variable`
|[[variable,`variable`]]<<fmi3SetClock>> in *Event Mode*,
<<fmi3GetInterval>> in *Initialization Mode* and in *Event Mode* if and only if this clock ticked
|simulation of the behavior of a control algorithm with variable execution time, generation of pulse sequences

|countdown clock
|`input`
|`countdown`
|[[countdown,`countdown`]]<<fmi3SetClock>> in *Event Mode*,
<<fmi3GetInterval>> in *Initialization Mode* and in every *Event Mode*
|time-delayed actions after and event, for example, ignition signal some time after specific crank shaft angle

.2+|triggered
|input clock
|`input`
|`triggered`
|[[triggered,`triggered`]]<<fmi3SetClock>> in *Event Mode*,
arguments <<clocksAboutToTick>> (<<fmi3DoStep>>) and <<clocksTicked>> (<<fmi3CallbackIntermediateUpdate>>)
|control algorithm, triggered by a crankshaft angle

|output clock
|`output`
|`triggered`
|<<fmi3GetClock>> in *Event Mode*,
arguments <<clocksAboutToTick>> (<<fmi3DoStep>>) and <<clocksTicked>> (<<fmi3CallbackIntermediateUpdate>>),
|crankshaft angle sensor ticking several times per revolution

|====

_]_

Clocks are <<discrete>> <<fmu-variables,variables>> with a special semantic.

Time-based clocks::

are in a sense predictable and help the importer to take these clock ticks into account a priori.
All time-based clocks are defined to be input clocks because the importer calls <<fmi3SetClock>> on these clocks.
The importer queries the FMU about when a time-based clock should be activated.
The importer will then activate the clock by calling <<fmi3SetClock>> with `values == fmi3ClockActive`.
+
The next <<clock>> activation at time instant latexmath:[t_i] is defined as:
[latexmath]
++++
\begin{align*}
t_0 &:= t_{\mathit{start}} + t_{\mathit{shift}} \\
t_i &:= t_{i-1} + \Delta T_{i}], i = 1,2,3,{...}
\end{align*}
++++

where:

.Mathematical Notation Description.
[#table-notation-description]
[cols="1,2"]
|===
|latexmath:[t_0]
|The time instant at which the <<clock>> is activated the first time.

|latexmath:[t_{\mathit{start}}]
|Start of simulation as defined by the argument <<startTime>> of <<fmi3EnterInitializationMode>>.

|latexmath:[t_{\mathit{shift}}]
|Delay for the first clock activation, defined differently for the different clock types.

|latexmath:[t_{i-1}]
|The previous time instant, where the <<clock>> ticked.

|latexmath:[\Delta T_{i} > 0]
|The time interval from the previous <<clock>> tick to the current <<clock>> tick, defined differently for the different clock types.
|===

[[periodic-clock-ticks]]Periodic clocks::
are time-based clocks which have a constant interval during the execution, except `interval = tunable` which indicates changes when <<tunable>> parameters change this clock interval depends on.
The time instant of the first clock activation is defined by a <<shift>>.

Periodic clocks can also be defined using rational numbers (see <<resolution>>).
In this case, <<clock>> activations are defined as (see <<#table-notation-description>> for notation):
[latexmath]
++++
\begin{align*}
t_0 &:= t_{\mathit{start}} + (\mathit{shiftCounter} / \mathit{resolution}) \\
t_i &:= t_{i-1} + (\mathit{intervalCounter} / \mathit{resolution})
\end{align*}
++++

Constant periodic clocks::
are time-based periodic clocks that define their interval and <<shift>> in the <<modelDescription.xml>>.

Fixed periodic clocks::
are time-base periodic clocks which can be activated by the importer with an arbitrary, but constant interval starting after an arbitrary <<shift>>.
The importer informs the FMU about the interval using <<fmi3SetInterval>>.

Calculated periodic clocks::
are time-base periodic clocks where the interval and <<shift>> depend on <<fixed>> <<parameter, parameters>>.
The importer must use <<fmi3GetInterval>> and <<fmi3GetShift>> to retrieve the clock interval and <<shift>> in *Initialization Mode*.

Tunable periodic clocks::
are time-base periodic clocks where the interval depends on <<tunable>> <<parameter, parameters>>.
The importer must use <<fmi3GetInterval>> to retrieve the clock interval in *Event Mode*, if any of the <<tunable>> <<parameter, parameters>> it depends on was changed.
<<shift>> may only depend on <<fixed>> <<parameter, parameters>>.
The importer must use <<fmi3GetShift>> to retrieve the clock <<shift>> in *Initialization Mode*.

Aperiodic clocks::
are time-based clocks where the next interval is unchangeably known right after the clock just ticked.
<<fmi3GetInterval>> must be called to retrieve the first interval in *Initialization Mode* and every next clock interval in every *Event Mode* if and only if the corresponding clock ticked.
Calling <<fmi3GetShift>> is not allowed.

Countdown clocks::
are time-based clocks where the next interval is not yet known right after the clock just ticked, forcing the importer to call <<fmi3GetInterval>> in *Initialization Mode* and in every *Event Mode*.
The return argument <<qualifier>> of <<fmi3GetInterval>> is used to indicate if the next interval is already known.
Calling <<fmi3GetShift>> is not allowed.

Triggered clocks::
tick unpredictably.

Triggered input clocks::
are activated with <<fmi3SetClock>> by the importer in *Event Mode*.

Triggered output clocks::
are activated within the FMU and the importer must call <<fmi3GetClock>> in *Event Mode*.
There are two mechanisms for an FMU to communicate to the importer that a triggered output clock is about to tick:
 * early return from a <<fmi3DoStep>> with <<clocksAboutToTick, `clocksAboutToTick == fmi3True`>>, and
 * calling <<fmi3CallbackIntermediateUpdate>> with <<clocksTicked, `clocksTicked == fmi3True`>>.

// --> Mathematical Description of Event Mode
// TODO: non-normative call sequence proposal (maybe import from Reference/Example FMU code)
// TODO: definition clocked partition and clocked variables with the equations (1) and (2) --> Event Mode
// TODO: describe auto-reset of clocks in UdpateDiscreteStates --> Event Mode
// TODO: describe deactivation of clock via fmi3SetClock(..., fmi3Deactivate) - clocked variable values return to previous values --> Event Mode
// TODO: forward link to "Clock Type Definition" and fix that section

===== Scheduled Execution

An external scheduler needs to know when an triggered <<inputClock>> depends on an <<outputClock>> of the same FMU.
When the <<outputClock>> ticks, the scheduler will trigger the corresponding <<inputClock>> according to all other scheduling constraints.
The <<triggeredBy>> attribute of an <<inputClock>> defines such a relationship.

In case more than one clock have to be activated at the same time instant, the scheduler needs a priority to define the activation sequence.
This ordering is defined by the <<priority>> attributes of the <<inputClock, `input clocks`>>.

_[For real-time computation use cases, the priority information is used also for task preemption configurations._
_It is therefore important to restrict the number of distinct priority levels for an FMU to available priority levels on the target platform and/or to avoid unnecessary computational overhead._
_A common number of different priority levels is, e.g., 100 (0 to 99), as defined in Linux based operating systems.]_

_[The clock priorities are local to an FMU._
_It is not possible for an FMU exporting tool to know in advance the priorities of other FMUs that will be connected to an FMU in a simulation setup._
_It is the task of the importer to derive a computational order for the computation of two or more distinct FMUs based on the local FMU clock priorities and input-output relationships of connected FMUs.]_

_[For periodic <<clock,`clocks`>> it is recommended to derive the priorities based on a rate monotonic scheduling scheme (smallest period leads to highest priority, that is, has the smallest priority value.]_

[[fmi3GetInterval]]
===== [[fmi3SetInterval]][[fmi3GetShift]] API

For some <<clock>> types, the interval [[fmi3SetInterval,`fmi3SetInterval`]] is set by the environment for the current time instant by the function <<fmi3SetIntervalDecimal>> or <<fmi3SetIntervalFraction>>:

[[fmi3SetIntervalDecimal,`fmi3SetIntervalDecimal`]]
[source, C]
----
include::../headers/fmi3FunctionTypes.h[tag=SetIntervalDecimal]
----

[[fmi3SetIntervalFraction,`fmi3SetIntervalFraction`]]
[source, C]
----
include::../headers/fmi3FunctionTypes.h[tag=SetIntervalFraction]
----

* `interval` is a vector of size `nValues` containing the clock interval to be set.

* `intervalCounter` and `resolution` are vectors of size `nValues` containing the clock intervals specified in the <<modelDescription.xml>>, see <<resolution>>.

For other clock types, the importer calls <<fmi3GetIntervalDecimal>> or <<fmi3GetIntervalFraction>> to query the next clock interval:

[[fmi3GetIntervalDecimal,`fmi3GetIntervalDecimal`]]
[source, C]
----
include::../headers/fmi3FunctionTypes.h[tag=GetIntervalDecimal]
----

[[fmi3GetIntervalFraction,`fmi3GetIntervalFraction`]]
[source, C]
----
include::../headers/fmi3FunctionTypes.h[tag=GetIntervalFraction]
----

[[qualifier,`qualifier`]]
* `qualifier` describes how to treat the `shift` and `shiftCounter` arguments and is defined as:
[[fmi3IntervalQualifier,`fmi3IntervalQualifier`]]
[source, C]
----
include::../headers/fmi3FunctionTypes.h[tag=IntervalQualifier]
----

[[shift, `shift`]]
For some clocks, the importer has to query the delay to the first clock tick from the FMU using the following functions[[fmi3GetShift,`fmi3GetShift`]]:

[[fmi3GetShiftDecimal,`fmi3GetShiftDecimal`]]
[source, C]
----
include::../headers/fmi3FunctionTypes.h[tag=GetShiftDecimal]
----

[[fmi3GetShiftFraction,`fmi3GetShiftFraction`]]
[source, C]
----
include::../headers/fmi3FunctionTypes.h[tag=GetShiftFraction]
----

* `shift` and `shiftCounter` define the time of the first clock activation, as defined in <<shiftCounter>>.


The following table summarizes the use of the API functions by the environment for different kinds of <<clock,`clocks`>>:

.Clock-API functions.
[#table-clock-api]
[cols="2,2,2"]
|===
|API function
|<<outputClock,`Output clocks` and `Local clocks`>>
|<<inputClock,`Input clocks`>>

|`fmi3GetClock`
|Call during *Event Mode* and only in SE in *Intermediate Update Mode*.
|Not allowed

|`fmi3SetClock`
|Not allowed
|Call after entering *Event Mode*.
Repeated calls if recomputations of clock state are needed during *Event Mode*.

|`fmi3GetIntervalDecimal` `fmi3GetIntervalFraction`
|Call during *Event Mode* and only in SE in *Intermediate Update Mode*.
|Not allowed

|`fmi3SetIntervalDecimal` `fmi3SetIntervalFraction`
|Not allowed
|Call after first <<clock>> activation.
(only for periodic <<clock,`clocks`>>)
|===


==== Getting Partial Derivatives

It is optionally possible to provide evaluation of partial derivatives for an FMU.
For Model Exchange, this means computing the partial derivatives at any time instant, whereas for Co-Simulation, this means computing the partial derivatives at a communication point.

An FMU has different states and in every state an FMU might be described by different equations and different unknowns.
The precise definitions are given in the mathematical descriptions of Model Exchange (<<math-model-exchange>>) and Co-Simulation (<<math-co-simulation>>).
In every state, the general form of the FMU equations are:

[latexmath]
++++
\mathbf{v}_{\mathit{unknown}} = \mathbf{h}(\mathbf{v}_{\mathit{known}}, \mathbf{v}_{\mathit{rest}}),
++++

where

* latexmath:[\mathbf{v}_{\mathit{unknonwn}}] is the vector of unknown floating point variables computed in the actual state:

** *Initialization Mode*: The exposed unknowns listed as elements `<ModelStructure><InitialUnknown>` that have a floating point type.

** *Continuous-Time Mode* (Model Exchange): The continuous-time outputs and state derivatives (= the variables listed as elements `<ModelStructure><Output>` with a floating point type and <<variability>> = <<continuous>> and the variables listed as elements `<ModelStructure><Derivative>`).

** *Event Mode* (Model Exchange): The same variables as in the *Continuous-Time Mode* and additionally variables listed as elements `<ModelStructure><Output>` with a floating point type and <<variability>> = <<discrete>>.

** *Step Mode* (Co-Simulation): The variables listed as elements `<ModelStructure><Output>` with a floating point type and <<variability>> = <<continuous>> or <<discrete>>.
Each state derivative variable listed as elements `<ModelStructure><Derivative>`, if present.

* latexmath:[\mathbf{v}_{\mathit{known}}] is the vector of known floating point <<input>> variables of function *h* that changes its value in the actual state.
Details about which variables are in latexmath:[\mathbf{v}_{\mathit{known}}] are given in the description of element <<dependencies>> in <<ModelStructure>>.

* latexmath:[{\mathbf{v}_{\mathit{rest}}}] is the set of <<input>> variables of function *h* that either changes its value in the actual state but are non-floating point variables, or do not change their values in this state, but change their values in other states _[for example, discrete-time <<input,`inputs`>> in *Continuous-Time Mode*]_.

_[The variable relationships are different in different states._
_For example, during *Continuous-Time Mode*, a continuous-time output y does not depend on discrete-time <<input,`inputs`>> (because they are held constant between events)._
_However, at *Event Mode*, y depends on discrete-time <<input,`inputs`>>._
_The function may compute the directional derivatives by numerical differentiation taking into account the sparseness of the equation system, or (preferred) by analytic derivatives.]_

There are two access functions for partial derivatives:

- <<fmi3GetDirectionalDerivative>> to compute the directional derivatives latexmath:[\mathbf{v}_{\mathit{sensitivity}} = \mathbf{J} \cdot \mathbf{v}_{\mathit{seed}}], and

- <<fmi3GetAdjointDerivative>> to calculate the adjoint derivatives latexmath:[\mathbf{v}_{\mathit{sensitivity}}^T = \mathbf{v}_{\mathit{seed}}^T \cdot \mathbf{J}]

with the Jacobian

[latexmath]
++++
\mathbf{J}
=
\begin{bmatrix}
\frac{\partial h_1}{\partial v_{\mathit{known},1}} & \cdots & \frac{\partial h_1}{\partial v_{\mathit{known},n}} \\
\vdots & \ddots & \vdots \\
\frac{\partial h_m}{\partial v_{\mathit{known},1}} & \cdots & \frac{\partial h_m}{\partial v_{\mathit{known},n}}
\end{bmatrix}
++++

where latexmath:[\mathbf{v}_{\mathit{known}}] are the latexmath:[n] knowns, and latexmath:[\mathbf{h}] are the latexmath:[m] functions to calculate the latexmath:[m] unknwon variables latexmath:[\mathbf{v}_{\mathit{unknwon}}]  from the knowns.

Both functions can also be used to construct the partial derivative matrices.
The functions may only be called if their availability is indicated by the attributes `providesDirectionalDerivatives` and `providesAdjointDerivatives` respectively.

[[fmi3GetDirectionalDerivative,`fmi3GetDirectionalDerivative`]]
[source, C]
----
include::../headers/fmi3FunctionTypes.h[tags=GetDirectionalDerivative]
----

[[fmi3GetAdjointDerivative,`fmi3GetAdjointDerivative`]]
[source, C]
----
include::../headers/fmi3FunctionTypes.h[tags=GetAdjointDerivative]
----

Both functions have the same arguments:

* `unknowns` contains value references to the unknowns.
* `nUnknowns` contains the length of argument `unknowns`.
* `knowns` contains value references of the knowns.
* `nKnowns` contains the length of argument `knowns`.
* `seed` contains the components of the seed vector.
* `nSeed` contains the length of `seed`.
* `sensitivity` contains the components of the sensitivity vector.
* `nSensitivity` contains the length of `sensitivity`.

_[Note that array variables will be serialized, so `nSeed` is only equal to `nKnowns` in the case of directional derivatives (resp., equal to `nUnknowns` in the case of adjoint derivatives) if all value references of `knowns` (resp., `unknowns`) point to scalar variables._
_Likewise `nSensitivity` is only equal to `nUnknowns` (resp., `nKnowns`) if all value references of `unknowns` (resp., `knowns`) point to scalar variables.]_

===== Directional Derivatives

[[example-directional-derivatives]]
_[Example:_ +
_Assume an FMU has the output equations_

[latexmath]
++++
\begin{bmatrix}
y_1
\\
y_2
\end{bmatrix}
=
\begin{bmatrix}
g_1(x, u_1, u_3, u_4)
\\
g_2(x, u_1)
\end{bmatrix}
++++

_and this FMU is connected, so that latexmath:[{y_1, u_1, u_3}] appear in an algebraic loop._
_Then the nonlinear solver needs a Jacobian and this Jacobian can be computed (without numerical differentiation) provided the partial derivative of latexmath:[{y_1}] with respect to latexmath:[{u_1}] and latexmath:[{u_3}] is available._
_Depending on the environment where the FMUs are connected, these <<derivative,`derivatives`>> can be provided:_

(a) _with one wrapper function around function <<fmi3GetDirectionalDerivative>> to compute the directional derivatives with respect to these two variables (in other words, latexmath:[{v_{\mathit{unknown}} = y_1}], latexmath:[{v_{\mathit{known}} = \left \{ u_1, u_3 \right \}}]), and then the environment calls this wrapper function with latexmath:[{v_{\mathit{seed}} = \left \{ 1, 0 \right \}}] to compute the partial derivative with respect to latexmath:[{u_1}] and latexmath:[{v_{\mathit{seed}} = \left \{ 0, 1 \right \}}] to compute the partial derivative with respect to latexmath:[{u_3}], or_

(b) _with two direct function calls of <<fmi3GetDirectionalDerivative>> (in other words, latexmath:[{v_{\mathit{unknown}} = y_1, v_{\mathit{known}} = u_1, v_{\mathit{seed}} = 1}]; and latexmath:[{v_{\mathit{unknown}} = y_1, v_{\mathit{known}} = u_3, v_{\mathit{seed}} = 1}])._

_Note that a direct implementation of this function with analytic derivatives:_

(a) _Provides the directional derivative for all <<input>> variables; so in the <<example-directional-derivatives,above example>>: latexmath:[{\Delta y_1 = \frac{\partial g_1}{\partial x} \cdot \Delta x + \frac{\partial g_1}{\partial u_1} \cdot \Delta u_1 + \frac{\partial g_1}{\partial u_3} \cdot \Delta u_3 + \frac{\partial g_1}{\partial u_4} \cdot \Delta u_4}]_

(b) _Initializes all seed-values to zero; so in the <<example-directional-derivatives,above example>>: latexmath:[{\Delta x = \Delta u_1 = \Delta u_3 = \Delta u_4 = 0}]_

(c) _Computes the directional derivative with the seed-values provided in the function arguments; so in the <<example-directional-derivatives,above example>>: latexmath:[{v_{\mathit{sensitivity}} = \Delta y_1 (\Delta x = 0, \Delta u_1 = 1, \Delta u_3 = 0, \Delta u_4 = 0)}]] and latexmath:[{v_{\mathit{sensitivity}} = \Delta y_1 (\Delta x = 0, \Delta u_1 = 0, \Delta u_3 = 1, \Delta u_4 = 0)}]]_

_[Note, function <<fmi3GetDirectionalDerivative>> can be utilized for the following purposes:_

- _Numerical integrators of stiff methods need matrix latexmath:[{\frac{\partial \mathbf{f}}{\partial \mathbf{x}}}]._

- _If the FMU is connected with other FMUs, the partial derivatives of the state derivatives and outputs with respect to the continuous states and the <<input,`inputs`>> are needed in order to compute the Jacobian for the system of the connected FMUs._

- _If the FMU shall be linearized, the same <<derivative,`derivatives`>> as in the previous item are needed._

- _If the FMU is used as the model for an extended Kalman filter, latexmath:[{\frac{\partial \mathbf{f}}{\partial \mathbf{x}}}] and latexmath:[{\frac{\partial \mathbf{g}}{\partial \mathbf{x}}}] are needed._

_If a dense matrix shall be computed, the columns of the matrix can be easily constructed by successive calls of <<fmi3GetDirectionalDerivative>>._
_For example, constructing the system Jacobian latexmath:[{\mathbf{A} = \frac{\partial \mathbf{f}}{\partial \mathbf{x}}}] as dense matrix can be performed in the following way:_

[source, C]
----
include::Reference-FMUs/examples/jacobian.c[tags=GetJacobian]
----

_If the sparsity of a matrix shall be taken into account, then the matrix can be constructed in the following way:_

- _The incidence information of the matrix (whether an element is zero or not zero) is extracted from the XML file from element `<ModelStructure>`._

- _A so called graph coloring algorithm is employed to determine the columns of the matrix that can be computed by one call of `fmi3GetDirectionalDerivative`._
_Efficient graph coloring algorithms are freely available, such as library https://cscapes.cs.purdue.edu/coloringpage/[ColPack] written in C/C++ (LGPL), or the routines by <<CGM84>>._
_See e.g. http://www.netlib.org/toms/618._

- _For the columns determined in (2), one call to <<fmi3GetDirectionalDerivative>> is made._
_After each such call, the elements of the resulting directional derivative vector are copied into their correct locations of the partial derivative matrix._

_More details and implementational notes are available from <<ABL12>>._

_Example:_

_Directional derivatives for higher dimension variables are almost treated in the same way.
Consider, for example, an FMU which calculates its output latexmath:[{Y}] by multiplying its 2x2 input latexmath:[{U}] with a 3x2 constant gain latexmath:[{K}], with_

[latexmath]
++++
K=
\begin{bmatrix}
a, b
\\
c, d
\\
e, f
\end{bmatrix}
++++
_The output latexmath:[{Y=K U}] is a matrix of size 3x2._
_The directional derivative of an output element latexmath:[{Y(i,j)}] with respect to the input latexmath:[{U}] and the seed latexmath:[{\Delta U}] is:_

[latexmath]
++++
\Delta Y(i,j) =
\frac{\partial Y(i,j)}{\partial U(1,1)} \cdot \Delta U(1,1) +
\frac{\partial Y(i,j)}{\partial U(1,2)} \cdot \Delta U(1,2) +
\frac{\partial Y(i,j)}{\partial U(2,1)} \cdot \Delta U(2,1) +
\frac{\partial Y(i,j)}{\partial U(2,2)} \cdot \Delta U(2,2)
++++

[latexmath]
++++
\Delta \mathbf{Y} =
\begin{bmatrix}
a \Delta U(1,1)+b \Delta U(2,1), a \Delta U(1,2)+ b \Delta U(2,2)
\\
c \Delta U(1,1)+d \Delta U(2,1), c \Delta U(1,2)+ d \Delta U(2,2)
\\
e \Delta U(1,1)+f \Delta U(2,1), e \Delta U(1,2)+ f \Delta U(2,2)
\end{bmatrix}
++++

_To get the directional derivative of latexmath:[{Y}] with respect to latexmath:[{U(2,1)}] the command `fmi3GetDirectionalDerivative(m, vr_Y, 1, vr_U, 1, {0.0, 0.0, 1.0, 0.0}, 4, dd, 6)` can be used where `vr_Y` and `vr_U` are references of the variable latexmath:[{Y}] and latexmath:[{U}], respectively._
_Note that in order to get the directional derivative of latexmath:[{Y}] with respect to latexmath:[{U(2,1)}], the seed value `{0, 0, 1.0, 0}` has been used._
_The retrieved directional derivative `dd` is stored in a matrix of size 3x2, so `nSensitivity` is 6._

===== Adjoint Derivatives

_[Adjoint derivatives are beneficial in several contexts:_

* _in artificial intelligence (AI) frameworks the adjoint derivatives are called "vector gradient products" (VJPs)._
_There adjoint derivatives are used in the backpropagation process to perform gradient-based optimization of parameters using reverse mode automatic differentiation (AD), see, e.g., <<BPRS15>>._

* _in parameter estimation (see <<BKF17>>)_

_Typically, reverse mode automatic differentiation (AD) is more efficient for these use cases than forward mode AD, as explained in the cited references._

_If one would like to construct the full Jacobian matrix, one can use either <<fmi3GetDirectionalDerivative>> (to column-wise construct it) or <<fmi3GetAdjointDerivative>> (to row-wise construct it, possibly improved with coloring methods as mentioned above)._
_However in the applications motivating the adjoint derivatives, one does not need the full Jacobian matrix latexmath:[\mathbf{J}], but vector  latexmath:[\mathbf{v}^T] multiplied from the left to the Jacobian, i.e. latexmath:[\mathbf{v}^T\mathbf{J}]._
_For computing the full Jacobian matrix, the column-wise construct is generally more efficient.]_

_Example:_ +
_Assume an FMU has the output equations_

[latexmath]
++++
\begin{bmatrix}
y_1
\\
y_2
\end{bmatrix}
=
\begin{bmatrix}
h_1(u_1, u_2)
\\
h_2(u_1, u_2)
\end{bmatrix}
++++

_and latexmath:[\left( w_1,  w_2 \right)^T \cdot \mathbf{ \frac{\partial h}{\partial u} }] for some vector latexmath:[\left( w_1,  w_2 \right)^T] is needed._
_Then one can get this with one function call of <<fmi3GetAdjointDerivative>> (with arguments_ latexmath:[\mathbf{v}_{\mathit{unknown}} = \text{valueReferences of} \left \{ y_1, y_2 \right \},  \mathbf{v}_{\mathit{known}} = \text{valueReferences of} \left \{ u_1, u_2 \right \},  \mathbf{v}_{\mathit{seed}} = \left( w_1, w_2 \right)^T] _), while with <<fmi3GetDirectionalDerivative>> at least two calls would be necessary to first construct the Jacobian column-wise and then multiplying from the right with_ latexmath:[\left( w_1,  w_2 \right)^T] _._

_If a dense matrix shall be computed, the rows of the matrix can be easily constructed by successive calls of <<fmi3GetAdjointDerivative>>._
_For example, constructing the system Jacobian latexmath:[{\mathbf{A} = \frac{\partial \mathbf{f}}{\partial \mathbf{x}}}] as a dense matrix can be performed in the following way:_

[source, C]
----
include::Reference-FMUs/examples/jacobian.c[tags=GetJacobianAdjoint]
----

_]_

==== Getting Number of Variable Dependencies and Variable Dependencies

The sparseness information within arrays is not given in the xml description.
The sparseness muss be retrieved during run-time using the C-API functions.
Zeros in the Jacobian are not necessarily due to the structure of the model.
Zero in the Jacobian might be due to the current operating point (current <<state>>, current <<input,`inputs`>>) and not due to a structural independence.

The variable dependency information in the XML description does not resolve to dependencies of individual array elements, nor does it take into account changing dependencies due to resizing of arrays via <<structuralParameter,`structural parameters`>>.
An FMU can indicate via the `providesPerElementDependencies` capability flag that it is able to provide detailed dependency information at runtime through the following C-API.
Note that these functions are only defined if the capability flag `providesPerElementDependencies = true`.

The number of dependencies of a given variable, which may change if <<structuralParameter,`structural parameters`>> are changed, can be retrieved by calling the following function:

[[fmi3GetNumberOfVariableDependencies,`fmi3GetNumberOfVariableDependencies`]]
[source, C]
----
include::../headers/fmi3FunctionTypes.h[tags=GetNumberOfVariableDependencies]
----

This function returns the number of <<dependencies>> for a given variable.

* `valueReference` specifies the <<valueReference>> of the variable for which the number of <<dependencies>> should be returned.

* `nDependencies` points to the `size_t` variable that will receive the number of <<dependencies>>.

[[fmi3GetVariableDependencies,`fmi3GetVariableDependencies`]]
The actual <<dependencies>> (of type `fmi3DependencyKind`) can be retrieved by calling the function `fmi3GetVariableDependencies`:

[source, C]
----
include::../headers/fmi3FunctionTypes.h[tags=DependencyKind]

include::../headers/fmi3FunctionTypes.h[tags=GetVariableDependencies]
----

This function returns the dependency information for a single variable.

* `dependent` specifies the <<valueReference>> of the variable for which the dependencies should be returned.

* `nDependencies` specifies the number of dependencies that the calling environment allocated space for in the result buffers, and should correspond to value obtained by calling <<fmi3GetNumberOfVariableDependencies>>.

* `elementIndicesOfDependent` must point to a buffer of `size_t` values of size `nDependencies` allocated by the calling environment.
It is filled in by this function with the element index of the dependent variable that dependency information is provided for.
The element indices start with 1. Using the element index 0 means all elements of the variable.
(Note: If an array has more than one dimension the indices are serialized in the same order as defined for values in <<serialization-of_variables>>.)

* `independents` must point to a buffer of `fmi3ValueReference` values of size `nDependencies` allocated by the calling environment.
It is filled in by this function with the value reference of the <<independent>> variable that this dependency entry is dependent upon.

* `elementIndicesIndependents` must point to a buffer of `size_t` values of size `nDependencies` allocated by the calling environment.
It is filled in by this function with the element index of the <<independent>> variable that this dependency entry is dependent upon.
The element indices start with 1.
Using the element index 0 means all elements of the variable.
(Note: If an array has more than one dimension the indices are serialized in the same order as defined for values in <<serialization-of_variables>>.)

* `dependencyKinds` must point to a buffer of `fmi3DependencyKind` values of size `nDependencies` allocated by the calling environment.
It is filled in by this function with the enumeration value describing the dependency of this dependency entry.

If this function is called before the <<fmi3ExitInitializationMode>> call, it returns the initial dependencies.
If this function is called after the <<fmi3ExitInitializationMode>> call, it returns the run-time dependencies.
The retrieved dependency information of one variable becomes invalid as soon as a <<structuralParameter,`structural parameter`>> linked to the variable or to any of its depending variables are set.
As a consequence, if you change <<structuralParameter,`structural parameters`>> affecting B or A, the dependency of B becomes invalid.
The dependency information must change only if <<structuralParameter,`structural parameters`>> are changed.
