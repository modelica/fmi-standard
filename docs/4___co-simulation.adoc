== FMI for Co-Simulation [[fmi-for-co-simulation]]

This chapter defines the Functional Mock-up Interface (FMI) for the coupling of two or more simulation models in a co-simulation environment (FMI for Co-Simulation).
It is designed both for coupling with subsystem models, which have been exported by their simulator together with its solver as runnable code (<<figure-co-simulation-with-generated-code>>), and for coupling of simulation tools on a single machine (<<figure-co-simulation-with-tool-coupling>>) or as part of a distributed co-simulation (<<figure-distributed-co-simulation>>).

In FMI version 3.0 the following new features have been added:

* signaling of <<clock>> ticks (i.e. events/interrupts) from the FMU to simulation environment
* signaling of <<clock>> ticks from simulation environment to the FMU
* definition of multiple model rates (periodic, variable/triggerable) in one FMU
* access to intermediate values of the FMU's variables between two communication points

Please refer to the different sections for a more detailed explanation of the motivation and use of the new features.

[[co-simulation]]
Co-Simulation::
Co-simulation is a rather general approach to the simulation of coupled technical systems and coupled physical phenomena in engineering with focus on instationary (time-dependent) problems.
The basic Co-Simulation interface is similar to the feature set of FMI 2.0 for Co-Simulation.
The asynchronous mode for FMUs has been removed since this mode was not supported by tools and it can be suitably replaced by Co-Simulation master implementations that control the asynchronous computation of FMUs via separate tasks/threads created for each FMU.

[[co-simulation-with-early-return]]
Early Return::
In FMI 3.0, an FMU is allowed to stop the execution of <<fmi3DoStep>> and return without reaching the predefined communication instant, i.e. `currentCommunicationPoint + communicationStepSize`.
This mechanism is called "early return".
With the early return feature, an FMU can signal <<outputClock>> events or internal state changes, i.e., discontinuity events to the Co-Simulation master at any time (not only at the end of <<fmi3DoStep>> function calls).
When an internal event occurs inside the FMU at a time instant, it informs the master that a new communication point for the Co-Simulation can be created.
Note that an event signal is not seen in the narrow sense of solver induced discontinuity events but in the general sense of a simulation event that has to be handled by the Co-Simulation master (e.g. state changes that require extended handling).
On a multi-node architecture, in particular, significant co-simulation speed-up may be obtained if the Co-Simulation master can avoid waiting until the end of the slowest <<fmi3DoStep>> when many FMUs are integrating in parallel and an event occurred.
To exploit such efficiency gains also the Co-Simulation master can command the FMU to return early from the current communication step.
This is even helpful if the FMU or the Co-Simulation master do not support the advanced handling of events based on the <<api-hybrid-co-simulation, Hybrid Co-Simulation>> functionalities.
In this way multiple event types and also <<outputClock>> ticks or interrupts can be supported based on the early return functionality and additional functionalities provided by <<api-hybrid-co-simulation,Hybrid Co-Simulation>>.

[[clocked-co-simulation]]
Clocked Co-Simulation::
The <<api-hybrid-co-simulation,Hybrid Co-Simulation>> interface provides functionalities to control and observe the ticking of <<clock,clocks>>.
For FMI for Co-Simulation, the ticking of a clock is interpreted as an activity of the associated model partition.
During simulation, the Co-Simulation master updates and manages values of inputs and outputs of FMUs and further models at communication points for each model partition.
The ratio between communication points created for a model partition and time can be seen as a model rate.
In that sense multiple model partitions of a model define multiple model rates in a model.

[[scheduled-co-simulation]]
Scheduled Co-Simulation::
The <<api-hybrid-co-simulation,Hybrid Co-Simulation>> interface provides an indirect control over the computation of model partitions.
With <<api-scheduled-co-simulation,Scheduled Co-Simulation>> a simulation master can directly control the time of computation (i.e. scheduling) for such model partitions.
+
The Scheduled Co-Simulation interface addresses simulation use cases that require:
+
* That at any time (even for unpredictable events) an event can be signaled to an FMU
* If multiple FMUs share (execution) resources, the time requirements (e.g. execution time, communication deadlines) of all model partitions have to be observed and respected
** Time requirements may exist due to communication constraints (that are not apparent at FMU simulation level) which have to be fulfilled by the simulation master
** That requires a global execution order and preemption policy for all model partitions of the multiple FMUs
** Priority information provided by the FMUs has to be evaluated and merged to an overall priority for available model partitions
* Data shall move between the different FMU model partitions for the same or next activation time, if direct communication via FMUs exist.
** Get/set operations must also be possible for the same activation time for different model partitions between the computation of these model partitions.
+
This Co-Simulation interface provides support for concurrent computation of model partitions (i.e. a support of multiple rates) on a single computational resource (e.g. CPU-core) of an FMU.
For that a preemptive multitasking regime is intended (cooperative multitasking is not covered by this description).
+
_[A parallel computation of model partitions is not part of the FMI 3.0 API._
_An FMU may still internally use parallel computation on multiple cores, but handling this is (currently) not part of the FMI standard. Such an internal parallel computation is not visible to the simulation master._
_It is a tool vendor specific solution that has ties to the used OS and the co-simulation environment]_

[[intermediate-variable-access]]
Intermediate Variable Access::
An FMU shall be able to inform a Co-Simulation master that is able to provide intermediate output variables and/or receive intermediate input variables at any time, i.e. not only at the end of a current <<fmi3DoStep>> function call.
It shall be possible for the FMU to inform the master whether the internal solver is in a temporary state or if it has just completed an internal integration step.
If the internal solver is in a temporary state, intermediate output variables shall only be used for directly computing intermediate input variables.
If the internal integration step is completed, the master can forward intermediate outputs to interconnected simulation units.

Coupling Scenarios::
+
.Co-simulation with generated code on a single computer (for simplicity shown for one slave only).
[#figure-co-simulation-with-generated-code]
image::images/co-simulation-single-slave.svg[width=50%, align="center"]
+
.Co-simulation with tool coupling on a single computer (for simplicity shown for one slave only).
[#figure-co-simulation-with-tool-coupling]
image::images/co-simulation-tool-coupling.svg[width=70%, align="center"]
+
In the tool coupling case the FMU implementation wraps the FMI function calls to API calls which are provided by the simulation tool (for example, a COM or CORBA API).
Additionally to the FMU the simulation tool is needed to run a co-simulation.
+
In its most general form, a tool coupling based co-simulation is implemented on distributed hardware with subsystems being handled by different computers with different OSs (cluster computer, computer farm, computers at different locations).
The data exchange and communication between the subsystems is typically performed using one of the network communication technologies (for example, MPI, TCP/IP).
The definition of this communication layer is not part of the FMI standard.
However, distributed co-simulation scenarios can be implemented using FMI as shown in <<figure-distributed-co-simulation>>.
+
.Distributed co-simulation infrastructure (for simplicity shown for one slave only).
[#figure-distributed-co-simulation]
image::images/co-simulation-distributed-infrastructure.svg[width=90%, align="center"]
+
The master has to implement the communication layer.
Additional parameters for establishing the network communication (for example, identification of the remote computer, port numbers, user account) are to be set via the GUI of the master.
These data are not transferred via the FMI API.

For all Co-Simulation interfaces intermediate variable access can be activated, if the FMU and the master supports this.
More information can be found in <<intermediate-variable-access>>.

The Co-Simulation master signals to the FMU which features shall be used for the current instance of the FMU in <<fmi3Instantiate>>:

[source, C]
----
include::../headers/fmi3FunctionTypes.h[tag=Instantiate]
----

Additionally the Co-Simulation master provides the required Co-Simulation features via the argument `fmuCoSimulationConfiguration`:

[source, C]
----
include::../headers/fmi3FunctionTypes.h[tag=CoSimulationConfiguration]
----

The master can only select a certain Co-Simulation interface for an FMU if the following attributes are set in the  `modelDescription.xml`.

[cols="1,2",options="header"]
|===
|Co-Simulation interface
|Required attributes

|`fmi3CoSimulation`
|`canNotUseBasicCoSimulation = false`

|`fmi3HybridCoSimulation`
|`providesHybridCoSimulation = true`, `canReturnEarlyAfterIntermediateUpdate = true`

|`fmi3ScheduledCoSimulation`
|`providesScheduledCoSimulation = true`
|===

Generally it is assumed, that a Co-Simulation FMU always supports the interface `fmi3CoSimulation`.
If that is not possible for an FMU (e.g. if the FMU cannot provide an emulation of <<inputClock>> tick occurrences), it has to include the capability flag `canNotUseBasicCoSimulation = true` in the `modelDescription.xml`.

If the FMU does not support the Co-Simulation interface selected in <<fmi3Instantiate>> it has to return `NULL`.

Multiple Co-Simulation Interface Support in one FMU::
Exporters are encouraged to support multiple Co-Simulation interfaces in one FMU, so it can be used in differently capable Co-Simulation master implementations and for different use cases.
_[That improves the reusability of FMUs._
_A common application of this multiple mode support is the reuse of FMUs for real-time and non-real-time simulations.]_
+
The described multi mode support is based on wrapping functionality into the <<fmi3DoStep>> function by emulating missing features of the Co-Simulation interface, the FMU has been originally exported for.
+
An FMU that supports <<api-scheduled-co-simulation,Scheduled Co-Simulation>> will in most cases also support <<api-hybrid-co-simulation,Hybrid Co-Simulation>>.
+
_[Wrapping towards other Co-Simulation interfaces can influence the simulation results._
_Depending on the model especially wrapping towards the (basic) Co-Simulation interface may result in divergent simulation results._
_Especially aperiodic <<inputClock,`input clocks`>> can not always be sufficiently emulated in modes that do not directly support <<clock,`clocks`>>._
_Therefore it is recommended that the FMU provides logging information to the user about the influence of the current mode on simulation results, if non-optimal modes are used by the simulation environment.]_
