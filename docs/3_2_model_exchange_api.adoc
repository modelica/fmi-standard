=== Application Programming Interface

This section contains the interface description to evaluate different model parts from a C program.

==== Providing Independent Variables and Re-initialization of Caching [[providing-independent-variables-and-re-initialization]]

Depending on the situation, different variables need to be computed.
In order to be efficient, it is important that the interface requires only the computation of variables that are needed in the present context.
For example, during the iteration of an integrator step, only the state derivatives need to be computed, provided the <<output>> of a model is not connected.
It might be that at the same time instant other variables are needed.
For example, if an integrator step is completed, the event indicator functions need to be computed as well.
If the state derivatives have already been computed at the present time instant, then it is important for efficiency that they are not newly computed in the call to compute the event indicator functions.
This means, the state derivatives shall be reused from the previous call.
This feature is called "caching of variables" in the sequel. +
Caching requires that the model evaluation can detect when the input arguments, like time or states, have changed.
This is achieved by setting them explicitly with a function call, since every such function call signals precisely a change of the corresponding variables.
For this reason, this section contains functions to set the input arguments of the equation evaluation functions.
This is unproblematic for time and states, but is more involved for <<parameter,`parameters`>> and <<input,`inputs`>>, since the latter may have different data types.

[source, C]
----
fmi3Status fmi3Set{VariableType}(..);
----

Set new values for <<parameter,`parameters`>>, <<start>> values and <<input,`inputs`>> and re-initialize caching of variables that depend on these variables.
The details of these functions are defined in <<get-and-set-variable-values>>.

_[The functions above have the slight drawback that values must always be copied._
_For example, a call to_ <<fmi3SetContinuousStates>> _will provide the actual states in a vector, and this function has to copy the values in to the internal model data structure so that subsequent evaluation calls can utilize these values._
_If this turns out to be an efficiency issue, a future release of FMI might provide additional functions to provide the address of a memory area where the variable values are present.]_

==== State Machine for Model Exchange [[state-machine-model-exchange]]

Every implementation of the FMI for Model Exchange must support calling sequences of the functions according to the state machine in <<figure-model-exchange-state-machine>>.

.Calling sequence of Model Exchange C functions.
[#figure-model-exchange-state-machine]
image::images/state-machine-model-exchange.svg[width=60%, align="center"]

Common states are defined in <<common-state-machine>>, such as super states <<FMUStateSetable,*FMU State Setable*>> and  <<Initialized,*Initialized*>>, states <<Instantiated,*Instantiated*>>, <<ConfigurationMode,*Configuration Mode*>>, <<ReconfigurationMode,*Reconfiguration Mode*>>, <<InitializationMode,*Initialization Mode*>>, <<EventMode,*Event Mode*>> and <<Terminated,*Terminated*>>.

===== State: Continuous-Time Mode

The *Continuous-Time Mode* is used by the importer to compute the values of all continuous-time variables between events by numerically solving ordinary differential and algebraic equations.
All discrete-time variables are fixed during this phase and the corresponding discrete-time equations are not evaluated.

In this state, the continuous-time equations are active and integrator steps are performed.

[#table-math-model-exchange]
[cols="7,3",options="header"]
|====
|Equations
|Functions

|latexmath:[\mathbf{t} := (]<<time>>latexmath:[, 0)]
|<<fmi3SetTime>>

|Set continuous-time <<input,`inputs`>> latexmath:[\mathbf{u}_{c}(\mathbf{t})]
|`fmi3Set{VariableType}`

|Set continuous-time <<state,`states`>> latexmath:[\mathbf{x}_{c}(\mathbf{t})]
|`fmi3SetFloat64`, <<fmi3SetContinuousStates>>

a|latexmath:[(\mathbf{y}_{c}, \mathbf{\dot{x}}_c, \mathbf{z}, \mathbf{w}_{c}) := \mathbf{f}_{\mathit{cont}}(\mathbf{x}_{c}, {}^\bullet\mathbf{x}_{d}, \mathbf{u}_{c}, {}^\bullet\mathbf{u}_{d}, \mathbf{p}, {}^\bullet\mathbf{r}, {}^\bullet\mathbf{b}, \mathbf{t})]
a|
`fmi3Get{VariableType}`,
<<fmi3GetDerivatives>>,
<<fmi3GetEventIndicators>>

a|
* Evaluate model equations with valid values for the right-hand side: +
latexmath:[(\mathbf{y}_{c}, \mathbf{\dot{x}}_c, \mathbf{z}, \mathbf{w}_{c}, \mathbf{b},] <<enterEventMode>> latexmath:[) := \mathbf{f}_{\mathit{comp}}(\mathbf{x}_{c}, {}^\bullet\mathbf{x}_{d}, \mathbf{u}_{c}, {}^\bullet\mathbf{u}_{d}, \mathbf{p}, {}^\bullet\mathbf{r}, {}^\bullet\mathbf{b}, \mathbf{t})]
* Update previous values of <<buffers>>: latexmath:[{}^\bullet\mathbf{b}:=\mathbf{b}]

|<<fmi3CompletedIntegratorStep>>

a|
* Evaluate latexmath:[\mathbf{f}_{\mathit{cont}}], if no `fmi3GetXXX` function was called
* Deactivate continuous-time equations latexmath:[\mathbf{f}_{\mathit{cont}}]
* Activate event equations latexmath:[\mathbf{f}_{\mathit{event}}]
* latexmath:[\mathbf{t}:=(\mathbf{t}_\mathit{R}, 0)]
|<<fmi3EnterEventMode>>

|====

Allowed Function Calls::

[[fmi3SetTime,`fmi3SetTime`]]
Function <<fmi3SetTime>>::
[source, C]
----
include::../headers/fmi3FunctionTypes.h[tags=SetTime]
----
Set a new value for the independent variable (typically a time instant).

 * [[time,`time`]] Argument `time` is the new value for the real part latexmath:[\mathbf{t}_\mathit{R}] of latexmath:[\mathbf{t} := (\mathbf{t}_\mathit{R}, 0)].
 <<time>> must be larger or equal to:
  - <<startTime>>,
  - the time at the last call to <<fmi3CompletedIntegratorStep>>,
  - the time at the last call to <<fmi3EnterEventMode>>.

[[fmi3SetContinuousStates,`fmi3SetContinuousStates`]]
Function <<fmi3SetContinuousStates>>::
[source, C]
----
include::../headers/fmi3FunctionTypes.h[tags=SetContinuousStates]
----
Set a new (continuous) state vector and re-initialize caching of variables that depend on the <<state,`states`>>.

* Argument `nContinuousStates` is the length of

* argument `continuousStates`

and is provided for checking purposes (variables that depend solely on<<constant,`constants`>>, <<parameter,`parameters`>>, time, and <<input,`inputs`>> do not need to be newly computed in the sequel, but the previously computed values can be reused).
Note that the continuous <<state,`states`>> might also be changed in *Event Mode*.
Note that <<fmi3Discard,`fmi3Status == fmi3Discard`>> is possible.

[[fmi3GetDerivatives,`fmi3GetDerivatives`]]
Function <<fmi3GetDerivatives>>::
[source, C]
----
include::../headers/fmi3FunctionTypes.h[tags=GetDerivatives]
----

[[fmi3GetEventIndicators,`fmi3GetEventIndicators`]]
Function <<fmi3GetEventIndicators>>::
[source, C]
----
include::../headers/fmi3FunctionTypes.h[tags=GetEventIndicators]
----

Compute state derivatives (that is derivatives w.r.t. to the <<independent>> variable also taking into account its unit) and event indicators at the current instant of the <<independent>> variable _[typically: time]_ and for the current <<state,`states`>>.
Note that <<fmi3Discard,`fmi3Status == fmi3Discard`>> is possible for both functions.

The <<derivative,`derivatives`>> are returned as a vector with `nContinuousStates` elements.
The ordering of the elements of the `derivatives` vector must be identical to the ordering of the `continuousStates` vector (for example, `derivatives[2]` is the <<derivative>> of `continuousStates[2]`).
The order of the `continuousStates` and `derivatives` vector must be the same as the ordered list of elements `<ModelStructure><Derivative>`.
_[Array variables are serialized as defined in <<serialization-of_variables>>.]_

The event indicators are returned as a vector with `nEventIndicators` elements.
The order of the `eventIndicators` vector must be the same as the ordered list of elements `<ModelStructure><EventIndicator>`.
_[Array variables are serialized as defined in <<serialization-of_variables>>.]_

[[state-event,state event]]
A <<state event>> is triggered when the domain of an event indicator changes from latexmath:[z_j > 0] to latexmath:[z_j \leq 0] or vice versa.
_[This definition is slightly different from the usual standard definition of state events:_ "latexmath:[z(t)*z(t_{i-1}) \leq 0]" _which has the severe drawback that the value of the event indicator at the previous event instant,_ latexmath:[z(t_{i-1}) \neq 0], _must be non-zero and this condition cannot be guaranteed._
_The often used term "zero crossing function" for `z` is misleading (and is therefore not used in this document), since a state event is defined by a change of a domain and not by a zero crossing of a variable.]_
The FMU must guarantee that after leaving *Event Mode* latexmath:[z_j \neq 0], for example, by shifting latexmath:[z_j] with a small value.
_[All event indicators should be piecewise continuous._
_Furthermore, latexmath:[z_j] should be scaled in the FMU with its nominal value (so all elements of the returned vector `eventIndicators` should be in the order of 1).]_

.An event occurs when the event indicator changes its domain from latexmath:[z>0] to latexmath:[z\leq 0] or vice versa.
[#figure-events]
image::images/Event.svg[width=60%, align="center"]

[[fmi3CompletedIntegratorStep,`fmi3CompletedIntegratorStep`]]
Function <<fmi3CompletedIntegratorStep>>::
[source, C]
----
include::../headers/fmi3FunctionTypes.h[tags=CompletedIntegratorStep]
----

// TODO: fix the following
Such an event is called <<step event>>.
_[<<step event,`Step events`>> are, for example, used to dynamically change the (continuous) <<state,`states`>> of a model internally in the FMU, because the previous states are no longer suited numerically.]_

This function must be called by the environment after every completed step of the integrator provided the capability flag `completedIntegratorStepNotNeeded = false`.
Argument `noSetFMUStatePriorToCurrentPoint == fmi3True` if `fmi3SetFMUState` will no longer be called for time instants prior to current time in this simulation run [the FMU can use this flag to flush a result buffer].

* [[enterEventMode,`enterEventMode`]] The return argument `enterEventMode` signals to the environment that the environment shall call <<fmi3EnterEventMode>>.

* Return argument `terminateSimulation` signals if the simulation shall be terminated.

If `enterEventMode == fmi3False` and `terminateSimulation == fmi3False`, the FMU stays in *Continuous-Time Mode* without the environment having to call <<fmi3EnterContinuousTimeMode>> again.
When the integrator step is completed and the <<state,`states`>> are modified by the integrator afterwards _[for example, correction by a BDF method]_, then <<fmi3SetContinuousStates>> has to be called with the updated states before <<fmi3CompletedIntegratorStep>> is called. +
When the integrator step is completed and one or more event indicators change sign (with respect to the previously completed integrator step), then the integrator or the environment has to determine the time instant of the sign change that is closest to the previous completed step up to a certain precision (usually a small multiple of the machine epsilon).
This is usually performed by an iteration where time is varied and <<state>> variables needed during the iteration are determined by interpolation.
Function <<fmi3CompletedIntegratorStep>> must be called after this <<state event>> location procedure and not after the successful computation of the time step by the integration algorithm.
The intended purpose of the function call is to indicate to the FMU that at this stage all <<input,`inputs`>> and <<state>> variables have valid (accepted) values.
After <<fmi3CompletedIntegratorStep>> is called, it is still allowed to go back in time (calling <<fmi3SetTime>>) and inquire values of variables at previous time instants with `fmi3Get{VariableType}` _[for example, to determine values of non-state variables at output points]_.
However, it is not allowed to go back in time over the previous <<fmi3CompletedIntegratorStep>> or the previous <<fmi3EnterEventMode>> call.

_[This function might be used, for example, for the following purposes:_

_Delays:_ +
_All variables that are used in a "delay(..)" operator are stored in an appropriate buffer and the function returns with `enterEventMode == fmi3False`, and <<terminateSimulation,`terminateSimulation == fmi3False`>>._

. _Dynamic state selection:_ +
_It is checked whether the dynamically selected states are still numerically appropriate._
_If yes, the function returns with `enterEventMode == fmi3False`  otherwise with `enterEventMode == fmi3True`._
_In the latter case, <<fmi3EnterEventMode>> has to be called and the states are dynamically changed by a subsequent <<fmi3UpdateDiscreteStates>>._

_Note that this function is not used to detect time or <<state event,`state events`>>, for example, by comparing event indicators of the previous with the current call of <<fmi3CompletedIntegratorStep>>._
_These types of events are detected in the environment, and the environment has to call <<fmi3EnterEventMode>> independently in these cases, whether the return argument `enterEventMode` of <<fmi3CompletedIntegratorStep>> is `fmi3True` or `fmi3False`.]_

[[fmi3EnterEventMode,`fmi3EnterEventMode`]]
Function <<fmi3EnterEventMode>>::
[source, C]
----
include::../headers/fmi3FunctionTypes.h[tags=EnterEventMode]
----

This function changes the state to *Event Mode*.

* `stepEvent` signals with `fmi3True` that a <<step event>> occurred.

* `rootsFound` is an array of length `nEventIndicators` that signals if a <<state event>> occurred.
For `i = 1, ..., nEventIndicators, rootsFound[i-1] != 0` if the event indicator latexmath:[z_i] has a root, and `rootsFound[i-1] == 0` if not.
For the components latexmath:[z_i] for which a root was found, the sign of `rootsFound[i-1]` indicates the direction of the zero-crossing.
A value of `+1` indicates that latexmath:[z_i] is increasing, while a value of `-1` indicates a decreasing latexmath:[z_i].
If `nEventIndicators == 0` the value of `rootsFound` is not defined.

* `nEventIndicators` contains the number of event indicators (length of `rootsFound`) or `0` if the caller cannot provide this information.

[[timeEvent,`timeEvent`]]
* `timeEvent` signals with `fmi3True` that a <<time event>> occurred.

_[An <<input-event>> can be detected by the FMU by keeping track of the calls of `fmi3Set{VariableType}` in *Event Mode*.]_

Function <<fmi3EnterConfigurationMode>>::
If the environment wants to change <<structuralParameter,`structural parameters`>>, it must move the FMU into *Reconfiguration Mode* using <<fmi3EnterConfigurationMode>>.

Function <<fmi3GetDirectionalDerivative>>::
See <<fmi3GetDirectionalDerivative>>.

[[fmi3GetContinuousStates,`fmi3GetContinuousStates`]]
Function <<fmi3GetContinuousStates>>::
[source, C]
----
include::../headers/fmi3FunctionTypes.h[tags=GetContinuousStates]
----

Return the new continuous state vector `continuousStates`.
The order of the states is also the same as the ordered list of elements `<ModelStructure><Derivative>`.
_[Array variables are serialized as defined in <<serialization-of_variables>>.]

==== Code Example

In the following example, the usage of the `fmi3XXX` functions is sketched in order to clarify the typical calling sequence of the functions in a simulation environment.
Furthermore, it is assumed that one FMU is directly integrated in a simulation environment.
If the FMU would be used inside another model, additional code is needed, especially initialization and event iteration has to be adapted.

[source, c]
----
include::Reference-FMUs/examples/model_exchange.c[tags=ModelExchange]
----

In the code above errors are handled by the following definition:

[source, C]
----
include::Reference-FMUs/examples/util.h[tags=CheckStatus]
----
