==== FMI Description Schema

This is defined in <<fmi-description-schema>>.
Additionally, the co-simulation specific element "Implementation" is defined in the next section.

===== Co-Simulation FMU (CoSimulation) [[CoSimulation]]
//TODO: find better place for attribute description!
//TODO: check wording "slave"

If the XML file defines an FMU for Co-Simulation, element "CoSimulation" must be present.
It is defined as:

//TODO: update XML images
image::images/cs_xml_1.png[width=80%, align="center"]

image::images/cs_xml_2.png[width=70%, align="center"]

These attributes have the following meaning (all attributes are optional with exception of `modelIdentifier`):

//TODO: describe possible and impossible combinations.  

[cols="1,1",options="header"]
|====
|Attribute Name
|_Description_

|`modelIdentifier`
|Short class name according to C syntax, for example, "A_B_C".
Used as prefix for FMI functions if the functions are provided in C source code or in static libraries, but not if the functions are provided by a DLL/SharedObject.
`modelIdentifier` is also used as name of the static library or DLL/SharedObject.
See also <<header-files-and-naming-of-functions>>.

|`needsExecutionTool`
|If true, a tool is needed to execute the model.
The FMU just contains the communication to this tool (see <<figure-co-simulation-with-tool-coupling>>).
_[Typically, this information is only utilized for information purposes.
For example, a co-simulation master can inform the user that a tool has to be available on the computer where the slave is instantiated.
The name of the tool can be taken from attribute `generationTool` of `fmiModelDescription`.]_

|`canBeInstantiatedOnlyOncePerProcess`
|This flag indicates cases (especially for embedded code), where only one instance per FMU is possible. (For multiple instantiation the default is `false`; if multiple instances are needed, the FMUs must be instantiated in different processes.).

|`canNotUseMemoryManagementFunctions`
|If true, the slave uses its own functions for memory allocation and freeing only.
The callback functions `allocateMemory` and `freeMemory` given in `fmi3Instantiate` are ignored.

|`canGetAndSetFMUState`
|If true, the environment can inquire the internal FMU state and restore it.
That is, `fmi3GetFMUState`, `fmi3SetFMUState`, and `fmi3FreeFMUState` are supported by the FMU.

|`canSerializeFMUState`
|If true, the environment can serialize the internal FMU state, in other words, `fmi3SerializedFMUStateSize`, `fmi3SerializeFMUState`, `fmi3DeSerializeFMUState` are supported by the FMU.
If this is the case, then flag `canGetAndSetFMUState` must be true as well.

|`providesDirectionalDerivative`
|If true, the directional derivative of the equations at communication points can be computed with `fmi3GetDirectionalDerivative`.

|`maxOutputDerivativeOrder`
|The slave is able to provide derivatives of outputs with maximum order.
Calling of `fmi3GetRealOutputDerivatives` is allowed up to the order defined by `maxOutputDerivativeOrder`.

|`canHandleVariableCommunicationStepSize`
|The slave can handle variable communication step size.
The communication step size (parameter communicationStepSize of `fmi3DoStep`) has not to be constant for each call.

|`providesIntermediateVariableAccess`
|The slave is able to provide access to selected variables during callback funtion call `intermediateUpdate()`. 
The accessible variables are marked with attribute `intermediateAccess` equals true. 

|`canReturnEarlyAfterIntermediateUpdate`
|The slave is able to return early from `fmi3DoStep()` if master calls `fmi3DoEarlyReturn()` during callback funtion call `intermediateUpdate()` and `canReturnEarly` equals true in `fmi3IntermediateUpdateInfo`.

|`providesHybridCoSimulation`
|If true, the slave can be set to co-simulation mode `fmi3ModeHybridCoSimulation` during instantiation of FMU.

|`providesScheduledExecutionSimulation`
|If true, the slave can be set to co-simulation mode `fmi3ModeScheduledExecutionSimulation` during instantiation of FMU.

|`canNotUseBasicCoSimulation`
|If false, the slave can be set to co-simulation mode `fmi3ModeCoSimulation` during instantiation of FMU.
_[the support of basic co-simulation should be possible for most co-simulation FMUs, thus the default value is false.]_



|====

The flags have the following default values. +
boolean: false +
unsignedInt: 0 +

Note that if `needsExecutionTool = true`, then it is required that the original tool is available to be executed in co-simulation mode.
If `needsExecutionTool = false`, the slave is completely contained inside the FMU in source code or binary format (DLL/SharedObject).

===== Example XML Description File [[xml-example-co-simulation]]

The example below is the same one as shown in <<xml-example-model-exchange>> for a ModelExchange FMU.
The only difference is the replacement of element ModelExchange by element CoSimulation (with additional attributes) and the removal of local variables, which are associated with continuous states and their derivatives.
The XML file may have the following content:

[source, xml]
----
include::examples/co_simulation.xml[]
----
