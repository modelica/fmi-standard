=== Mathematical Description [[math-model-exchange]]

==== Basic Definitions [[basic-definitions-model-exchange]]

The goal of the Model Exchange interface is to numerically solve a system of differential, algebraic and discrete-time equations.
In this version of the interface, ordinary differential equations in state-space representation with events are handled (abbreviated as "hybrid ODE").
Algebraic equation systems might be contained inside the FMU.
Also, the FMU might consist of discrete-time equations only, for example, describing a sampled-data controller.

The <<independent>> variable latexmath:[t \in \mathbb{T}] _[typically: time]_ is a tuple latexmath:[t = (t_R,t_I)], where latexmath:[t_R \in \mathbb{R},\ t_{I} \in \mathbb{N} = \{0, 1, 2, \ldots\}].
The real part latexmath:[t_R] of this tuple is the <<independent>> variable of the FMU for describing the continuous-time behavior of the model between events.
During continuous-time integration latexmath:[t_I = 0].
The integer part latexmath:[t_I] of this tuple is a counter to enumerate (and therefore distinguish) the events at the same continuous-time instant latexmath:[t_R].
This time definition is also called "super-dense time" in literature, see, for example, <<LZ07>>.
An ordering is defined on latexmath:[\mathbb{\text{T}}] that leads to the notation in <<table-model-exchange-math-notation>>.
_[The notation latexmath:[^{\bullet}t] is from <<BCP10,BCP10>>, adapted from non-standard analysis to super-dense time, in order to precisely define the value from the previous event iteration.]_

.Conventions and notation used.
[#table-model-exchange-math-notation]
[cols="1,7,4"]
|====
|Operation
|Mathematical meaning
|Description

^|latexmath:[t_1 < t_2]
|latexmath:[(t_{\mathit{R1}},t_{\mathit{I1}}) < (t_{\mathit{R2}}, t_{\mathit{I2}})\ \Leftrightarrow \ t_{\mathit{R1}} < t_{\mathit{R2}}\ \textbf{or} \ t_{\mathit{R1}}= t_{\mathit{R2}} \ \textbf{and} \ t_{\mathit{I1}} < t_{\mathit{I2}}]
|latexmath:[t_1] is before latexmath:[t_2]

^|latexmath:[t_1 = t_2]
|latexmath:[(t_{\mathit{R1}},t_{\mathit{I1}}) = (t_{\mathit{R2}},t_{\mathit{I2}}) \ \Leftrightarrow  t_{\mathit{R1}}= t_{\mathit{R2}}\ \textbf{and} \ t_{\mathit{I1}} = t_{\mathit{I2}}]
|latexmath:[t_1] is identical to latexmath:[t_2]

^|latexmath:[t^{+}]
|latexmath:[{{(t}_{R},t_{I})}^{+} \Leftrightarrow (\lim_{\mathit{\epsilon \rightarrow 0}}{\left(t_{R} + \varepsilon \right),t_{\mathit{Imax}})}]
|right limit at latexmath:[t].
latexmath:[t_{\mathit{Imax}}] is the largest occurring integer index of super-dense time

^|latexmath:[^-t]
|latexmath:[^{-}{{(t}_{R},t_{I})} \Leftrightarrow (\lim_{\mathit{\epsilon \rightarrow 0}}{\left( t_{R} - \varepsilon \right),0)}]
|left limit at latexmath:[t]

^|latexmath:[^{\bullet}t]
|latexmath:[^{\bullet}{\left( t_{R},t_{I} \right)\ } \Leftrightarrow \left\{ \begin{matrix} ^-t \ & \mathbf{if} \ t_I = 0 \\ (t_R, t_I - 1) \ & \mathbf{if} \ t_I > 0 \\ \end{matrix} \right.]
|previous time instant (= either left limit or previous event instant).

^|latexmath:[v^+]
|latexmath:[v(t^+)]
|value at the right limit of latexmath:[t]

^|latexmath:[^{-}v]
|latexmath:[v(^-t)]
|value at the left limit of latexmath:[t]

^|latexmath:[^{\bullet}v]
|latexmath:[v(^{\bullet}t)]
|previous value (= either left limit or value from the previous event)
|====

_[Assume that an FMU has an event at latexmath:[t_R=2.1s] and here a signal changes discontinuously._
_If no event iteration occurs, the time instant when the event occurs is defined as (2.1, 0), and the time instant when the integration is restarted is defined as (2.1, 1).]_

The hybrid ODEs supported by FMI are described as piecewise continuous-time systems.
Discontinuities can occur at time instants latexmath:[t_0, t_1, \ldots, t_n] where latexmath:[t_i < t_{i+1}].
These time instants are called `events`.
Events can be known before hand (= <<time event>>), or are defined implicitly (= <<state event,`state`>> and <<step event,`step events`>>), see below.
Between events, variables are either <<continuous>> or do not change their value.
A variable is called discrete-time, if it changes its value only at an event instant.
Otherwise the variable is called continuous-time.
Only floating point variables can be continuous-time.
The following variable indices are used to describe the timing behavior of the corresponding variable (for example, latexmath:[v_d] is a discrete-time variable):

[cols="1,10"]
|====
|Index
|Description

|`x`
|A continuous-time variable latexmath:[x(t)],
is a continuous function of time inside each interval latexmath:[t_i^+ < \ ^-t_{i+1}]

|`m`
|A piece-wise <<constant>> variable latexmath:[m(t)], is constant inside each interval latexmath:[t_i^+ < \ ^-t_{i+1}].

|`c`
| A *Clock* variable latexmath:[c(t)], is active only at particular time instants.

|`r`
|A *Clocked* variable latexmath:[r(t)], is a variable of a numeric type, string or enumeration associated to a <<clock>> latexmath:[c(t)] and therefore active only at particular time instants.

|====
At every event instant latexmath:[t_i], variables might be discontinuous (see <<figure-piecewise-continuous-variables>>).

.Piecewise-continuous variables of an FMU: continuous-time (latexmath:[v_c]) and discrete-time (latexmath:[v_d]).
[#figure-piecewise-continuous-variables]
image::images/PieceWiseContinuousVariables.svg[width=60%]

The next event instance latexmath:[t_i] is defined by the earliest occurrence of one of the following conditions:

. The environment of the FMU triggers an event at the current time instant because at least one discrete-time <<input>> changes its value, a continuous-time <<input>> has a discontinuous change, or a <<tunable>> <<parameter>> changes its value.
Such an event is called external event.
_[Note that if an FMU A is connected to an FMU B, and an event is triggered for A, then potentially all <<output,`outputs`>> of A will be discontinuous at this time instant._
_It is therefore advisable to trigger an external event for B at this time instant too if an <<output>> of A is connected to B._
_This means to call <<fmi3EnterEventMode>> on B.]_ +
+
All the following events are internal events:

. At a predefined time instant latexmath:[t_i=T_{\mathit{next}}(t_{i-1}, 0)] that was defined at the previous event instant latexmath:[t_{i-1}] by the FMU.
Such an event is called <<time event>>.

. At a time instant, where an event indicator latexmath:[z_j(t)] changes its domain from latexmath:[z_j > 0] to latexmath:[z_j \leq 0] or from latexmath:[z_j \leq 0] to latexmath:[z_j > 0] (see <<figure-events>>).
More precisely: An event latexmath:[t = t_i] occurs at the smallest time instant latexmath:[t] with latexmath:[t>t_{i-1}] where latexmath:[(z_j(t)>0) \neq (z_j(t_{i-1}) >0)].
Such an event is called <<state event>>.
_[This definition is slightly different from the standard definition of <<state event,`state events`>>: _ latexmath:[z_j(t) \cdot z_j(t_{i-1}) \leq 0] _._
_This often used definition has the severe drawback that_ latexmath:[z_j(t_{i-1}) \neq 0] _is required in order to be well-defined and this condition cannot be guaranteed.]._
All event indicators are piecewise continuous and are collected together in one vector of floating point numbers latexmath:[\mathbf{z(t)}]. +

.An event occurs when the event indicator changes its domain from latexmath:[z>0] to latexmath:[z\leq 0] or vice versa.
[#figure-events]
image::images/Event.svg[width=60%, align="center"]

[start=4]
. At every completed step of an integrator, <<fmi3CompletedIntegratorStep>> must be called (provided the capability flag `completedIntegratorStepNotNeeded` of `<fmiModelDescription>` is `false`).
An event occurs at this time instant, if indicated by the return argument `enterEventMode == fmi3True`.
Such an event is called <<step event>>.
_[<<step event,`Step events`>> are, for example, used to dynamically change the (continuous) <<state,`states`>> of a model internally in the FMU, because the previous states are no longer suited numerically.]_

An FMI Model-Exchange model is described by the following variables:

[cols="1,10"]
|====
|Variable
|Description

|latexmath:[t]
|<<independent>> variable _[typically: time]_ latexmath:[\in \mathbb{T}].
(Variable defined with <<causality>> = <<independent>>).

|latexmath:[\mathbf{v}]
|A vector of all exposed variables (all variables defined in element `<ModelVariables>`, see <<definition-of-model-variables>>).
A subset of the variables is selected via a subscript.
Example: latexmath:[\mathbf{v}_{\mathit{initial=exact}}] are variables defined with attribute <<initial>> = <<exact>> (see <<definition-of-model-variables>>).
These are <<parameter,`parameters`>> and start values of other variables, such as initial values for <<state,`states`>>, state derivatives or <<output,`outputs`>>.

|latexmath:[\mathbf{p}]
|Parameters that are constant during simulation.
The symbol without a subscript references <<parameter,`parameters`>> (variables with <<causality>> = <<parameter>>).
Dependent <<parameter,`parameters`>> (variables with <<causality>> = <<calculatedParameter>>) are denoted as latexmath:[\mathbf{p}_{\mathit{calculated}}].

|latexmath:[\mathbf{u}(t)]
|Input variables.
The values of these variables are defined outside of the model.
Variables of this type are defined with attribute <<causality>> = <<input>>.
Whether the <<input>> is a discrete-time or continuous-time variable is defined via attribute <<variability>> = <<discrete>> or <<continuous>> (see <<definition-of-model-variables>>).

|latexmath:[\mathbf{y}(t)]
|Output variables.
The values of these variables are computed in the FMU and they are designed to be used in a model connection.
For instance, output variables might be used in the environment as input values to other FMUs or other submodels.
Variables of this type are defined with attribute <<causality>> = <<output>>.
Whether the <<output>> is a discrete-time or continuous-time variable is defined via attribute <<variability>> = <<discrete>> or <<continuous>> (see <<definition-of-model-variables>>).

|latexmath:[\mathbf{w}(t)]
|Local variables of the FMU that cannot be used for FMU connections.
Variables of this type are defined with attribute <<causality>> = <<local>>, see <<definition-of-model-variables>>.

|latexmath:[\mathbf{z}(t)]
|A vector of floating point continuous-time variables representing the event indicators used to define <<state event,`state events`>> (recall <<figure-events>>).
For notational convenience, an event indicator is conceptually treated as a different type of variable as an <<output>> or a <<local>> variable for the mathematical description in <<table-math-model-exchange>>.
In reality, event indicator is however part of the <<output,`outputs`>> latexmath:[\mathbf{y}] or the <<local>> variables latexmath:[\mathbf{w}] of an FMU.

|latexmath:[\mathbf{x}_c(t)]
|A vector of floating point continuous-time variables representing the continuous-time <<state,`states`>>.
For notational convenience, a continuous-time <<state>> is conceptually treated as a different type of variable as an <<output>> or a <<local>> variable for the mathematical description in <<table-math-model-exchange>>.
In reality, a continuous-time <<state>> is however part of the <<output,`outputs`>> latexmath:[\mathbf{y}] or the <<local>> variables latexmath:[\mathbf{w}] of an FMU.

|latexmath:[\mathbf{x}_d(t)] +
latexmath:[^{\bullet}\mathbf{x}_d(t)]
|latexmath:[\mathbf{x}_d(t)] is a vector of (internal) discrete-time variables (of any type) representing the discrete-time states. +
latexmath:[{}^{\bullet}\mathbf{x}_d(t)] is the value of latexmath:[\mathbf{x}_d(t)] at the previous super-dense time instant, so latexmath:[{}^{\bullet}\mathbf{x}_d(t)=\mathbf{x}_d({}^{\bullet}t)].
Given the previous values of the discrete-time states, latexmath:[{}^{\bullet}\mathbf{x}_d(t)], at the actual time instant latexmath:[t], all other discrete-time variables, especially the discrete-time states latexmath:[\mathbf{x}_d(t)], can be computed. +
Discrete-time states are not visible in the interface of an FMU and are only introduced here to clarify the mathematical description.
In reality, a discrete-time state is part of the <<output,`outputs`>> latexmath:[\mathbf{y}] or the <<local>> variables latexmath:[\mathbf{w}] of an FMU.

|latexmath:[T_{\mathit{next}}(t_{i})]
|At initialization or at an event instant, an FMU can define the next time instant latexmath:[T_{\mathit{next}}], at which the next time event occurs (see also the definition of events above).
Every event removes automatically a previous definition of latexmath:[T_{\mathit{next}}], and it must be explicitly defined again, event if a previously defined latexmath:[T_{\mathit{next}}] was not triggered at the current event instant.

|latexmath:[\mathbf{r}(t_i)]
|A vector of Boolean variables with latexmath:[r_{j} := z_{j} > 0].
When entering *Continuous-Time Mode* all relations reported via the event indicators latexmath:[\mathbf{z}] are fixed and during this mode these relations are replaced by latexmath:[\mathbf{r}].
Only during *Initialization Mode* or *Event Mode* the domains latexmath:[z_{j} > 0] can be changed.
For notational convenience, latexmath:[\mathbf{r} := \mathbf{z} > 0] is an abbreviation for latexmath:[\mathbf{r}:=\{z_1>0, z_2>0, \ldots \}].
_[For more details, see <<Remark3,Remark 3>> below.]_
|====

==== Computation Modes [[computation-modes-model-exchange]]

Computing the solution of an FMI model means to split the solution process in different phases, and in every phase different equations and solution methods are utilized.
The phases can be categorized according to the following modes:

===== Initialization Mode
This mode is used to compute at the start time latexmath:[t_0] initial values for continuous-time <<state,`states`>> latexmath:[\mathbf{x}_c(t_0)], and for the previous (internal) discrete-time states latexmath:[\mathbf{x}_d(t_0)], by utilizing extra equations not present in the other modes (for example, equations to define the <<start>> value for a <<state>> or for the derivative of a <<state>>).

===== Continuous-Time Mode
This mode is used to compute the values of all floating point continuous-time variables between events by numerically solving ordinary differential and algebraic equations.
All discrete-time variables are fixed during this phase and the corresponding discrete-time equations are not evaluated.

===== Event Mode
This mode is used to compute new values for all continuous-time variables, as well as for all discrete-time variables that are activated at the current event instant latexmath:[t], given the values of the variables from the previous instant latexmath:[{}^{\bullet}t].
This is performed by solving algebraic equations consisting of all continuous-time and all active discrete-time equations.

==== Model Evaluations, Dependencies, and Call Sequence

When connecting FMUs together, loop structures can occur that lead to particular difficulties because linear or non-linear algebraic systems of equations in floating point variables but also in Boolean or Integer variables might be present.
In order to solve such systems of equations over FMUs efficiently, the dependency information is needed stating, for example, which <<output,`outputs`>> depend directly on <<input,`inputs`>>.
This data is optionally provided in the XML file under element `<ModelStructure>`.
If this data is not provided, the worst case must be assumed, that is, all <<output>> variables depend algebraically on all <<input>> variables.

_[Example: In <<figure-connected-fmus>> two different types of connected FMUs are shown (the "dotted lines" characterize the dependency information):_

.Calling sequences for FMUs that are connected in a loop.
[#figure-connected-fmus]
image::images/ArtificialAlgebraicLoops.svg[width=80%, align="center"]

_In the left diagram, FMU1 and FMU2 are connected in such a way that by an appropriate sequence of `fmi3Set{VariableType}` and `fmi3Get{VariableType}` calls, the FMU variables can be computed with the following call sequence:_

[source, C]
----
fmi3Instance FMI1, FMI2;
fmi3ValueReference vr_FMU1_u, vr_FMU1_y, vr_FMU2_u1, vr_FMU2_u2, vr_FMU2_y1, vr_FMU2_y2;
fmi3Float64 s=0.1, FMU2_y1, FMU1_y, FMU2_y2;

...

fmi3SetFloat64(FMU2, &vr_FMU2_u1, 1, &s,        1);
fmi3GetFloat64(FMU2, &vr_FMU2_y1, 1, &FMU2_y1,  1);
fmi3SetFloat64(FMU1, &vr_FMU1_u,  1, &FMU2_y1,  1);
fmi3GetFloat64(FMU1, &vr_FMU1_y,  1, &FMU1_y,   1);
fmi3SetFloat64(FMU2, &vr_FMU2_u2, 1, &FMU1_y,   1);
fmi3GetFloat64(FMU2, &vr_FMU2_y1, 1, &FMU2_y2,  1);
...
----


_In the right diagram, FMU3 and FMU4 are connected in such a way that a real algebraic loop is present._
_This loop might be solved iteratively with a Newton method._
_In every iteration the iteration variable latexmath:[u_4] is provided by the solver, and via the shown sequence of `fmi3Set{VariableType}` and `fmi3Get{VariableType}` calls, the residual is computed and is provided back to the solver._
_Based on the residual a new value of latexmath:[u_4] is provided._
_The iteration is terminated when the residual is close to zero._

[source, C]
----
fmi3Instance FMI1, FMI2;
fmi3ValueReference vr_FMU3_u, vr_FMU3_y, vr_FMU4_u, vr_FMU4_y;
fmi3Float64 s, FMU3_y, FMU4_y, residual;
bool converged;

// Newton iteration
while (!converged)
{
  // input s[0] calculated by the solver
  ...
  fmi3SetFloat64(FMU2, &vr_FMU4_u, 1, &s,   1);
  fmi3GetFloat64(FMU2, &vr_FMU4_y, 1, &FMU4_y,  1);
  fmi3SetFloat64(FMU1, &vr_FMU3_u, 1, &FMU4_y,  1);
  fmi3GetFloat64(FMU1, &vr_FMU3_y, 1, &FMU3_y,  1);
  residual=s-FMU3_y; // provided to the solver
}

----

_These types of artificial or real algebraic loops can occur in all the different modes, such as *Initialization Mode*, *Event Mode*, and *Continuous-Time Mode*._
_Since different variables are computed in every mode and the causality of variable computation can be different in *Initialization Mode* as with respect to the other two modes, it might be necessary to solve different kinds of loops in the different modes.]_

In <<table-math-model-exchange>> the equations are defined that can be evaluated in the respective mode.
The following color coding is used in the table:

* [silver]#*grey*#: If a variable in an argument list is marked in [silver]#grey#, then this variable is not changing in this mode and just the last calculated value from the previous mode is internally used.
For an input argument, it is not allowed to call `fmi3Set{VariableType}`.
For an output argument, calling `fmi3Get{VariableType}` on such a variable returns always the same value in this mode.
* [lime]#*green*#: Functions marked in [lime]#green# are special functions to enter or leave a mode.
* [blue]#*blue*#: Equations and functions marked in [blue]#blue# define the actual computations to be performed in the respective mode.

_[In <<table-math-model-exchange>>, the setting of the super-dense time, (latexmath:[t_R], latexmath:[t_I]), is precisely described._
_Tools will usually not have such a representation of time._
_However, super-dense time defines precisely when a new "model evaluation" starts and therefore which variable values belong to the same "model evaluation" at the same (super-dense) time instant and should be stored together.]_

.Mathematical description of an FMU for Model Exchange.
[#table-math-model-exchange]
[cols="5,3"]
|====
|Equations
|FMI functions

2+|Equations before *Initialization Mode*

|Set variables latexmath:[\mathbf{v}_{\mathit{initial=exact}}] and latexmath:[\mathbf{v}_{\mathit{initial=approx}}]  that have a <<start>> value (<<initial>> = <<exact>> or <<approx>>)
|`fmi3Set{VariableType}`

2+|Equations during *Initialization Mode*

|[lime]#Enter *Initialization Mode* at latexmath:[t=t_0] (activate initialization, discrete-time and continuous-time equations). Set <<independent>> variable time latexmath:[T_{\mathit{R0}}] and define latexmath:[t_0 := (t_{\mathit{R0}},0)]#
|`[lime]#fmi3EnterInitializationMode#`

|Set variables latexmath:[\mathbf{v}_{\mathit{initial=exact}}] that have a <<start>> value with
<<initial>> = <<exact>> (<<parameter,`parameters`>> latexmath:[\mathbf{p}] and
continuous-time <<state,`states`>> with <<start>> values latexmath:[\mathbf{x}_{\mathit{c,initial=exact}}] are included here)
|`fmi3Set{VariableType}`

|Set continuous-time and discrete-time <<input,`inputs`>>  latexmath:[\mathbf{u}(\color{grey}t_{\color{grey} 0})]
|`fmi3Set{VariableType}`

|[blue]#latexmath:[\mathbf{v}_{\mathit{initialUnknowns}}:=f_{\mathit{init}}(\mathbf{u_c}, \mathbf{u_d}, \color{grey}t_{\color{grey} 0}, \mathbf{v}_{\mathit{initial=exact}}])#
|`[blue]#fmi3Get{VariableType}#`, `[blue]#fmi3GetContinuousStates#`

|[lime]#Exit *Initialization Mode* (de-activate initialization equations)#
|`[lime]#fmi3ExitInitializationMode#`

2+|Equations during *Event Mode*

|[lime]#Enter *Event Mode* at latexmath:[t = t_{i}] with latexmath:[{t_{i}\ : = (t}_{R},t_{I} + 1)] *if*  externalEvent *or* nextMode latexmath:[\equiv] EventMode *or* latexmath:[t_i=(T_{\mathit{next}}(t_{i-1}), 0)] *or*  latexmath:[\min_{t>t_{i-1}} t:\left\lbrack z_{j}\left( t \right) > 0\  \neq \ z_{j}\left( t_{i-1} \right) > 0 \right\rbrack] +
(activate discrete-time equations)#
|`[lime]#fmi3EnterEventMode#` [lime]#(only from *Continuous-Time Mode*)#

|Set <<tunable>> <<parameter,`parameters`>> latexmath:[\mathbf{p}_{\mathit{tune}}] +
(and do not set other <<parameter,`parameters`>> latexmath:[\mathbf{p}_{\mathit{other}}])
|`fmi3Set{VariableType}`

|Set continuous-time and discrete-time <<input,`inputs`>> latexmath:[\mathbf{u}(t_i)]
|`fmi3Set{VariableType}`

|Set continuous-time <<state,`states`>> latexmath:[\mathbf{x}_c(t_i)]
|`fmi3Set{VariableType}`, <<fmi3SetContinuousStates>>

|[blue]#latexmath:[(\mathbf{y}_{c+d}, \mathbf{\dot{x}}_c, \mathbf{w}_{c+d}, \mathbf{z}, \mathbf{x}_{c,\mathit{reinit}})=\mathbf{f}_{\mathit{sim}}(\mathbf{x_c}, \mathbf{u_{c+d}}, \color{grey}t_{\color{grey} i}, \mathbf{p}_{\mathit{tune}}, \color{grey}{\mathbf{p}_{\mathit{other}})}]#  +
latexmath:[\mathbf{f}_{\mathit{sim}}]is also a function of the internal variables latexmath:[{}^\bullet\mathbf{x}_d]
|`[blue]#fmi3Get{VariableType}#`,
`[blue]#fmi3GetContinuousStates#`,
`[blue]#fmi3GetDerivatives#`
`[blue]#fmi3GetEventIndicators#`

|[lime]#Increment super-dense time and define with#
`[lime]#newDiscreteStatesNeeded#` [lime]#whether a new event iteration is required.# +
[blue]#latexmath:[\qquad]*if not*# `[blue]#newDiscreteStatesNeeded#`[blue]#*then* +
latexmath:[\qquad \qquad T_{\mathit{next}}=T_{\mathit{next}}(\mathbf{x}_c,{}^\bullet\mathbf{x}_d, \mathbf{u_{c+d}}, \color{grey}t_{\color{grey} i}, \mathbf{p}_{\mathit{tune}}, \color{grey}{\mathbf{p}_{\mathit{other}})}]# +
[blue]#latexmath:[\qquad]*end if*# +
[blue]#latexmath:[\qquad t:=t(t_R, t_i+1)]# +
[blue]#latexmath:[\qquad {}^\bullet\mathbf{x}_d:=\mathbf{x}_d]#
|`[lime]#fmi3NewDiscreteStates#`

2+|Equations during *Continuous-Time Mode*

|[lime]#Enter *Continuous-Time Mode*:# +
[lime]#latexmath:[\qquad \textrm{// de-activate discrete-time equations}]# +
[lime]#latexmath:[\qquad \textrm{// "frozen" variables:}]# +
[lime]#latexmath:[\qquad \mathbf{r} := \mathbf{z}>0 \qquad \textrm{//all relations}]# +
[lime]#latexmath:[\qquad \textbf{x}_d, \textbf{w}_d \qquad \textrm{//all discrete-time variables}]# +
|`[lime]#fmi3EnterContinuousTimeMode#`

|Set <<independent>> variable _[typically: time]_ latexmath:[t(>t_{\mathit{enter  mode}}): t:=(\min(t_{Ri} + h, T_{\mathit{next}}), 0)]
|<<fmi3SetTime>>

|Set continuous-time <<input,`inputs`>> latexmath:[\mathbf{u}_{c}(t)]
|`fmi3Set{VariableType}`

|Set continuous-time <<state,`states`>> latexmath:[\mathbf{x}_{c}(t)]
|`fmi3Set{VariableType}`, <<fmi3SetContinuousStates>>

a|[blue]#latexmath:[(\mathbf{y}_{c}\mathbf{,} \color{grey}{\mathbf{y}_{d}}\mathbf{,\ }{\dot{\mathbf{x}}}_{c}\mathbf{,}_{}\mathbf{w}_{c}\mathbf{,}\color{grey}{\mathbf{w}_{d}}\mathbf{,z,}\color{grey}{\mathbf{x}_{c,\mathit{reinit}}}):=\mathbf{f}_{\mathit{sim}}(\mathbf{x}_{c},\ \mathbf{u}_{c}\mathbf{,} \color{grey}{\mathbf{\ u}_{d}}, t,\color{grey}{\mathbf{p}_{\mathit{tune}},\mathbf{p}_{\mathit{other}}})]# +
[blue]#latexmath:[\qquad \mathbf{f}_{\mathit{sim}}] is also a function of the internal variables# [silver]#latexmath:[{}^\bullet\mathbf{x}_{d},\mathbf{r}].#
 a|
`[blue]#fmi3Get{VariableType},#`
`[blue]#fmi3GetDerivatives,#`
`[blue]#fmi3GetEventIndicators#`

|[lime]#Complete integrator step and return `enterEventMode`#
|`[lime]#fmi3CompletedIntegratorStep#`

2+|Data types

2+|latexmath:[t \in \mathbb{R}, \mathbf{p} \in \mathbb{P}^{np},  \mathbf{u}(t) \in \mathbb{P}^{nu},\mathbf{y}(t) \in \mathbb{P}^{ny}, \mathbf{x}_c(t) \in \mathbb{R}^{nxc}, \mathbf{x}_d(t) \in \mathbb{P}^{nxd}, \mathbf{w}(t) \in \mathbb{P}^{nw}, \mathbf{z}(t) \in \mathbb{R}^{nz}] +
latexmath:[\qquad \mathbb{R}]: floating point variable, latexmath:[\mathbb{P}]: floating point *or* Boolean *or* integer *or* enumeration *or* string variable +
latexmath:[\mathbf{f}_{\mathit{init}}, \mathbf{f}_{\mathit{sim}} \in C^0] (=continuous functions with respect to all input parameters inside the respective mode). +
latexmath:[h \in \mathbb{R}] is the simulation step size.
|====

_[Remark 1 - Calling Sequences:_

_In <<table-math-model-exchange>>, for notational convenience in every mode one function call is defined to compute all output arguments from all inputs arguments._
_In reality, every scalar output argument can be computed by one `fmi3Get{VariableType}` function call._
_Additionally, the output argument need not be a function of all input arguments, but of only a subset from it, as defined in the XML file under `<ModelStructure>`._
_This is essential when FMUs are connected in a loop, as shown in <<figure-connected-fmus>>. For example, since_ latexmath:[y_{\mathit{2a}}] _depends only on_ latexmath:[u_{\mathit{1a}}] _, but not on_ latexmath:[u_{\mathit{1b}}]_, it is possible to call_ `fmi3Set{VariableType}` _to set_ latexmath:[u_{\mathit{1a}}] _, and then inquire_ latexmath:[y_{\mathit{2a}}] _with_ `fmi3Get{VariableType}` _without setting_ latexmath:[u_{\mathit{1b}}] _beforehand._

_It is non-trivial to provide code for `fmi3Set{VariableType}`, `fmi3Get{VariableType}`, if the environment can call `fmi3Set{VariableType}` on the <<input,`inputs`>> in quite different orders._
_A simple remedy is to provide the dependency information, not according to the real functional dependency, but according to the sorted equations in the generated code._
_Example:_

_Assume an FMU is described by the following equations (`u1`, `u2` are <<input,`inputs`>>, `y1`, `y2` are <<output,`outputs`>>,`w1`, `w2` are internal variables):_

-----
w1 = w2 + u1
w2 = u2
y1 = w1
y2 = w2
-----

_Sorting of the equations might result in (this ordering is not unique):_

-----
w2 := u2
y2 := w2
w1 := w2 + u1
y1 := w1
-----

_With this ordering, the dependency should be defined as `y2 = f(u2), y1 = f(u1,u2)`._
_When `y2` is called first with `fmi3Get{VariableType}`, then only `u2` must be set first (since `y2 = f(u2)`), and the first two equations are evaluated._
_If later `y1` is inquired as well, then the first two equations are not evaluated again and only the last two equations are evaluated._
_On the other hand, if `y1` is inquired first, then `u1` and `u2` must be set first (since `y1 = f(u1,u2)`) and then all equations are computed._
_When `y2` is inquired afterwards, the cached value is returned._

_If sorting of the equations in this example would instead result in the following code:_

----
w2 := u2
w1 := w2 + u1
y1 := w1
y2 := w2
----

_then the dependency should be defined as `y2 = f(u1,u2)`, `y1 = f(u1,u2)`, because `u1` and `u2` must be first set, before `y2` can be inquired with `fmi3Get{VariableType}` when executing this code._

_Remark 2 - Mathematical Model of Discrete-Time FMUs:_

_There are many different ways discrete-time systems are described._
_For FMI, the following basic mathematical model for discrete-time systems is used (other description forms must be mapped, as sketched below):_

image::images/remark_2_source.png[width=70%]

_At an event instant, the discrete system is described by algebraic equations as function of the previous (internal) discrete-time states>>_ latexmath:[_{}^{\bullet}\mathbf{x}_{d}] _and the discrete-time <<input,`inputs`>>_ latexmath:[\mathbf{u}_{d}].
_If FMUs are connected in a loop, these algebraic equations are called iteratively, until the solution is found._
_If the current discrete-time states_ latexmath:[\mathbf{x}_{d}] _and the previous discrete-time states_ latexmath:[_{}^{\bullet}\mathbf{x}_{d}] _are not identical, the discrete-time states are updated, the integer part of the time is incremented and a new event iteration is performed._
_Other discrete-time models must be mapped to this description form._
_Examples:_

Synchronous systems::
_A synchronous system, such as Lucid Synchrone <<PZ06>> or Modelica 3.3 <<MLS12>>, is called periodically, and at every sample instant the discrete-time equations are evaluated exactly once._
_An FMU of this type should be implemented in FMI 3.0 with <<clock,`clocks`>>._

_However, just like in FMI 2.0, it could in principle also be implemented by activating the model equations only at the first event iteration and returning always `newDiscreteStatesNeeded == fmi3False` from <<fmi3NewDiscreteStates>>._
_Furthermore, the discrete-time states are not updated by <<fmi3NewDiscreteStates>>, but as first action before the discrete-time equations are evaluated, in order that_ latexmath:[^{\bullet}\mathbf{x}_d] _(= value at the previous Lucid Synchrone/Modelica 3.3 clock tick) and_ latexmath:[\mathbf{x}_d] _(value at the latest Lucid Synchrone/Modelica 3.3 clock tick) have reasonable values between Lucid Synchrone/Modelica 3.3 clock ticks._

State machines with one memory location for a state::
_In such a system there is only one memory location for a discrete-time state and not two, and therefore a discrete-time state is updated in the statement where it is assigned (and not in <<fmi3NewDiscreteStates>>)._
_As a result, <<fmi3NewDiscreteStates>> is basically just used to start a new (super-dense) time instant._
_This is unproblematic, as long as no algebraic loops occur._
_FMUs of this type can therefore not be used in real algebraic loops if the involved variables depend on a discrete-time state._
_This restriction is communicated to the environment of the FMU by the `ScalarVariable` definition of the corresponding <<input>> with flag <<canHandleMultipleSetPerTimeInstant>> `= false` (so an <<input>> with this flag is not allowed to be called in an algebraic loop)._

[[Remark3]]
_Remark 3 - Event Indicators / Frozen Relations:_

_In <<table-math-model-exchange>>, vector_ latexmath:[\mathbf{r}] _is used to collect all relations together that are utilized in the event indicators_ latexmath:[\mathbf{z}] _._
_In *Continuous-Time Mode* all these relations are "frozen" and do not change during the evaluations in the respective mode._
_This is indicated in <<table-math-model-exchange>> by computing_ latexmath:[\mathbf{r}] _when entering the *Continuous-Time Mode* and providing_ latexmath:[\mathbf{r}] _as (internal) input argument to the evaluation functions._
_Example:_

_An equation of the form_

----
y = if x1 > x2 or x1 < x3 then +1 else -1;
----

_can be implemented in the FMU as:_

----
z1 := x1 - x2;
z2 := x3 - x1;
if *Initialization Mode* or *Event Mode* then
  r1 := z1 > 0;
  r2 := z2 > 0;
end if;
y = if r1 or r2 then +1 else -1
----

_Therefore, the original if-clause is evaluated in this form only during *Initialization Mode* and *Event Mode*._
_In *Continuous-Time Mode* this equation is evaluated as:_

----
z1 = x1 - x2;
z2 = x3 - x1
y = if r1 or r2 then +1 else -1;
----

_and when entering *Continuous-Time Mode* r1 and r2 are computed as_

----
r1 = z1 > 0
r2 = z2 > 0
----

_When z1 changes from z1 > 0 to z1 <= 0 or vice versa, or z2 correspondingly, the integration is halted, and the environment must call <<fmi3EnterEventMode>>._

_An actual implementation will pack the code into a function with side effects, say Greater(...), resulting in:_

----
y = if Greater(x1-x2,...) or Greater(x3-x1,...) then +1 else -1;
----

_Furthermore, a hysteresis should be added for the event indicators.]_

An FMU is initialized in *Initialization Mode* with latexmath:[\mathbf{f}_{\mathit{init}}(\ldots)].

The input arguments to this function consist of the <<input>> variables (= variables with <<causality>> = <<input>>), of the <<independent>> variable (= variable with <<causality>> = <<independent>> _[typically: time]_), and of all variables that have a <<start>> value with <<initial>> = <<exact>> in order to compute the continuous-time <<state,`states`>> and the output variables at the initial time latexmath:[t_0].
In <<table-math-model-exchange>>, the variables with <<initial>> = <<exact>> are collected together in variable latexmath:[\mathbf{v}_{\mathit{initial=exact}}].

For example, initialization might be defined by providing initial <<start>> values for the <<state,`states`>>, latexmath:[\mathbf{x}_{\mathit{c0}}], or by stating that the state derivatives are zero (latexmath:[\dot{\mathbf{x}}_{c} = \mathbf{0}]).
Initialization is a difficult topic by itself, and it is required that an FMU solves a well-defined initialization problem inside the FMU in *Initialization Mode*. +
After calling <<fmi3ExitInitializationMode>>, the FMU is implicitly in *Event Mode*, and all discrete-time and continuous-time variables at the initial time instant latexmath:[(t_R, 0)] can be calculated.
If these variables are present in an algebraic loop, iteration can be used to compute them.
Once finalized, <<fmi3NewDiscreteStates>> must be called, and depending on the value of the return argument, the FMU either continues the event iteration at the initial time instant or switches to *Continuous-Time Mode*. +
After switching to *Continuous-Time Mode*, the integration is started.
Basically, during *Continuous-Time Mode*, the <<derivative,`derivatives`>> of the continuous <<state,`states`>> are computed.
If FMUs and/or submodels are connected together, then the <<input,`inputs`>> of these models are the <<output,`outputs`>> of other models, and therefore, the corresponding FMU outputs must be computed.
Whenever result values shall be stored, usually at output points defined before the start of the simulation, the `fmi3Get{VariableType}` function with respect to the desired variables must be called. +
Continuous integration is stopped at an event instant.
An event instant is determined by a <<time event,`time`>>, <<state event,`state`>> or <<step event>>, or by an external event triggered by the environment.

In order to determine a <<state event>>, the event indicators *z* have to be inquired at every completed integrator step.
Once the event indicators signal a change of their domain, an iteration over time is performed between the previous and the actual completed integrator step, in order to determine the time instant of the domain change up to a certain precision. +
After an event is triggered, the FMU needs to be switched to *Event Mode*.
In this mode, systems of equations over connected FMUs might be solved (similarly as in *Continuous-Time Mode*).
Once convergence is reached, <<fmi3NewDiscreteStates>> must be called to increment super-dense time (and conceptually update the discrete-time states defined internally in the FMU by latexmath:[^{\bullet}\mathbf{x}_d := \mathbf{x}_d]).
Depending on the discrete-time model, a new event iteration might be needed.

_[For example, an FMU implements a state machine that forces an internal state transitions to occur, when new <<input>> values are available.]_

The function calls in <<table-math-model-exchange>> describe precisely which input arguments are needed to compute the desired output argument(s).
There is no 1:1 mapping of these mathematical functions to C functions.
Instead, all input arguments are set with `fmi3Set{VariableType}` C function calls, and then the result argument(s) can be determined with the C functions defined in the right column of <<table-math-model-exchange>>.
This technique is discussed in detail in <<providing-independent-variables-and-re-initialization>>.
_[In short: For efficiency reasons, all equations from <<table-math-model-exchange>> will usually be available in one (internal) C function._
_With the C functions described in the next sections, input arguments are copied into the internal model data structure only when their value has changed in the environment._
_With the C functions in the right column of <<table-math-model-exchange>>, the internal function is called in such a way that only the minimum needed equations are evaluated._
_Hereby, variable values calculated from previous calls can be reused._
_This technique is called "caching" and can significantly enhance the simulation efficiency of real-world models.]_
