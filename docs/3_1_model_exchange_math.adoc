=== Concepts [[math-model-exchange]]

==== Providing Independent Variables and Re-initialization of Caching [[providing-independent-variables-and-re-initialization]]

Depending on the situation, different variables need to be computed.
In order to be efficient, it is important that the interface requires only the computation of variables that are needed in the present context.
For example, during the iteration of an integrator step, only the state derivatives need to be computed, provided the <<output>> of a model is not connected.
It might be that at the same time instant other variables are needed.
For example, if an integrator step is completed, the event indicator functions need to be computed as well.
If the state derivatives have already been computed at the present time instant, then it is important for efficiency that they are not newly computed in the call to compute the event indicator functions.
This means, the state derivatives shall be reused from the previous call.
This feature is called "caching of variables" in the sequel. +
Caching requires that the model evaluation can detect when the input arguments, like time or states, have changed.
This is achieved by setting them explicitly with a function call, since every such function call signals precisely a change of the corresponding variables.
For this reason, this section contains functions to set the input arguments of the equation evaluation functions.
This is unproblematic for time and states, but is more involved for <<parameter,`parameters`>> and <<input,`inputs`>>, since the latter may have different data types.


[source, C]
----
fmi3Status fmi3Set{VariableType}(..);
----

Set new values for <<parameter,`parameters`>>, <<start>> values and <<input,`inputs`>> and re-initialize caching of variables that depend on these variables.
The details of these functions are defined in <<get-and-set-variable-values>>.

_[The functions above have the slight drawback that values must always be copied._
_For example, a call to_ <<fmi3SetContinuousStates>> _will provide the actual states in a vector, and this function has to copy the values in to the internal model data structure so that subsequent evaluation calls can utilize these values._
_If this turns out to be an efficiency issue, a future release of FMI might provide additional functions to provide the address of a memory area where the variable values are present.]_

==== Model Evaluations, Dependencies, and Call Sequence

// TODO: Move this section to General Mechanisms and generalize for both ME and CS

When connecting FMUs, loop structures can occur that lead to particular difficulties because linear or non-linear algebraic systems of equations in floating point variables but also in Boolean or Integer variables might be present.
In order to solve such systems of equations over FMUs efficiently, the dependency information is needed stating, for example, which <<output,`outputs`>> depend directly on <<input,`inputs`>>.
This data is optionally provided in the XML file under element `<ModelStructure>`.
If this data is not provided, the worst case must be assumed, that is, all <<output>> variables depend algebraically on all <<input>> variables.

_[Example: In <<figure-connected-fmus>> two different types of connected FMUs are shown (the "dotted lines" characterize the dependency information):_

.Calling sequences for FMUs that are connected in a loop.
[#figure-connected-fmus]
image::images/ArtificialAlgebraicLoops.svg[width=80%, align="center"]

_In the left diagram, FMU1 and FMU2 are connected in such a way that by an appropriate sequence of `fmi3Set{VariableType}` and `fmi3Get{VariableType}` calls, the FMU variables can be computed with the following call sequence:_

[source, C]
----
fmi3Instance FMI1, FMI2;
fmi3ValueReference vr_FMU1_u, vr_FMU1_y, vr_FMU2_u1, vr_FMU2_u2, vr_FMU2_y1, vr_FMU2_y2;
fmi3Float64 s=0.1, FMU2_y1, FMU1_y, FMU2_y2;

...

fmi3SetFloat64(FMU2, &vr_FMU2_u1, 1, &s,        1);
fmi3GetFloat64(FMU2, &vr_FMU2_y1, 1, &FMU2_y1,  1);
fmi3SetFloat64(FMU1, &vr_FMU1_u,  1, &FMU2_y1,  1);
fmi3GetFloat64(FMU1, &vr_FMU1_y,  1, &FMU1_y,   1);
fmi3SetFloat64(FMU2, &vr_FMU2_u2, 1, &FMU1_y,   1);
fmi3GetFloat64(FMU2, &vr_FMU2_y1, 1, &FMU2_y2,  1);
...
----


_In the right diagram, FMU3 and FMU4 are connected in such a way that a real algebraic loop is present._
_This loop might be solved iteratively with a Newton method._
_In every iteration the iteration variable latexmath:[u_4] is provided by the solver, and via the shown sequence of `fmi3Set{VariableType}` and `fmi3Get{VariableType}` calls, the residual is computed and is provided back to the solver._
_Based on the residual a new value of latexmath:[u_4] is provided._
_The iteration is terminated when the residual is close to zero._

[source, C]
----
fmi3Instance FMI1, FMI2;
fmi3ValueReference vr_FMU3_u, vr_FMU3_y, vr_FMU4_u, vr_FMU4_y;
fmi3Float64 s, FMU3_y, FMU4_y, residual;
bool converged;

// Newton iteration
while (!converged)
{
  // input s[0] calculated by the solver
  ...
  fmi3SetFloat64(FMU2, &vr_FMU4_u, 1, &s,   1);
  fmi3GetFloat64(FMU2, &vr_FMU4_y, 1, &FMU4_y,  1);
  fmi3SetFloat64(FMU1, &vr_FMU3_u, 1, &FMU4_y,  1);
  fmi3GetFloat64(FMU1, &vr_FMU3_y, 1, &FMU3_y,  1);
  residual=s-FMU3_y; // provided to the solver
}

----

_These types of artificial or real algebraic loops can occur in all the different modes, such as *Initialization Mode*, *Event Mode*, and *Continuous-Time Mode*._
_Since different variables are computed in every mode and the causality of variable computation can be different in *Initialization Mode* as with respect to the other two modes, it might be necessary to solve different kinds of loops in the different modes.]_

_[Remark 1 - Calling Sequences:_

_In <<table-math-model-exchange>>, for notational convenience in every mode one function call is defined to compute all output arguments from all inputs arguments._
_In reality, every scalar output argument can be computed by one `fmi3Get{VariableType}` function call._
_Additionally, the output argument need not be a function of all input arguments, but of only a subset from it, as defined in the XML file under `<ModelStructure>`._
_This is essential when FMUs are connected in a loop, as shown in <<figure-connected-fmus>>._
_For example, since_ latexmath:[y_{\mathit{2a}}] _depends only on_ latexmath:[u_{\mathit{1a}}] _, but not on_ latexmath:[u_{\mathit{1b}}]_, it is possible to call_ `fmi3Set{VariableType}` _to set_ latexmath:[u_{\mathit{1a}}] _, and then inquire_ latexmath:[y_{\mathit{2a}}] _with_ `fmi3Get{VariableType}` _without setting_ latexmath:[u_{\mathit{1b}}] _beforehand._

_It is non-trivial to provide code for `fmi3Set{VariableType}`, `fmi3Get{VariableType}`, if the environment can call `fmi3Set{VariableType}` on the <<input,`inputs`>> in quite different orders._
_A simple remedy is to provide the dependency information, not according to the real functional dependency, but according to the sorted equations in the generated code._
_Example:_

_Assume an FMU is described by the following equations (`u1`, `u2` are <<input,`inputs`>>, `y1`, `y2` are <<output,`outputs`>>,`w1`, `w2` are internal variables):_

-----
w1 = w2 + u1
w2 = u2
y1 = w1
y2 = w2
-----

_Sorting of the equations might result in (this ordering is not unique):_

-----
w2 := u2
y2 := w2
w1 := w2 + u1
y1 := w1
-----

_With this ordering, the dependency should be defined as `y2 = f(u2), y1 = f(u1,u2)`._
_When `y2` is called first with `fmi3Get{VariableType}`, then only `u2` must be set first (since `y2 = f(u2)`), and the first two equations are evaluated._
_If later `y1` is inquired as well, then the first two equations are not evaluated again and only the last two equations are evaluated._
_On the other hand, if `y1` is inquired first, then `u1` and `u2` must be set first (since `y1 = f(u1,u2)`) and then all equations are computed._
_When `y2` is inquired afterwards, the cached value is returned._

_If sorting of the equations in this example would instead result in the following code:_

----
w2 := u2
w1 := w2 + u1
y1 := w1
y2 := w2
----

_then the dependency should be defined as `y2 = f(u1,u2)`, `y1 = f(u1,u2)`, because `u1` and `u2` must be first set, before `y2` can be inquired with `fmi3Get{VariableType}` when executing this code._

_Remark 2 - Mathematical Model of Discrete-Time FMUs:_

_There are many different ways discrete-time systems are described._
_For FMI, the following basic mathematical model for discrete-time systems is used (other description forms must be mapped, as sketched below):_

image::images/remark_2_source.png[width=70%]

_At an event instant, the discrete system is described by algebraic equations as function of the previous (internal) discrete-time states>>_ latexmath:[_{}^{\bullet}\mathbf{x}_{d}] _and the discrete-time <<input,`inputs`>>_ latexmath:[\mathbf{u}_{d}].
_If FMUs are connected in a loop, these algebraic equations are called iteratively, until the solution is found._
_If the current discrete-time states_ latexmath:[\mathbf{x}_{d}] _and the previous discrete-time states_ latexmath:[_{}^{\bullet}\mathbf{x}_{d}] _are not identical, the discrete-time states are updated, the integer part of the time is incremented and a new event iteration is performed._
_Other discrete-time models must be mapped to this description form._
_Examples:_

Synchronous systems::
_A synchronous system, such as Lucid Synchrone <<PZ06>> or Modelica 3.3 <<MLS12>>, is called periodically, and at every sample instant the discrete-time equations are evaluated exactly once._
_An FMU of this type should be implemented in FMI 3.0 with <<clock,`clocks`>>._

_However, just like in FMI 2.0, it could in principle also be implemented by activating the model equations only at the first event iteration and returning always `discreteStatesNeedUpdate == fmi3False` from <<fmi3UpdateDiscreteStates>>._
_Furthermore, the discrete-time states are not updated by <<fmi3UpdateDiscreteStates>>, but as first action before the discrete-time equations are evaluated, in order that_ latexmath:[^{\bullet}\mathbf{x}_d] _(= value at the previous Lucid Synchrone/Modelica 3.3 clock tick) and_ latexmath:[\mathbf{x}_d] _(value at the latest Lucid Synchrone/Modelica 3.3 clock tick) have reasonable values between Lucid Synchrone/Modelica 3.3 clock ticks._

State machines with one memory location for a state::
_In such a system there is only one memory location for a discrete-time state and not two, and therefore a discrete-time state is updated in the statement where it is assigned (and not in <<fmi3UpdateDiscreteStates>>)._
_As a result, <<fmi3UpdateDiscreteStates>> is basically just used to start a new (super-dense) time instant._
_This is unproblematic, as long as no algebraic loops occur._
_FMUs of this type can therefore not be used in real algebraic loops if the involved variables depend on a discrete-time state._
_This restriction is communicated to the environment of the FMU by the `ScalarVariable` definition of the corresponding <<input>> with flag <<canHandleMultipleSetPerTimeInstant>> `= false` (so an <<input>> with this flag is not allowed to be called in an algebraic loop)._

[[Remark3]]
_Remark 3 - Event Indicators / Frozen Relations:_

_In <<table-variable-types>>, vector_ latexmath:[\mathbf{r}] _is used to label all relations in_ latexmath:[{\mathbf{f}_{\mathit{cont}}}] _and_ latexmath:[{\mathbf{f}_{\mathit{comp}}}] _._
_In *Continuous-Time Mode* all these relations are "frozen"._
_This is indicated in <<updateRelations, the mathematical description>> of *Event Mode* by computing_ latexmath:[{}^\bullet\mathbf{r}] _when entering the *Continuous-Time Mode* and providing_ latexmath:[{}^\bullet\mathbf{r}] _as part of the right-hand side of_ latexmath:[{\mathbf{f}_{\mathit{cont}}}] _and_ latexmath:[{\mathbf{f}_{\mathit{comp}}}] _in <<table-math-model-exchange,mathematical description>> of *Continuous-Time Mode*._

_Example:_

_An equation of the form_

----
y = if x1 > x2 or x1 < x3 then +1 else -1;
----

_can be implemented in the FMU as:_

----
z1 := x1 - x2;
z2 := x3 - x1;
if *Initialization Mode* or *Event Mode* then
  r1 := z1 > 0;
  r2 := z2 > 0;
end if;
y = if r1 or r2 then +1 else -1
----

_Therefore, the original if-clause is evaluated in this form only during *Initialization Mode* and *Event Mode*._
_In *Continuous-Time Mode* this equation is evaluated as:_

----
z1 = x1 - x2;
z2 = x3 - x1
y = if r1 or r2 then +1 else -1;
----

_and when entering *Continuous-Time Mode* r1 and r2 are computed as_

----
r1 = z1 > 0
r2 = z2 > 0
----

_When z1 changes from z1 > 0 to z1 <= 0 or vice versa, or z2 correspondingly, the integration is halted, and the environment must call <<fmi3EnterEventMode>>._

_An actual implementation will pack the code into a function with side effects, say Greater(...), resulting in:_

----
y = if Greater(x1-x2,...) or Greater(x3-x1,...) then +1 else -1;
----

_Furthermore, a hysteresis should be added for the event indicators.]_
