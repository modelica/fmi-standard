=== Concepts [[concepts-model-exchange]]

==== Selective Computation of FMU Variables [[providing-independent-variables-and-re-initialization]]

Depending on the phase of the solver algorithm, different FMU variables need to be computed.
FMI allows selective retrieval of FMU variables with specific get functions (e.g. `fmi3Get{VariableType}`, <<fmi3GetEventIndicators>>, <<fmi3GetDerivatives>>).
This enables computation on demand.

For example, during the iteration of an integrator step, only the state derivatives need to be computed, provided the <<output>> of a model is not connected.
When localizing of <<state-event,state events>>, only the computation of event indicators might be required.

Because specific set functions exist (`fmi3Set{VariableType}`, <<fmi3SetTime>>, <<fmi3SetContinuousStates>>), caching algorithms can be applied to reuse already computed values.

In all tables describing the mathematical model of a state (e.g. <<table-math-model-exchange,*Continuous-Time Mode*>>), for notational convenience one function (e.g. latexmath:[\mathbf{f}_\mathit{cont}]) is defined to compute all output arguments from all inputs arguments.
In an FMU, every output argument can be computed by its specific get function.
Additionally, the output argument need not be a function of all input arguments, but of only a subset from it, as defined in the <<modelDescription.xml>> under `<ModelStructure>`.

_[The functions above have the slight drawback that values must always be copied._
_For example, a call to_ <<fmi3SetContinuousStates>> _will provide the actual states in a vector, and this function has to copy the values in to the internal model data structure so that subsequent evaluation calls can utilize these values._
_If this turns out to be an efficiency issue, a future release of FMI might provide additional functions to provide the address of a memory area where the variable values are present.]_

==== Algebraic Loops [[algebraic-loops]]

When connecting FMUs, loop structures can occur that might lead to linear or non-linear algebraic systems of equations, involving continuous and discrete-time variables.
In order to detect and solve such systems of equations efficiently, information which <<output,`output`>> depends directly on which <<input,`inputs`>> is needed.
This data is optionally provided in the <<modelDescription.xml>> under element `<ModelStructure>`.
If this data is not provided, the worst case must be assumed: all <<output>> variables depend algebraically on all <<input>> variables.

_[Example: In <<figure-connected-fmus>> two different types of connected FMUs are shown (the "dotted lines" characterize the dependency information):_

.Calling sequences for FMUs that are connected in a loop.
[#figure-connected-fmus]
image::images/ArtificialAlgebraicLoops.svg[width=80%, align="center"]

_In the left diagram, FMU1 and FMU2 are connected in such a way that by an appropriate sequence of `fmi3Set{VariableType}` and `fmi3Get{VariableType}` calls, the FMU variables can be computed with the following call sequence:_

[source, C]
----
fmi3Instance FMI1, FMI2;
fmi3ValueReference vr_FMU1_u, vr_FMU1_y, vr_FMU2_u1, vr_FMU2_u2, vr_FMU2_y1, vr_FMU2_y2;
fmi3Float64 s=0.1, FMU2_y1, FMU1_y, FMU2_y2;

...

fmi3SetFloat64(FMU2, &vr_FMU2_u1, 1, &s,        1);
fmi3GetFloat64(FMU2, &vr_FMU2_y1, 1, &FMU2_y1,  1);
fmi3SetFloat64(FMU1, &vr_FMU1_u,  1, &FMU2_y1,  1);
fmi3GetFloat64(FMU1, &vr_FMU1_y,  1, &FMU1_y,   1);
fmi3SetFloat64(FMU2, &vr_FMU2_u2, 1, &FMU1_y,   1);
fmi3GetFloat64(FMU2, &vr_FMU2_y1, 1, &FMU2_y2,  1);
...
----


_In the right diagram, FMU3 and FMU4 are connected in such a way that a real algebraic loop is present._
_This loop might be solved iteratively with a Newton method._
_In every iteration the iteration variable FMU4_u is provided by the solver, and via the shown sequence of `fmi3Set{VariableType}` and `fmi3Get{VariableType}` calls, the residual is computed and is provided back to the solver._
_Based on the residual a new value of FMU4_u is provided._
_The iteration is terminated when the residual is close to zero._

[source, C]
----
fmi3Instance FMI1, FMI2;
fmi3ValueReference vr_FMU3_u, vr_FMU3_y, vr_FMU4_u, vr_FMU4_y;
fmi3Float64 s, FMU3_y, FMU4_y, residual;
bool converged = false;

// Newton iteration
while (!converged)
{
  // input s[0] calculated by the solver
  ...
  fmi3SetFloat64(FMU2, &vr_FMU4_u, 1, &s,   1);
  fmi3GetFloat64(FMU2, &vr_FMU4_y, 1, &FMU4_y,  1);
  fmi3SetFloat64(FMU1, &vr_FMU3_u, 1, &FMU4_y,  1);
  fmi3GetFloat64(FMU1, &vr_FMU3_y, 1, &FMU3_y,  1);
  residual=s-FMU3_y; // provided to the solver
  converged=residual<tolerance;
}

----

_These types of artificial or real algebraic loops can occur in all the different modes, such as *Initialization Mode*, *Event Mode*, and *Continuous-Time Mode*._
_Since different variables are computed in every mode and the causality of variable computation can be different in *Initialization Mode* as with respect to the other two modes, it might be necessary to solve different kinds of loops in the different modes.]_

// XXX

_Remark 2 - Mathematical Model of Discrete-Time FMUs:_

_There are many different ways discrete-time systems are described._
_For FMI, the following basic mathematical model for discrete-time systems is used (other description forms must be mapped, as sketched below):_

image::images/remark_2_source.png[width=70%]

_At an event instant, the discrete system is described by algebraic equations as function of the previous (internal) discrete-time states>>_ latexmath:[_{}^{\bullet}\mathbf{x}_{d}] _and the discrete-time <<input,`inputs`>>_ latexmath:[\mathbf{u}_{d}].
_If FMUs are connected in a loop, these algebraic equations are called iteratively, until the solution is found._
_If the current discrete-time states_ latexmath:[\mathbf{x}_{d}] _and the previous discrete-time states_ latexmath:[_{}^{\bullet}\mathbf{x}_{d}] _are not identical, the discrete-time states are updated, the integer part of the time is incremented and a new event iteration is performed._
_Other discrete-time models must be mapped to this description form._
_Examples:_

Synchronous systems::
_A synchronous system, such as Lucid Synchrone <<PZ06>> or Modelica 3.3 <<MLS12>>, is called periodically, and at every sample instant the discrete-time equations are evaluated exactly once._
_An FMU of this type should be implemented in FMI 3.0 with <<clock,`clocks`>>._

_However, just like in FMI 2.0, it could in principle also be implemented by activating the model equations only at the first event iteration and returning always `discreteStatesNeedUpdate == fmi3False` from <<fmi3UpdateDiscreteStates>>._
_Furthermore, the discrete-time states are not updated by <<fmi3UpdateDiscreteStates>>, but as first action before the discrete-time equations are evaluated, in order that_ latexmath:[^{\bullet}\mathbf{x}_d] _(= value at the previous Lucid Synchrone/Modelica 3.3 clock tick) and_ latexmath:[\mathbf{x}_d] _(value at the latest Lucid Synchrone/Modelica 3.3 clock tick) have reasonable values between Lucid Synchrone/Modelica 3.3 clock ticks._

// TODO: link to <<canHandleMultipleSetPerTimeInstant>> where appropriate

[[Remark3]]
_Remark 3 - Event Indicators / Frozen Relations:_

_In <<table-variable-types>>, vector_ latexmath:[\mathbf{r}] _is used to label all relations in_ latexmath:[{\mathbf{f}_{\mathit{cont}}}] _and_ latexmath:[{\mathbf{f}_{\mathit{comp}}}] _._
_In *Continuous-Time Mode* all these relations are "frozen"._
_This is indicated in <<updateRelations, the mathematical description>> of *Event Mode* by computing_ latexmath:[{}^\bullet\mathbf{r}] _when entering the *Continuous-Time Mode* and providing_ latexmath:[{}^\bullet\mathbf{r}] _as part of the right-hand side of_ latexmath:[{\mathbf{f}_{\mathit{cont}}}] _and_ latexmath:[{\mathbf{f}_{\mathit{comp}}}] _in <<table-math-model-exchange,mathematical description>> of *Continuous-Time Mode*._

_Example:_

_An equation of the form_

----
y = if x1 > x2 or x1 < x3 then +1 else -1;
----

_can be implemented in the FMU as:_

----
z1 := x1 - x2;
z2 := x3 - x1;
if *Initialization Mode* or *Event Mode* then
  r1 := z1 > 0;
  r2 := z2 > 0;
end if;
y = if r1 or r2 then +1 else -1
----

_Therefore, the original if-clause is evaluated in this form only during *Initialization Mode* and *Event Mode*._
_In *Continuous-Time Mode* this equation is evaluated as:_

----
z1 = x1 - x2;
z2 = x3 - x1
y = if r1 or r2 then +1 else -1;
----

_and when entering *Continuous-Time Mode* r1 and r2 are computed as_

----
r1 = z1 > 0
r2 = z2 > 0
----

_When z1 changes from z1 > 0 to z1 <= 0 or vice versa, or z2 correspondingly, the integration is halted, and the environment must call <<fmi3EnterEventMode>>._

_An actual implementation will pack the code into a function with side effects, say Greater(...), resulting in:_

----
y = if Greater(x1-x2,...) or Greater(x3-x1,...) then +1 else -1;
----

_Furthermore, a hysteresis should be added for the event indicators.]_
