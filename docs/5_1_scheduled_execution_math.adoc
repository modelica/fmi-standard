=== Concepts [[concepts-scheduled-execution]]

==== Preemption Support [[preemption-support]]

For real-time applications the simulation time equals the real wall clock time, thus each <<fmi3ActivateModelPartition>> computation step has to be finished in real-time within its current period time length (computation time is not only defined by the runtime of <<fmi3ActivateModelPartition>> but also by the time for setting and getting variables and related operations).
Usually a preemptive scheduling of the <<fmi3ActivateModelPartition>>, <<get-and-set-variable-values,`fmi3Get{VariableType}`>>, <<get-and-set-variable-values,`fmi3Set{VariableType}`>> calls is required to respect this constraint.

The FMU's code has to be prepared for being able to correctly handle preemptive calls of <<fmi3ActivateModelPartition>>, <<get-and-set-variable-values,`fmi3Get{VariableType}`>>, <<get-and-set-variable-values,`fmi3Set{VariableType}`>>, <<fmi3GetClock>> and <<fmi3GetIntervalDecimal>>.
In general for Scheduled Execution this requires a secured internal and external access to global states and variable values to ensure the correct handling of the preemption of model partition computations.
_[For <<get-and-set-variable-values,`fmi3Get{VariableType}`>>, <<get-and-set-variable-values,`fmi3Set{VariableType}`>> in particular a unique assignment of the respective variables to model partitions via its associated <<Clock>> is strongly recommended.]_
It is also required that the FMU reports the active state of an <<outputClock>> only with the first call of <<fmi3GetClock>> for a specific activation of this <<Clock>> and sets the reported activation state immediately back to `false` for the following <<fmi3GetClock>> calls for that <<Clock>> until this <<outputClock>> is internally activated again.
Similarly for <<countdown, `countdown Clocks`>> a call to <<fmi3GetIntervalDecimal>> has to ensure that the Clock's interval qualifier is reset to <<fmi3IntervalUnchanged>>.

If a preemptive multitasking regime is intended, an individual task (or thread -- task and thread are used synonymously here) for each model partition (associated to an <<inputClock>>) has to be created.
The task for computing each <<fmi3ActivateModelPartition>> is created and controlled by the simulation algorithm, not by the FMU.
So the FMU exporting tool does not need to take care for that (except for preparing its code to support preemption).

_[If only one single model partition is available via the interface of an FMU, preemptive calls of the related <<fmi3ActivateModelPartition>> function are possible by default since there are no external cross dependencies within one model partition between communication points.]_

Preemption support means that the scheduler can immediately interrupt the current execution of a model partition in order to execute a model partition of higher priority.
The computation of the interrupted model partition is proceeded afterwards.
So by regarding priorities and supporting preemption the scheduler can ensure that most critical model partitions are never delayed by less important model parts.
_[This is particularly important for real-time simulators as the wall clock time is dictating the time for the next execution.]_

* Same <<priority>>: The scheduler does not preempt the execution of a model partition in favor of a model partition of the same priority.
For model partitions with the same priority, it decides on the execution order based on (customer) configurations in the importer.
* Different priorities: The scheduler preempts the execution of a model partition of a lower priority as soon as a model partition of higher priority partition needs to be computed.
_[Simply stated: The model partition of higher priority preempts the model partition of lower priority.]_

_[An example for scheduling based on priorities and preempting model partitions is given in section <<example-scheduled-execution>>.]_

It may be important for the FMU to secure particular sections of its code against being preempted.
Callback functions <<preemption-support,`fmi3CallbackLockPreemption`>> and <<preemption-support,`fmi3CallbackUnlockPreemption`>> are provided by the simulation algorithm when instantiating the FMU via <<fmi3InstantiateScheduledExecution>> to allow the FMU to signal entering and exiting such code sections.

[source, C]
----
include::../headers/fmi3FunctionTypes.h[tag=CallbackPreemptionLock]
----

The FMU's code has to be prepared to correctly handle preemption of

* <<fmi3ActivateModelPartition>>,
* <<get-and-set-variable-values,`fmi3Get{VariableType}`>>,
* <<get-and-set-variable-values,`fmi3Set{VariableType}`>>,
* <<fmi3GetClock>>
* and <<fmi3GetIntervalDecimal>>.

In general this means that the FMU's code has to secure access to its global states and variables wherever data inconsistencies due to potential preemptions are anticipated.

_[Note that_

* _in order to avoid data inconsistencies and safeguard predictable behavior with <<get-and-set-variable-values,`fmi3Get{VariableType}`>>, <<get-and-set-variable-values,`fmi3Set{VariableType}`>> a unique assignment of the respective variables to model partitions via its associated <<Clock>> is strongly recommended._
_Observe the example below:_
_If every variable is assigned uniquely to a model partition it is not necessary to use <<preemption-support, `preemption locks`>> in the context of <<get-and-set-variable-values,`fmi3Get{VariableType}`>> and <<get-and-set-variable-values,`fmi3Set{VariableType}`>>._
* _for <<fmi3GetClock>> the FMU has to ensure that the active state of an <<outputClock,output Clock>> is securely reset and cannot be observed twice for the same Clock tick in case this call is preempted._
_An example is given in <<example-scheduled-execution>>._
* _for <<fmi3GetIntervalDecimal>> the FMU has to ensure that the <<countdown, countdown Clock's>> interval qualifier is reset to <<fmi3GetIntervalDecimal, `fmi3IntervalUnchanged`>> and cannot be observed twice for the same Clock tick in case this call is preempted._
_An example is given in <<example-scheduled-execution>>._
* _depending on their implementation <<preemption-support,`fmi3CallbackLockPreemption`>> and <<preemption-support,`fmi3CallbackUnlockPreemption`>> have a strong impact on the simulator's OS so their use should be as rare and short as possible._
_So in general it is recommended to reduce dependencies between different model partitions of one FMU by design._
_One may also consider if the code can be preempted by other parts of the same FMU: E.g. a model partition cannot be interrupted if it is the only model partition of the FMU or if it holds the highest priority._
_I such cases no locks are necessary.]_

_[Example to observe why every variable should be assigned uniquely to a model partition via its associated <<Clock>>:_

* _An output variable is changed by two different model partitions._
_The values returned by <<get-and-set-variable-values,`fmi3Get{VariableType}`>> that is placed after <<fmi3ActivateModelPartition>> may return the values computed by the other model partition if that model partition has higher priority and preempted the execution meanwhile._
* _An input variable is used by two different model partitions._
_The variable values of a model partitions of lower priority may have been overwritten by a call to <<get-and-set-variable-values,`fmi3Set{VariableType}`>> for a model partition of higher priority.]_
