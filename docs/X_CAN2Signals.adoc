= CAN2Signals: CAN Communication and FMI 3.0
:sectnums:
:sectnumlevels: 5
:toc: left
:toc-title: Contents
:toclevels: 5
:xrefstyle: short
:docinfo: shared
:docinfodir: docs
:stylesheet: docs/fmi-spec.css
:stem: latexmath
:source-highlighter: highlightjs
:nofooter:
:favicon: images/favicon.ico
:revdate: unreleased
:revnumber: 3.0
:icons: font

This layered standard defines on top of FMI 3.0, how to describe and simulate CAN signals as input and output variables of an FMU.

{empty} +
{empty}

Copyright (C) 2008-2011 MODELISAR Consortium and 2012-2020 The Modelica Association Project FMI.

This document is licensed under the Attribution-ShareAlike 4.0 International license.
The code is released under the 2-Clause BSD License.
The licenses text can be found in the https://raw.githubusercontent.com/modelica/fmi-standard/master/LICENSE.txt[LICENSE.txt] file that accompanies this distribution.

{empty}

== Introduction

=== Intend of this Document

Automotive CAN is a bus technology that has been applied successfully over many years by all automotive OEMs world wide.
Virtualizing electronic control units (ECUs) and then simulating multiple such vECUs requires connecting them using a virtual version of the bus technology.
Reusing standard bus topology description formats, such as DBC and ARXML, is required for efficiency and testing reasons alike.
Files in these formats exist in validated form as part of the engineering process, tooling exists and these standards evolve to support new use cases.

This document describes how to use standard description formats for CAN bus topologies on top of the FMI 3.0 standard.
vECUs following this standard can then easily be connected in importing tools because the bus description files declare which signals have what properties and belong to what messages in which of the potentially multiple buses connected to each vECUs.
The importer does not need to know about the special CAN semantics of certain signals of an FMU; it simply forwards signal values according to the FMI standard.

This document only deals with classic CAN, not CAN-FD.
Signal and message properties will be extracted from the bus description files and it allows all exporters to have the same understanding and interpretation of the FMU signals.
Such signal properties are, for example: signal scaling, message timing and trigger conditions, packaging of signals in messages, unit definitions.
This document does not address potential open points of these description formats, it is assumed that such ambiguities will be handled elsewhere (e.g. message timing in the DBC format).
This document does not address IP protection or copyright issues.
These are technical and legal issues that need attention from standardization bodies of the referenced description formats, tool vendors and end users.

=== Rough Outline of the Approach

The bus description files will be placed into the `/extra/org.modelica.fmi.layered_CAN` folder.

CAN signals will be input or output variables with physical interpretation (units and numeric values) if possible, or binary types, if no numeric interpretation is possible.
There will be one terminal type for each CAN message with the name `BusName::MessageName` and it will group input or output variables with their corresponding signal names `BusName::MessageName::SignalName`.
All variables of one terminal must be either input or output depending on the message being received or sent.
This naming schema will create unique variable names as required by the FMI standard.
Each CAN message `BusName::MessageName` has its own dedicated clock, the name is `BusName::MessageName_CLOCK` and it will be part of the terminal of the CAN message it belongs to.
Optionally, it is allowed to also send the message data as `fmi3Binary` variable `BusName::MessageName_DATA`.
All variables belonging to a CAN message are clocked variables _[The output/input clock is active when a message is sent/received.]_.
Signal variables are generally of type `fmiFloat64`, except if conversion to physical requires other data types, e.g. `fmi3Int64`, or escapes numeric interpretation and is given the `fmi3Binary` type.

_[For example, XCP over CAN or UDS over CAN will use all 64 bits in the CAN message payload, often defining a single "signal"._
_While one could call this an `fmi3UInt64`, a numeric interpretation is clearly not intended and should use `fmi3Binary` instead.]_

All CAN message terminals will be wrapped into the CAN bus terminal they belong to.
The CAN bus terminal will also specify which node(s) are wrapped inside this FMU.
If an FMU specifies nodes that are both senders and receivers of a message, the receiver role will be removed from the FMU interface to allow the CAN signals to have a unique role as output.
_[The FMI standard requires a variable to be either input or output.]_

=== Comments about this Approach

_[Splitting messages into signals to be transported as FMI variables cuts the communication stack at the top level (AUTOSAR: Virtual Function Bus)._
_This is largely functionally equivalent to cutting below the communication stack where 64-bit messages are sent._
_Given the presence of the ARXML or DBC description formats, one can translate one cut layer into the other._
_Primarily exchanging signals as chosen here simplifies interaction with plant models and is intentionally kept simple._
_Optionally, the message data can be transported as well for each CAN message to eliminate the need for reconstruction of the message data from the signal values allowing for use cases that focus on the Basic Software._
_Forcing the variables into a naming schema will allow simpler connection of FMUs with other simulation artifacts not aware of this layered standard._
_The naming schema proposed here is already in use with MCD tools when measuring CAN and other bus types.]_

== Details

=== Bus Description Files

FMI 3.0 introduces an `/extra` folder in its `zip` structure.
The CAN description files will be placed under the reverse domain name controlled by the MAP FMI: `/extra/org.modelica.fmi.layered_CAN`.
Both DBC and ARXML files are allowed.
The root name of the description files shall be used as bus identifier in the CAN bus terminal type and are case sensitive.

Multiple files can be specified, each one defining one bus architecture used by the FMU.
This standard does not support composing one CAN bus architecture from multiple description files.

It is recommended to use ARXML files if possible, because the DBC standard lacks some key properties that have later been added using non-standard extensions with many dialects in use.

=== Terminal Definitions

==== CAN Bus Terminal

Each bus connected to the FMU must be described by a CAN bus terminal named `CAN::BusName` in `icons/terminalsAndIcons.xml` as a `<Terminal>` element of `<fmiTerminalsAndIcons><Terminals>` that wraps all message terminals.
The CAN bus name must match the root name of the CAN description file, e.g. `Powertrain`, if the file is `/extra/org.modelica.fmi.layered_CAN/Powertrain.dbc`.

// TODO: EXAMPLE here

Attribute definitions::
 * `terminalKind` must be set to `CAN_bus`.
 * `matchingRule` must be set to `bus`.
 * `name` is the CAN bus name, e.g. `Powertrain`, see example and constraints above.

Element definitions::
 * There must be no `<TerminalMemberVariable>` element.
 * There must be no `<TerminalStreamMemberVariable>` element.
 * There must be one `<Terminal>` element per CAN bus message described in the description file.

Annotation element::
 * In the annotation elements, there will be an `<Annotation>` element defining which node or nodes of the CAN bus description file are wrapped inside the FMU.
If the combination of nodes specified for this FMU turns a message and its signals into both input and output because sending and receiving nodes are specified, only the sending (output) role will be defined in the FMU interface.
Receiving messages must then be handled internal to the FMU.

// TODO: how would that work in an annotation?

// TODO: do we need to define what the graphical representation looks like? Or should we not allow it?

==== CAN Message Terminal

Each CAN message described in the description file must be an element of its corresponding CAN bus terminal (see `<Terminal>` element of CAN bus terminal).

Attribute definitions::
 * `terminalKind` must be set to `CAN_message`.
 * `matchingRule` must be set to `bus`.
 * `name` must match the message name of the CAN bus description file in `/extra/org.modelica.fmi.layered_CAN`, prefixed with the CAN bus name and `::`.

Element definitions::
 * There must be no `<TerminalStreamMemberVariable>` element.
 * There must be no `<Terminal>` element.
 * There must be one `<TerminalMemberVariable>` per CAN signal of this CAN message.
 * There must be one `<TerminalMemberVariable>` for the clock referenced by all CAN signals of this message with their `clockReference` attribute.
 * Optionally, there can be an additional `<TerminalMemberVariable>` element referencing a variable of type `fmi3Binary` that contains the binary representation of the CAN message data.
   If one output CAN message has such a binary representation of the message data, all output CAN messages must have such a binary representation of the data.
   Any of the input CAN messages may have such a binary representation of the message data.

All `<TerminalMemberVariables>` must have the same type of either input or output, including the clock.

==== CAN Signal Variables

Each CAN signal must be listed as `<TerminalMemberVariable>` of its corresponding CAN message terminal.

Attribute definitions::
 * `variableName` refers to the input or output variable name of the FMU and to enforce uniqueness is built as follows: `BusName::MessageName::SignalName`.
 * `memberName` is the `SignalName` as given in the bus description file.
 * `variableKind` is `CAN_signal_physical` for all variables that represent physical (numeric) variables.
   For variables of type `fmi3Binary` the `variableKind` is set to `CAN_signal_binary`.

In case multiplexed signals are present in a message: all signals are present, but only the active signal according to the multiplex switch signal contains a valid value, all inactive values must be ignored _[those values could even be outside their specified min-max range without fault]_.

==== CAN Message Clocks

In order to use FMU input and output variables as transport layer for CAN buses, aperiodic clock variables are used.
Such a clock is activated by the sender to indicate the transmission of the corresponding CAN message.
Each CAN message `BusName::MessageName` has its own dedicated clock variable `BusName::MessageName_CLOCK`.
All clocked variables triggered by this clock belonging to the same CAN message are then valid and can be read by the recipients of this CAN messages.
The value of the clocked variable must be a message counter modulus 1024.

_[Using a message counter allows recipients to detect dropped messages._
_These clocks must be aperiodic clocks to allow for non-ideal bus communication patterns.]_

==== CAN Message Data

There can be an optional `fmi3Binary` variable representing the CAN message data.
For CAN message `BusName::MessageName` the name of the CAN message data variable is `BusName::MessageName_CLOCK` a

=== Known Limitations of this Standard

This layered standard maps the CAN bus protocol onto co-simulation variables as transport layer simulating in many ways an ideal CAN bus.
Such an ideal CAN bus differs from physical CAN buses in the following ways:

 * Bus message arbitration: CAN messages are sent according to priority (determined by Frame_ID) on wire.
   Here all message are transmitted at the same time without delay.

 * Bus congestion/bandwidth: too many CAN messages for the bandwidth of the bus.
   Here the CAN bus has infinite capacity.

 * Protocol functions of higher levels: i.e. CAN request for retransmit is a specific protocol function.
   Here such specialties must be handled by the first layer inside the FMU.

 * Incoming buffer overflow: when an ECU receives more messages than its buffer can hold.
   Here the FMU will receive all messages, regardless of buffer size.

 * Bus transmission errors: electrical errors which cause failed message transmission.
   Here no such transmission errors can occur, unless explicitly added into the simulation.
