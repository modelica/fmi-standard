=== FMI Description Schema [[fmi-description-schema]]

All static information related to an FMU is stored in the text file `modelDescription.xml` in XML format.
Especially, the FMU variables and their attributes such as name, unit, default <<initial>> value, etc. are stored in this file.
The structure of this XML file is defined with the schema file `fmiModelDescription.xsd`.
This schema file utilizes the following helper schema files:

- `fmi3Annotation.xsd`
- `fmi3AttributeGroups.xsd`
- `fmi3FMUType.xsd`
- `fmi3Terminal.xsd`
- `fmi3Type.xsd`
- `fmi3Unit.xsd`
- `fmi3Variable.xsd`
- `fmi3VariableDependency.xsd`

In this section these schema files are discussed.
The normative definition are the above mentioned schema files footnote:[Note that the screenshots of this section have been generated from the schema files with the tool "Altova XMLSpy" (www.altova.com).
With the enterprise edition of XMLSpy it is possible to automatically generate C++,
C# and Java code that reads an XML file of fmiModelDescription.xsd.
An efficient open source XML parser is SAX (http://sax.sourceforge.net/, http://en.wikipedia.org/wiki/Simple_API_for_XML).
All data from the XML file is only defined via attributes and not via elements.
Therefore, only an attribute handler needs to be defined for a SAX parser.].
Below, optional elements are marked with a dashed box.
The required data types (like: `xs:normalizedString`) are defined in https://www.w3.org/TR/xmlschema-2/[XML Schema Part 2: Datatypes Second Edition].
The types used in the FMI schema files are:

[cols="1,3,1"]
|====
|_XML_
|Description (http://www.w3.org/TR/xmlschema-2/)
|_Mapping to C_

|`double`
|IEEE double-precision 64-bit floating point type _[In order to not loose precision,
a number of this type should be stored on an XML file with at least 16 significant digits; for example, 2/3 should be stored as `0.6666666666666667`]_
|`double`

|`int`
|Integer number with maximum value 2147483647 and minimum value -2147483648 (32 bit Integer)
|`int`

|`unsignedInt`
|Integer number with maximum value 4294967295 and minimum value 0 (unsigned 32 bit Integer)
|`unsigned int`

|`boolean`
|Boolean number. Legal literals: `false`, `true`, `0`, `1`
|`char`

|`string`
|Any number of characters
|`char*`

|`normalizedString`
|String without carriage return, line feed, and tab characters
|`char*`

|`hexBinary`
|Arbitrary hex-encoded binary data
|`char*`

|`dateTime`
|Date, time and time zone (for details see the link above).
Example: `2002-10-23T12:00:00Z` (noon on October 23, 2002, Greenwich Mean Time)
|tool specific
|====

The first line of an XML file, such as `modelDescription.xml`, must contain the encoding scheme of the XML file.
It is required that the encoding scheme is always UTF-8:

[source, xml]
----
include::examples/co_simulation.xml[lines=1]
----

The FMI schema files (`fmi3*.xsd`) are also stored in UTF-8. +
_[Note that the definition of an encoding scheme is a prerequisite in order for the XML file to contain letters outside of the 7 bit ANSI ASCII character set, such as German umlauts, or Asian characters._
_Furthermore, note the FMI calling interface requires that strings are encoded in UTF-8._
_Since the XML files are also required to be encoded in UTF-8, string variables need not to be transformed when reading from the XML files in to C string variables.]._

The special values `NaN`, `+INF`, `-INF` for variables values are not allowed in the FMI XML files.

_[Note that child information items, such as elements in a sequence are ordered lists according to document order, whereas attribute information items are unordered sets (see http://www.w3.org/TR/XML-infoset/#infoitem.element)._
_The FMI schema is based on ordered lists in a sequence and therefore parsing must preserve this order._
_For example, the information stored in `ModelVariables.Derivatives` is only correct if this property is fulfilled.]_

==== Definition of an FMU (fmiModelDescription) [[fmiModelDescription]]

This is the root-level schema file and contains the following definition (the figure below contains all elements in the schema file.
Data is defined by attributes to these elements):

[[system_overview]]
image::images/fmiModelDescription_schema.png[]

On the top level, the schema consists of the following elements (see xref:system_overview[figure above]
footnote:[Note, elements `<ModelVariables>` and `<ModelStructure>` are mandatory,
whereas `<UnitDefinitions>`, `<TypeDefinitions>`, `<LogCategories>`, `<DefaultExperiment>`,
`<VendorAnnotation>` are optional.
If an optional element is present and defines a list (such as `<UnitDefinitions>`),
the list must have at least one element (such as `<Unit>`).]):

[cols="1,3",options="header"]
|====
|Element-Name
|Description

|`ModelExchange`
|If present, the FMU is based on FMI for Model Exchange _[(in other words, the FMU includes the model or the communication to a tool that provides the model, and the environment provides the simulation engine)]_.

|`CoSimulation`
|If present, the FMU is based on FMI for Co-Simulation _[(in other words, the FMU includes the model and the simulation engine, or a communication to a tool that provides the model and the simulation engine, and the environment provides the master algorithm to run coupled FMU Co-Simulation slaves together)]_.

|`UnitDefinitions`
|A global list of unit and display unit definitions _[for example, to convert display units into the units used in the model equations]_.
These definitions are used in the XML element `ModelVariables`.

|`TypeDefinitions`
|A global list of type definitions that are utilized in `ModelVariables`.

|`LogCategories`
|A global list of log categories that can be set to define the log information that is supported from the FMU.

|`DefaultExperiment`
|Providing default settings for the integrator, such as stop time and relative tolerance.

|`VendorAnnotations`
|Additional data that a vendor might want to store and that other vendors might ignore.

|`ModelVariables`
|The central FMU data structure defining all variables of the FMU that are visible/accessible via the FMU functions.

|`ModelStructure`
|Defines the structure of the model.
Especially, the ordered lists of <<output,`outputs`>>, continuous-time <<state,`states`>> and initial unknowns (the unknowns during Initialization Mode) are defined here.
Furthermore, the dependency of the unkowns from the knowns can be optionally defined.
_[This information can be, for example, used to compute efficiently a sparse Jacobian for simulation, or to utilize the <<input>> / <<output>> dependency in order to detect that in some cases there are actually no algebraic loops when connecting FMUs together]_.
|====

At least one element of `ModelExchange` or `CoSimulation` must be present to identify the type of the FMU.
If both elements are defined, different types of models are included in the FMU.
The details of these elements are defined in <<ModelExchange>> and <<fmi-for-co-simulation>>.

The XML attributes of `fmiModelDescription` are:

image::images/fmiModelDescription_schema_2.png[width=80%, align="center"]

[cols="1,3",options="header"]
|====
|Attribute-Name
|Description

|`fmiVersion`
|Version of FMI for Model Exchange or FMI for Co-Simulation that was used to generate the XML file.
The value for this version is `3.0`.
Future minor revisions are denoted as `3.0.1`, `3.1`, ...

_[During development prototype FMU implementations can indicate compliance with a certain development version based on the tags available at https://github.com/modelica/fmi-standard/tags._
_For example the value for the FMI 3.0 Alpha 2 release is `3.0-alpha.2`.]_

|`modelName`
|The name of the model as used in the modeling environment that generated the XML file, such as `Modelica.Mechanics.Rotational.Examples.CoupledClutches`.

|`instantiationToken`
|The instantiationToken is a string that can be used by the FMU to check that the XML file is compatible with the implementation of the FMU.
For this purpose the importing tool must pass the instantiationToken from the `modelDescription.xml` to the `fmi3Instantiate` function call.

|`description`
|Optional string with a brief description of the model.

|`author`
|Optional string with the name and organization of the model author.

|`version`
|Optional version of the model _[for example `1.0`]_.

|`copyright`
|Optional information on the intellectual property copyright for this FMU _[for example `(C) My Company 2011`]_.

|`license`
|Optional information on the intellectual property licensing
for this FMU _[for example `BSD license <license text or link to license>`]_.

|`generationTool`
|Optional name of the tool that generated the XML file.

|`generationDateAndTime`
|Optional date and time when the XML file was generated.
The format is a subset of `dateTime` and should be: `YYYY-MM-DDThh:mm:ssZ` (with one `T` between date and time; `Z` characterizes the Zulu time zone, in other words, Greenwich meantime) _[for example `2009-12-08T14:33:22Z`]_.

|`variableNamingConvention`
|Defines whether the variable names in `ModelVariables / Variable / name` and in `TypeDefinitions / Type / name` follow a particular convention.
For the details, see <<variableNamingConvention>>. Currently standardized are:

- `flat`: A list of strings (the default).

- `structured`: Hierarchical names with `.` as hierarchy separator, and with array elements and derivative characterization.

|`numberOfEventIndicators`
|The (fixed) number of event indicators for an FMU based on FMI for Model Exchange. For Co-Simulation, this value is ignored.
|====

==== Definition of Source Code (BuildConfiguration)

The `BuildConfiguration` provides the necessary information to compile and link the contained sources of the model into a dynamic library or as part of an executable.

[cols="1,3a",options="header"]
|====
|Attribute
|Description

|modelIdentifier
|The `modelIdentifier` of the `ModelExchange` or `CoSimulation` elements this build configuration is associated with.

|platform
|Platform tuple of the platform the build configuration is intended for (e.g. `x86_64-linux`)

|description
|Description of the build configuration
|====

===== SourceFileSet

The `SourceFileSet` element groups source files that can be compiled with the same compiler and compiler options. Every build configuration must contain at least one `SourceFileSet`.

[cols="1,3a",options="header"]
|====
|Attribute
|Description

|language
|Language of the source files (e.g. `C99`, `C++11`)

|compiler
|The compiler to compile the sources (e.g. `VisualC`, `gcc`, `clang++`)

|compilerOptions
|The compiler flags that have to be used when compiling the sources (e.g. `-fno-rtti`, `/Od`)
|====

====== SourceFile

[cols="1,3a",options="header"]
|====
|Attribute
|Description

|name
|Path of the source file relative to the `sources` directory
|====

====== PreprocessorDefinition

The `PreprocessorDefinition` element defines a preprocessor definition that needs to be passed to the compiler when compiling the source files in the `SourceFileSet`.

[cols="1,3a",options="header"]
|====
|Attribute
|Description

|`name`
|Name of the preprocessor definition

|`value`
|Value of the preprocessor definition

|`optional`
|Determines wether the definition is optional (default is `false`)

|`description`
|Description of the preprocessor definition
|====

====== PreprocessorDefinition/Option

The `Option` element defines a possible value for the `PreprocessorDefinition`. If a `PreprocessorDefinition` contains `Option` elements, its default value must be contained in the options.

[cols="1,3a",options="header"]
|====
|Attribute
|Description

|`value`
|Value of the preprocessor definition option

|`description`
|Description of the preprocessor definition option
|====

====== IncludeDirectory

The `IncludeDirectory` element defines the include directories that need to be passed to the compiler when compiling the source files in the `SourceFileSet`.

[cols="1,3a",options="header"]
|====
|Attribute
|Description

|`name`
|Path of the include directory relative to the `sources` directory
|====

====== Library

The `Library` element defines a static library required to link the model binary.

[cols="1,3a",options="header"]
|====
|Attribute
|Description

|`name`
|Name of the library

|`version`
|Version specifier of the library as defined in https://www.python.org/dev/peps/pep-0440/#version-specifiers[PEP 440].
The characters `>` (greater-than) and `<` (less-than) must be escaped as `&gt;` and `&lt;`.
 _[For example `2.5`, `>=2.0,<3.0` or `>=1.0,!=1.2`]_.

|`external`
|Boolean attribute that determines wether the library is contained in the `binaries/<platform_tuple>` directory (`false`) or if it has to be provided by the environment (`true`). The default is `false`.

|`description`
|Description of the library definition option
|====

====== Examples

.A minimal build configuration
[source, xml]
----
include::examples/build_configuration.xml[tags=PIDContoller]
----

.Multiple complex build configurations
[source, xml]
----
include::examples/build_configuration.xml[tags=PlantModel]
----

==== Definition of Units (UnitDefinitions)

_[In this section, the units of the variables are (optionally) defined._
_Unit support is important for technical systems since otherwise it is very easy for errors to occur._
_Unit handling is a difficult topic, and there seems to be no method available that is really satisfactory for all applications, such as unit check, unit conversion, unit propagation or dimensional analysis._
_In FMI, a pragmatic approach is used that takes into account that every software system supporting units has potentially its own specific technique to describe and utilize units._
_The approach used here is slightly different than FMI 1.0 to reduce the need for standardized string representations.]_

Element `UnitDefinitions` of `fmiModelDescription` is defined as:

image::images/UnitDefinitions_schema.png[]

It consists of zero or more `Unit` definitions footnote:[If no units are defined, element `<UnitDefinitions>` must not be present.
If 1 or more units are defined, this element must be present.].
A `Unit` is defined by its `name` attribute such as `N.m` or `N*m` or `Nm`, which must be unique with respect to all other defined elements of the `UnitDefinitions` list.
If a variable is associated with a `Unit`, then the value of the variable has to be provided with the `fmi3SetXXX` functions or else is returned by the `fmi3GetXXX` functions with respect to this `Unit`.
_[The purpose of the name is to uniquely identify a unit and, for example, use it to display the unit in menus or in plots._
_Since there is no standard to represent units in strings, and there are different ways how this is performed in different tools, no specific string representation of the unit is required.]_

Optionally, a value given in unit `Unit` can be converted to a value with respect to unit `BaseUnit` utilizing the conversion `factor` and `offset` attributes:

image::images/BaseUnit_schema.png[width=50%, align="center"]

Besides `factor` and `offset`, the `BaseUnit` definition consists of the exponents of the 7 SI base units `kg`, `m`, `s`, `A`, `K`, `mol`, `cd`, and of the exponent of the SI derived unit `rad`.
_[Depending on the analysis/operation carried out, the SI derived unit `rad` is or is not utilized, see discussion below._
_The additional `rad` base unit helps to handle the often occurring quantities in technical systems that depend on an angle.]_

A value with respect to `Unit` (abbreviated as `Unit_value`) is converted with respect to `BaseUnit` (abbreviated as `BaseUnit_value`) by the equation:

`BaseUnit_value = factor * Unit_value + offset`

_[For example, if_ latexmath:[\color{blue}{p_{bar}}] _is a pressure value in unit `bar`, and_ latexmath:[\color{blue}{p_{Pa}}] _is the pressure value in `BaseUnit`, then_

latexmath:[\color{blue}{p_{Pa} = 10^5 p_{bar}}]

_and therefore, `factor = 1.0e5` and `offset = 0.0`._

_In the following table several unit examples are given (Note that if in column `exponents` the definition "latexmath:[\color{blue}{kgm^2 / s^2}]" is present, then the attributes of `BaseUnit` are: `kg=1, m=2, s=-2`):_

[cols="1,1,1,1,1"]
|====
.2+^|*Quantity*
.2+^|*Unit.name* +
(examples)
3+^|*Unit.BaseUnit*
^|*exponents*
^|*factor*
^|*offset*

^|_Torque_
^|`N.m`
^|latexmath:[\color{blue}{kg \cdot m^2 / s^2}]
^|`1.0`
^|`0.0`

^|_Energy_
^|`J`
^|latexmath:[\color{blue}{kg \cdot m^2 / s^2}]
^|`1.0`
^|`0.0`

^|_Pressure_
^|`bar`
^|latexmath:[\color{blue}{\frac{kg}{m \cdot s^2}}]
^|`1.0e5`
^|`0.0`

^|_Angle_
^|`deg`
^|`rad`
^|`0.01745329251994330 (= pi/180)`
^|`0.0`

^|_Angular velocity_
^|`rad/s`
^|`rad/s`
^|`1.0`
^|`0.0`

^|_Angular velocity_
^|`rpm`
^|`rad/s`
^|`0.1047197551196598 (=2*pi/60)`
^|`0.0`

^|_Frequency_
^|`Hz`
^|`rad/s`
^|`6.283185307179586` +
`(= 2*pi)`
^|`0.0`

^|_Temperature_
^|`&#176;F`
^|`K`
^|`0.5555555555555556` +
`(= 5/9)`
|`255.3722222222222` +
`(= 273.15-32*5/9)`

^|_Per cent by length_
^|`%/m`
^|`1/m`
^|`0.01`
^|`0.0`

^|_Parts per million_
^|`ppm`
^|`1`
^|`1.0e-6`
^|`0.0`

^|_Length_
^|`km`
^|`m`
^|`1000`
^|`0.0`

^|_Length_
^|`yd`
^|`m`
^|`0.9144`
^|`0.0`
|====

_Note that `Hz` is typically used as `Unit.name` for a frequency quantity, but it can also be used as `DisplayUnit` for an angular velocity quantity (since `revolution/s`).]_

_The `BaseUnit` definitions can be utilized for different purposes (the following application examples are optional and a tool may also completely ignore the `Unit` definitions):_

Signal connection check::
+
_When two signals v1 and v2 are connected together, and on at least one of the signals no `BaseUnit` element is defined, then the connection equation "v2 = v1" holds (if v1 is an <<output>> of an FMU and v2 is an <<input>> of another FMU, with `fmi3GetXXX` the value of v1 is inquired and used as value for v2 by calling `fmi3SetXXX`)._
+
_When two signals v1 and v2 are connected together, and for both of them `BaseUnit` elements are defined, then they must have identical exponents of their `BaseUnit`._
_If `factor` and `offset` are also identical, again the connection equation `v2 = v1` holds._
_If `factor` and `offset` are not identical, the tool may either trigger an error or, if supported, perform a conversion; in other words, use the connection equation (in this case the `relativeQuantity` of the `TypeDefinition`, see below, has to be taken into account in order to determine whether `offset` shall or shall not be utilized):_
+
`factor(v1) * v1 + offset(v1) = factor(v2) * v2 + offset(v2)`
+
_As a result, wrong connections can be detected (for example, connecting a force with an angle signal would trigger an error) and conversions between, say, US and SI units can be either automatically performed or, if not supported, an error is triggered as well._
+
_[Note that this approach is not satisfactory for variables belonging to different quantities that have, however, the same `BaseUnit`, such as quantities `Energy` and `Torque`, or `AngularVelocity` and `Frequency`._
_To handle such cases, quantity definitions have to be taken into account (see `TypeDefinitions`) and quantity names need to be standardized.]_
+
_This approach allows a general treatment of units, without being forced to standardize the grammar and allowed values for units (for example, in FMI 1.0, a unit could be defined as `N.m` in one FMU and as `N*m` in another FMU, and a tool would have to reject a connection, since the units are not identical. In FMI 2.0, the connection would be accepted, provided both elements have the same `BaseUnit` definition)._

Dimensional analysis of equations::
+
_In order to check the validity of equations in a modeling language, the defined units can be used for dimensional analysis, by using the `BaseUnit` definition of the respective unit._
_For this purpose, the `BaseUnit` `rad` has to be treated as `1`._
_Example:_
+
[latexmath]
++++
\begin{align*}
J \cdot \alpha = \tau \rightarrow [kg.m^2]*[rad/s^2] = [kg.m^2/s^2] & \quad \text{// o.k. ("rad" is treated as "1")} \\
J \cdot \alpha = f \rightarrow [kg.m^2]*[rad/s^2] = [kg.m/s^2] & \quad \text{// error, since dimensions do not agree}
\end{align*}
++++

Unit propagation::
+
_If unit definitions are missing for signals, they might be deduced from the equations where the signals are used._
_If no unit computation is needed, `rad` is propagated._
_If a unit computation is needed and one of the involved units has `rad` as a `BaseUnit`, then unit propagation is not possible._
_Examples:_
+
- _a = b + c, and `Unit` of c is provided, but not `Unit` of a and b:_ +
_The Unit definition of `c` (in other words, `Unit.name`, `BaseUnit`, `DisplayUnit`) is also used for `a` and `b`._
_For example, if BaseUnit(c) = `rad/s`, then BaseUnit(a) = BaseUnit(b) = `rad/s`._
+
- _a = b*c, and `Unit` of a and of c is provided, but not `Unit` of b:_ +
_If `rad` is either part of the `BaseUnit` of `a` and/or of `c`, then the `BaseUnit` of `b` cannot be deduced (otherwise it can be deduced)._
_Example: If `BaseUnit(a) = kg.m/s2` and `BaseUnit(c) = m/s2`, then the `BaseUnit(b) can be deduced to be `kg`._
_In such a case `Unit.name` of b cannot be deduced from the `Unit.name` of `a` and `c`, and a tool would typically construct the `Unit.name` of `b` from the deduced `BaseUnit`._

_]_

Additionally to the unit definition, optionally a set of display units can be defined that can be utilized for <<input>> / <<output>> of a value:

image::images/DisplayUnit_schema.png[width=80%, align="center"]

A `DisplayUnit` is defined by `name`, `factor` and `offset`.
The attribute `name` must be unique with respect to all other `names` of the `DisplayUnit` definitions of the same `Unit` [(different `Unit` elements may have the same `DisplayUnit` names)].
A value with respect to Unit (abbreviated as `Unit_value`) is converted with respect to `DisplayUnit` (abbreviated as `DisplayUnit_value`) by the equation:

`DisplayUnit_value = factor * Unit_value + offset`

_[`offset` is, for example, needed for temperature units.]_

_[For example, if latexmath:[\color{blue}{T_K}] is the temperature value of `Unit.name` (in `K`) and latexmath:[\color{blue}{T_F}] is the temperature value of `DisplayUnit` (in `&#176;F`), then_

[latexmath]
++++
T_F = (9/5) * (T_K - 273.15) + 32
++++

_and therefore, `factor = 1.8 (=9/5)` and `offset = -459.67 (= 32 - 273.15*9/5)`._

_Both the `DisplayUnit.name` definitions as well as the `Unit.name` definitions are used in the `Variable` elements._
_Example of a definition:_

[source, xml]
----
include::examples/unit_definition.xml[tags=UnitDefinitions]
----
_]_

The schema definition is present in a separate file `fmi3Unit.xsd`.

==== Definition of Types (TypeDefinitions) [[definition-of-types]]

Element `TypeDefinitions` of `fmiModelDescription` is defined as:

image::images/TypeDefinitions_schema.png[width=90%, align="center"]

This element consists of a set of `SimpleType` definitions according to schema `fmi3SimpleType` in file `fmi3Type.xsd`.
One `SimpleType` has a type `name` and `description` as attributes.
Attribute `name` must be unique with respect to all other elements of the `TypeDefinitions` list.
Furthermore, `name` of a `SimpleType` must be different to all `name` attributes of `Variable`pass:[s] _[if the same names would be used, then this would nearly always give problems when importing the FMU in an environment such as Modelica, where a type name cannot be used as instance name]_.
Additionally, one of the elements `Real`, `Integer`, `Boolean`, `String`, `Binary`, `Enumeration` or `Clock` must be present.
They have the following definitions:

image::images/Real_schema.png[width=50%, align="center"]

image::images/Integer_schema.png[width=50%, align="center"]

_[The attributes of `Real` and `Integer` are collected in the attribute groups `fmi3RealAttributes` and `fmi3IntegerAttributes` in file `fmi3AttributeGroups.xsd`, since these attributes are reused in the `Variable` element definitions below.]_

image::images/Enumeration_schema.png[width=80%, align="center"]

These definitions are used as default values in element `Variable`pass:[s] _[in order that, say, the definition of a `Torque` type does not have to be repeated over and over again]_.
The attributes and elements have the following meaning:

[cols="1,5",options="header"]
|====
|_Name_
|_Description_

|`quantity`
|Physical quantity of the variable. _[For example, `Angle`, or `Energy`.
The quantity names are not standardized]_

|`unit`
|Unit of the variable defined with `UnitDefinitions.Unit.name` that is used for the model equations.
_[For example, `N.m`: in this case a `Unit.name = `N.m` must be present under `UnitDefinitions`.]_

|`displayUnit`
|Default display unit. The conversion to the `unit` is defined with the element `<fmiModelDescription><UnitDefinitions>`.
If the corresponding `displayUnit` is not defined under `<UnitDefinitions> <Unit> <DisplayUnit>`, then `displayUnit` is ignored.
It is an error if `displayUnit` is defined in element `Real`, but `unit` is not, or unit is not defined under `<UnitDefinitions><Unit>`.

|`mimeType`
|Indicates the type of data passed as a binary.
Defaults to `application/octet-stream`, which is unspecific.
Implementations can use this information to provide guidance to the user about valid/useful connections.

|`relativeQuantity`
|If this attribute is `true`, then the `offset` of `displayUnit` must be ignored.
_[For example, 10 degree Celsius = 10 Kelvin if `relativeQuantity = true` and not 283.15 Kelvin.]_

|`min`
|Minimum value of variable (variable value &#8805; `min`).
If not defined, the minimum is the largest negative number that can be represented on the machine.
The `min` definition is information from the FMU to the environment defining the region in which the FMU is designed to operate, see also comment after this table.

|`max`
|Maximum value of variable (variable value &#8804; `max`).
If not defined, the maximum is the largest positive number that can be represented on the machine.
The `max` definition is information from the FMU to the environment defining the region in which the FMU is designed to operate, see also comment after this table.

|`nominal`
|Nominal value of variable.
If not defined and no other information about the nominal value is available, then nominal = 1 is assumed. +
_[The nominal value of a variable can be, for example, used to determine the absolute tolerance for this variable as needed by numerical algorithms:_ +
`absoluteTolerance = nominal * tolerance * 0.01` +
_where `tolerance` is, for example, the relative tolerance defined in `<DefaultExperiment>`, see <<DefaultExperiment>>.]_

|`unbounded`
|If `true`, indicates that during time integration, the variable gets a value much larger than its nominal value `nominal`.
_[Typical examples are the monotonically increasing rotation angles of crank shafts and the longitudinal position of a vehicle along the track in long distance simulations._
_This information can, for example, be used to increase numerical stability and accuracy by setting the corresponding bound for the relative error to zero (relative tolerance = 0.0), if the corresponding variable or an alias of it is a continuous <<state>> variable.]_

|Item
|Items of an enumeration has a sequence of `name` and `value` pairs.
The values can be any integer number but must be unique within the same enumeration (in order that the mapping between `name` and `value` is bijective).
An `Enumeration` element must have at least one Item.
|====

_[Attributes `min` and `max` can be set for variables of type Real, Integer or Enumeration._
_The question is how `fmi3SetReal`, `fmi3SetInteger`, `fmi3GetReal`, `fmi3GetInteger` shall utilize this definition._
_There are several conflicting requirements:_ +
_Avoiding forbidden regions (for example, if `u` is an <<input>> and "sqrt(u)" is computed in the FMU, min=0 on `u` shall guarantee that only values of `u` in the allowed regions are provided)._
_Numerical algorithms (ODE-solver, optimizers. nonlinear solvers) do not guarantee constraints._
_If a variable is outside of the bounds, the solver tries to bring it back into the bounds._
_As a consequence, calling `fmi3GetReal` during an iteration of such a solver might return values that are not in the defined min/max region._
_After the iteration is finalized, it is only guaranteed that a value is within its bounds up to a certain numerical precision._ +
_In debug mode checks on min/max should be performed._
_For maximum performance on a real-time system the checks might not be performed._ +
_The approach in FMI is therefore that min/max definitions are an information from the FMU to the environment defining the region in which the FMU is designed to operate._
_The environment is free to utilize this information (typically, in debug mode of the environment the min/max is checked in the cases as stated above)._
_In any case, it is expected that the FMU handles variables appropriately where the region definition is critical._
_For example, dividing by an <<input>> (so the <<input>> should not be in a small range of zero) or taking the square root of an <<input>> (so the <<input>> should not be negative) may either result in `fmi3Error`, or the FMU is able to handle this situation in other ways._

_If the FMU is generated so that min/max shall be checked whenever meaningful (for example, for debug purposes), then the following strategy should be used:_

_If `fmi3SetReal` or `fmi3SetInteger` is called violating the min/max attribute settings of the corresponding variable, the following actions are performed:_

- _On a <<fixed>> or <<tunable>> <<parameter>> `fmi3Status = fmi3Discard` is returned._
- _On an <<input>>, the FMU decides what to return (If no computation is possible, it could return `fmi3Status = fmi3Discard`, in other situations it may return `fmi3Warning` or `fmi3Error`, or `fmi3OK`, if it is uncritical)._

_If an FMU defines min/max values for Integer and Enumerations (<<local>> and <<output>> variables), then the expected behavior of the FMU is that `fmi3GetInteger` returns values in the defined range._

_If an FMU defines min/max values for Reals, then the expected behavior of the FMU is that `fmi3GetReal` returns values at the solution (accepted steps of the integrators) in the defined range with a certain uncertainty related to the tolerances of the numerical algorithms.]_

*Clock Type Definition* [[clock-type-definition]]

Clocks are integrated in the element `ModelVariables` of fmiModelDescription as a `Variable` element with the base type `fmi3Clock`.
The variable sub type `fmi3Clock` provides additional attributes for defining <<clock,`clocks`>>.

[cols="1,5",options="header"]
|====
|_Attribute-Name_
|_Description_

|`clockType`
|The type of <<clock,`clocks`>> is defined based on the mandatory attribute `clockType`.
If the properties of a <<clock>> adhere to synchronous clock theory it is defined with clockType = `STClock`.
As an additional option for FMI for Co-Simulation discrete parts (that do not necessarily apply to synchronous clock theory) or continuous parts of the FMU can be associated to model partitions via <<clock,`clocks`>> whose ticks define the sampling points (i.e. communication points) for the variables of these model partitions.
Clocks that are defined for such cases have the clockType attribute value `CPClock` and have to be ignored for FMI for Model Exchange.
It is not allowed to include <<clock,`clocks`>> of different `clockType` in one FMU.
`clockType` is a required attribute.

|`priority`
|The <<clock,`clocks`>> are ordered descending based on their priorities.
The priority of a <<clock>> has to be defined via the integer attribute `priority` - smaller values have a higher priority.
It is possible to define multiple <<clock,`clocks`>> with the same priority.
No ordering is defined for <<clock,`clocks`>> of the same priority.
If a computational order information is needed, different priorities have to be defined.
//TODO: Are 100 different priority levels enough?
The minimum value is 0 (max priority).
The maximum value is 99 (min priority).

_[For periodic <<clock,`clocks`>> it is recommended to derive the priorities based on a rate monotonic scheduling scheme (smallest period leads to highest priority (smallest priority value)).]_

`priority` is a required attribute.

|`periodic`
|Clocks can be periodic or non-periodic. If a <<clock>> is periodic the attribute `periodic = true`.

`periodic` is an optional attribute. The default value is `false`.

|`strict`
|If a periodic <<clock>> is strictly periodic, the `strict` attribute is `true`.
If the optional attribute `strict` is set to `true`, then the FMU and the simulation master have to respect the predefined interval and offset.
If the optional attribute `strict` is set to `false` another interval or offset can be used, derived from the current simulation setup.

`strict` is an optional attribute. The default value is `false`.
It is not allowed to set `strict` to `true` if `periodic = false`.

|`intervalCounter`, `shiftCounter`, `resolution`
|The interval of <<output>> or <<input>> periodic <<clock,`clocks`>> is defined with unsignedLong valued `intervalCounter` and `resolution`

`interval = intervalCounter / resolution`.

The initial tick of periodic <<clock,`clocks`>> may be delayed by defining a `shiftCounter` (default value 0). This results in the actual

`offset = interval * shiftCounter / resolution`.

More information about clock intervals:
 <<additional-clock-properties>>.

The attributes `intervalCounter`, `shiftCounter` and `resolution` are interval <<start>> values for periodic <<clock,`clocks`>> and must not be used together with non-periodic <<clock,`clocks`>>.
If `strict = true` it is required to provide values for `intervalCounter`, `shiftCounter` and `resolution`.

`intervalCounter` and `resolution` have no default value.
|====

[#TypeDefinitions]
image::images/clock_variable.png[]

==== Definition of Log Categories (LogCategories) [[definition-of-log-categories]]

Element `LogCategories` of `fmiModelDescription` is defined as:

image::images/LogCategories_schema.png[width=70%, align="center"]

`LogCategories` defines an unordered set of category strings that can be utilized to define the log output via function <<logMessage>>, see <<creation-destruction-and-logging>>.
A tool is free to use any `normalizedString` for a category value.
The `name` attribute of `Category` must be unique with respect to all other elements of the `LogCategories` list.

There are the following standardized names for `Category` and these names should be used if a tool supports the corresponding log category.
If a tool supports one of these log categories and wants to expose it, then an element Category with this name should be added to `LogCategories` _[To be clear, only the Category names listed under `LogCategories` in the XML file are known to the environment in which the FMU is called.]_

[cols="1,3",options="header"]
|====
|_Category name_
|_Description_

|`logEvents`
|Log all events (during initialization and simulation).

|`logSingularLinearSystems`
|Log the solution of linear systems of equations if the solution is singular (and the tool picked one solution of the infinitely many solutions).

|`logNonlinearSystems`
|Log the solution of nonlinear systems of equations.

|`logDynamicStateSelection`
|Log the dynamic selection of <<state,`states`>>.

|`logStatusWarning`
|Log messages when returning `fmi3Warning` status from any function.

|`logStatusDiscard`
|Log messages when returning `fmi3Discard` status from any function.

|`logStatusError`
|Log messages when returning `fmi3Error` status from any function.

|`logStatusFatal`
|Log messages when returning `fmi3Fatal` status from any function.

|`logAll`
|Log all messages.
|====

The optional attribute `description` shall contain a description of the respective log category.
_[Typically, this string can be shown by a tool if more details for a log category shall be presented.]_

_[This approach to define `LogCategories` has the following advantages:_

. _A simulation environment can present the possible log categories in a menu and the user can select the desired one (in the FMI 1.0 approach, there was no easy way for a user to figure out from a given FMU what log categories could be provided)._ +
_Note that since element `LogCategories` is optional, an FMU does not need to expose its log categories._

. _The log output is drastically reduced, because via <<fmi3SetDebugLogging>> exactly the categories are set that shall be logged and therefore the FMU only has to print the messages with the corresponding categories to the <<logMessage>> function._
_In FMI 1.0, it was necessary to provide all log output of the FMU to the <<logMessage>> and then a filter in the <<logMessage>> could select what to show to the end-user._
_The approach introduced in FMI 2.0 is therefore much more efficient.]_

==== Definition of a Default Experiment (DefaultExperiment) [[DefaultExperiment]]

Element `DefaultExperiment` of `fmiModelDescription` is defined as:

image::images/DefaultExperiment_schema.png[width=70%, align="center"]

`DefaultExperiment` consists of the optional default start time, stop time, relative tolerance, and step size for the first simulation run.
A tool may ignore this information.
However, it is convenient for a user that `startTime`, `stopTime`, `tolerance` and `stepSize` have already a meaningful default value for the model at hand.
Furthermore, for Co-Simulation the `stepSize` defines the preferred `communicationStepSize`.

==== Definition of Terminals (Terminals)

===== Rationale

Terminals are fully optional and can be ignored by any importing tool.

Definition `Terminal`: A terminal is...

* a structured interface for connections to other models
* intended to be used for signal flow between models, parameter propagation, and compatibility checks of the model configuration
* a sequence of references to variables with connection meta data

Predefined rules for variable matching in a connection are given below.
Predefined variable kinds are used to describe how the member variables have to be handled.
Domain specific connection rules, terminals and their member variables can be provided by other standards.

_[Co-Simulation errors are not addressed by the terminals._
_The co-simulation algorithm has to be chosen and implemented by the importing tool._
_Features that might be required for specific co-simulation algorithms had to be implemented by the FMU exporting tool._

_Algebraic loops in systems of connected Model Exchange FMUs are not addressed or resolved by the terminals._
_It is not required that the <<causality>> of the terminal member variables in connected terminals match._

_The SSP standard refers to a `connectorKind`._
_This `connectorKind` is not related to the `terminalKind` or `variableKind` described in the following sections.]_

===== Terminals

Element `Terminals` of `fmiModelDescription` is defined as:

image::images/fmiModelDescription_Terminals_Schema.png[width=40%, pdfwidth=40%, align="center"]

All instances of `Terminal` have the type `fmi3Terminal` and are listed in the `Terminals` sequence:

image::images/fmiModelDescription_Terminals_Terminal_Schema.png[width=60%, pdfwidth=60%, align="center"]

The normalized string attribute `name` of the `Terminal` element is the instance name of the terminal. The terminal name must be unique on each level.
//_[The terminal name may contain dots, to enable structured terminals.]_

The normalized string attribute `matchingRule` describes the rules for variable matching in a connection.
There are three predefined matching rules: plug, bus, and sequence.
Other standards may define new matching rules.
_[It is recommended that vendor specific rules start with `_vendorName` or `_toolName` to avoid namespace clashes.]_

There is a sequence of terminal member variables, terminal stream member variables, and nested terminals in the `Terminal` element.
The member variables are the exchanged variables.
The type of the nested terminals is `fmi3Terminal`, and they can be used to implement structured terminals.

[cols="1,3",options="header"]
|====
|_matchingRule_
|_Description_

[[plug,`plug`]]
|`plug`
|Matching of the variables is based on `memberName`.
An importing tool should connect terminals only if all member variables are present and match.

[[bus,`bus`]]
|`bus`
|Matching of the variables is based on `memberName`.
An importing tool may connect terminals if some or no terminal member variables are present.

[[sequence,`sequence`]]
|`sequence`
|Matching of the variables is based on the order of the terminal member variables.
An importing tool should connect terminals only if the number of member variables matches.

|====

The normalized string `terminalKind` is an optional attribute. Other standards may define terminal kinds.
It is intended that the `terminalKind` is used to define domain specific member variable sequences, member names and order, or high level restrictions for connections.

_[Other terminal kinds should refer to the predefined matchingRules._
_Vendor specific terminal kinds should start with `_vendorName` or `_toolName` to avoid namespace clashes._

_Examples for `terminalKind`: `StandardXXX_Mechanical_Translational`, `Modelica.Mechanics.Translational.Interfaces.Flange_a`, `vendorNameA_customTypeA`, `_vendorNameB_customLibrary_customTypeB`._

_The structured naming convention of the `ModelVariables` is <<independent>> from the terminal names and member variable names._

_A tool may choose to connect terminals with a different or unknown `terminalKind`, if the `matchingRule` matches.]_

===== Terminal Member Variable

The `TerminalMemberVariable` is defined as:

image::images/fmi3Terminal_TerminalMemberVariable_Schema.png[width=50%, pdfwidth=50%, align="center"]

The normalized string `variableKind` is used to provide general information about the variable.
This information defines how the connection of this variable has to be implemented (e.g. Kirchhoff's current law or common signal flow).

The normalized string `memberName` is the representation in tools which apply name-based matching in connections.
The member name has to be unique in a terminal.

The normalized string `variableName` is used to identify the terminal member variable in the list of `ModelVariables`.
_[The `name` attribute of the model variable is equal to the `variableName` of the `TerminalMemberVariable`._
_An importing tool may use the `variableName` attribute to identify a specific alias to get additional information, such as minimum, maximum, and nominal values.]_

One variable can be part of several terminals, which is considered aliasing according to the rules of <<aliasing-of-variables>>.

_[Tools which apply sequence based matching should also provide unique member names, so that all importing tools which use name based matching use the same member names._

_The suggested variable naming scheme for the structured naming convention is <ModelVariable name> = <terminalName>.<memberName>_.

_Not all `ModelVariables` which have the prefix "<terminalName>." are a member variable, and there may exist member variables which don't have this prefix._

_Example 1 (suggested scheme): <ModelVariable name> is `portA.U`, <terminalName> is `portA`, <memberName> is `U`._

_Example 2 (suggested scheme): <ModelVariable name> is `hierarchConn.innerConn.U`, <outer terminal name> is `hierarchConn`, <inner terminal name> is `innerConn`, <memberName> is `U`._

_Example 3 (no prefix): <ModelVariable name> is `u`, <terminalName> is `portA`, <memberName> is `u`._

_Example 4 (prefix but not a member): <ModelVariable name> is `portA.u`, there is a terminal with <terminalName> `portA`, but this variable is not a terminal member._

_The suggested variable naming scheme for the non-structured naming convention is: <ModelVariable name> = <memberName>_

_Matching is not restricted by <<variability>>, <<causality>> or variable type._
_Example: A <<fixed>> variable may be connected to a <<tunable>> variable, a variable of type Real may be connected to a variable of type Integer._
_However, it is recommended that the variable types and variabilities are equal._

_The `matchingRule` refers to the `TerminalMemberVariables` on the same level only. Nested terminals can have different `matchingRules`._

_There is no special handling of <<derivative,`derivatives`>>._
_If a <<derivative>> is a terminal member variable then it is considered as normal member variable._
_However, if a <<derivative>> of a terminal member variable is not terminal member, then this <<derivative>> information may be used by an importing tool.]_

The predefined variable kinds are:
[cols="1,3",options="header"]
|====
|_variableKind_
|_Description_

[[signal,`signal`]]
|`signal`
|The values in connected terminals are intended to be equal.
Restricted to <<input>> and <<output>>, <<parameter>> and <<calculatedParameter>>.
_[Example: Signal flow, parameter propagation, equality checks]_

[[inoutflow,`inflow/outflow`]]
|`inflow` / `outflow`
|Variables which fulfill Kirchhoff's current law.
Restricted to <<input>> and <<output>>, <<parameter>> and <<calculatedParameter>>.
_[Example: Electric current]_
|====

===== General remark on signal

_[The signal `variableKind` can be applied for different use cases._
_The first use case is a signal flow from an <<output>> of one FMU to an <<input>> of another FMU. The <<output>> value has to be forwarded to the <<input>>._

_The signal flow can cause algebraic loops._
_If variables in connected terminals have the <<causality>> <<output>>, then an importing tool may iterate an undefined <<input>> of an FMU to ensure that the connected output values are equal._

_Another use case is the parameter propagation._
_If a variable in both connected terminals has the <<causality>> <<parameter>>, then an importing tool could ask the user for the value of one of those <<parameter,`parameters`>> only, and propagate this value to the other FMU._
_If only one of the variables has <<causality>> <<parameter>>, and the other is a <<constant>> <<output>> or <<calculatedParameter>>, then the importing tool could also propagate the <<parameter>> value without presenting a parameter to the user._
_One example of use would be the name of a substance flowing through a pipe._
_If the fluid flows from one pipe FMU to another, the substance should be the same._
_This substance name could be propagated over several FMUs._

_Finally the `variableKind` `signal` can be applied to implement compatibility checks._
_If for example the <<variability>> of the variables in connected terminals are <<constant>>, then the importing tool can implement an equality assertion._
_This is also possible with <<calculated>> <<parameter,`parameters`>>._
_One example of use would be the cross sectional flow area in pipes which is calculated from geometry parameters._
_A change in the cross sectional flow area is relevant for the momentum equation, and therefore the connection has to be deemed incompatible if these variables are present and unequal.]_

===== General remark on inflow and outflow

_[Flow variables have a direction and must fulfill a zero sum constraint i.e. the sum of all flow variables connected together must be zero (Kirchhoff's current law)._
_In addition because different tools might have different direction definitions both, `inflow` and `outflow` `variableKinds` are available._
_For variables with `inflow` a positive value means that the flow is inwards, and for `outflow` a positive value means that the flow is outwards._
_For the sake of simplicity in the following latexmath:[\dot{m}_i] denotes an inflowing quantity:_

latexmath:[0 = \sum{\dot{m}_i}]

_Connecting a single <<output>> `outflow` to a single <<input>> `inflow`, or vice versa automatically fulfills the flow constraint, while connecting two single signals of the same flow type requires a negation of the signal.]_

===== Terminal Stream Member Variable

The `TerminalStreamMemberVariable` is defined as:

image::images/fmi3Terminal_TerminalStreamMemberVariable_Schema.png[width=60%, pdfwidth=60%, align="center"]

This element is used for variables which fulfill the balance equation for transported quantities.
It is restricted to <<input>> and <<output>>, <<parameter>> and <<calculatedParameter>>.

The Stream concept is described in the appendix D.3 of the Modelica specification.
Only one terminal member variable with the `variableKind` `inflow` or `outflow` per terminal is allowed, if a TerminalStreamMemberVariable is present.
_[More sophisticated structures can be implemented using hierarchical terminals.]_

The attribute `inStreamVariableName` and `outStreamVariableName` are used to identify the `ModelVariables`.
If the referenced model variables are arrays, then the size of the `inStreamVariableName` and `outStreamVariableName` has to be equal.
A terminal may have more than one TerminalStreamMemberVariable.
The `inStreamMemberName` and `outStreamMemberName` describe the terminal member name for matching purposes, similar to the `memberName` attribute in the `TerminalMemberVariable`.

_[An example of use for an array of stream variables is a gas mixture flow._
_The gas composition could be implemented as a mass fraction vector._
_The `outStreamVariableName` refers to_ latexmath:[portA.q_\textit{outStream}\textit{[\]}] _and the `inStreamVariableName` refers to_  latexmath:[portA.q_\textit{inStream}\textit{[\]}] _._
_The `inStreamMemberName` and `outStreamMemberName` are "_ latexmath:[q_\textit{inStream}\textit{[\]}] _" and "_ latexmath:[q_\textit{outStream}\textit{[\]}] _"._

_Balance equation for transported quantities:_

_latexmath:[0 = \sum{q_i\dot{m}_i}]_

_latexmath:[0 = \sum{\dot{m}_i}\cdot
\left\{\begin{array}{ll}
q_{\textit{$i$, outStream}} &\textit{if $\dot{m}$ is outflowing through terminal $i$}\\
q_{\textit{$i$, inStream}} &\textit{if $\dot{m}$ is inflowing through terminal $i$}
\end{array}\right.]_

_The_ latexmath:[q_\textit{$i$, outStream}] _is the convective quantity in case the matter flows out of the FMU._
latexmath:[q_\textit{$i$, inStream}] _is the convective quantity in case the matter flows into the FMU. Both variables are present in the terminal._
_The outStream variable has the <<causality>> <<output>> or <<calculatedParameter>> because this information has to be provided by each FMU._
_The inStream variable has the <<causality>> <<input>> or <<parameter>>._
_To display the actual value in an importing tool, this actual value has to be selected depending on the sign of the terminal member variable with `variableKind` `inflow` or `outflow`._
_However, calculating the actual value is not necessary._

_If only two terminals with a variable are connected and their <<causality>> matches, then the values of the outStream variables can be forwarded to the corresponding inStream values._

_In Modelica the inStream variable is not directly visible, the value can only be accessed using "inStream()", therefore an additional ModelVariable has to be added during the export._
_It is suggested that Modelica tools exporting an FMU derive the member name for the inStream variable according to the scheme "<outStream name>_inStream"._
_E.g. if the outStream name is "h_outflow" then the inStream name should be "h_outflow_inStream".]_

==== Definition of a Graphical Representation (GraphicalRepresentation)

===== Rationale

The graphical representation of the FMU and terminals are needed in order to more easily comprehend the meaning of connected FMUs and to help an importing tool to display the terminals and the FMU icon in the way the exporter intended.

The graphical representation is fully optional.
The graphical representation of terminals is separate from the terminal definitions in the `Terminals` element.

There are three optional elements in the `GraphicalRepresentation`:

. The `CoordinateSystem` defines the extent of the whole icon (graphical items may exceed that rectangle).
. The `Icon` defines an image source for the FMU.
. The `Terminal` sequence contains the graphical representation of the visible terminals.

image::images/fmiModelDescription_GraphicalRepresentation_Schema.png[width=60%, pdfwidth=60%, align="center"]

===== CoordinateSystem

image::images/fmiModelDescription_GraphicalRepresentation_CoordinateSystem_Schema.png[width=60%, pdfwidth=60%, align="center"]

The `CoordinateSystem` element and its defined extent is used as reference for other graphical items. It also provides a scaling factor to millimeter.

The coordinate system is defined by the coordinates of two points, the left lower (`x1`, `y1`) corner and the right upper (`x2`, `y2`) corner, where the coordinates of the first point shall be less than the coordinates of the second point _[a first quadrant coordinate system]_.
The x-axis directed to the right, the y-axis is directed upwards.

_[The exporting tool should define how the coordinate system unit relates to mm display or print out size._
_However, an importing tool might choose to use the factor from the default coordinate system extent to the actual coordinate system extent to calculate a scaling factor, to match the default icon size in the importing tool._

_The area defined by the coordinate system suggested to be used as "clickable icon size" in other tools._
_A `Terminal` might be placed outside of this area, so the visible bounding box has to be determined by the importing tool.]_

The coordinate system default is `x1=-100, y1=-100, x2=100, y2=100`. This extent is used if the `CoordinateSystem` element is missing.
The default `suggestedScalingFactorTo_mm` is 0.1.
So the default coordinate system display size should be 20 mm width and 20 mm height.

The FMU icon and all graphical representations provide the position and extent with the attributes `x1`, `y1`, `x2`, `y2`.
The values of these attributes directly relate to this coordinate system and are not normalized.
Flipping of the FMU icon or a terminal can be realized by setting its attributes `x2 < x1` or `y2 < y1` without changing the coordinate system.

===== Icon

image::images/fmiModelDescription_GraphicalRepresentation_Icon_Schema.png[width=30%, pdfwidth=30%, align="center"]

In the `Icon` element the FMU icon without terminals is defined, its extent and position.

The `iconSource_PNG` attribute is mandatory to simplify the import in other tools, so a PNG file has to be provided in any case.
Optionally an SVG file can be provided.
This enables high quality rendering and printing in importing tools.

===== Terminals

image::images/fmiModelDescription_GraphicalRepresentation_Terminal_Schema.png[width=50%, pdfwidth=50%, align="center"]

For `fmi3Terminals` (terminals which are listed in the `Terminals` element) the name of the terminal in the `GraphicalRepresentation` is equal to the name of the terminal in the `Terminals` element (e.g. `port_a`).
_[If the graphical representation is used for an <<input>> or <<output>> (e.g. a Real <<input>> `u`), then a `Terminal` has to be added to the `Terminals` element which has one `TerminalMemberVariable`._
_The name of the `Terminal` and the name of the `TerminalMemberVariable` should be equal to the name of the <<input>> / <<output>>.]_

The `iconSource_PNG` is mandatory for a terminal, optionally an SVG file can be provided.
The default connection stroke size and color can be provided, to define the intended connection line layout in the importing tool. The stroke size is given relative to the coordinate system extent.
The stroke color is given in RGB values from 0 to 255. E.g.: `255 255 0`.

The VendorAnnotations element can be used by vendors to store additional information for the graphical representation.
_[It is suggested that Modelica tools store the Modelica annotation of the connector under the tool name `Modelica3Annotation` in the attribute `annotation` of an element `connector`._
_The attribute `name` of the connector element is equal to the `name` attribute of the referenced `fmi3Terminal`.]_

_[Only terminals from the `Terminals` element can have a graphical representation._
_For simple <<input,`inputs`>> / <<output,`outputs`>> a terminal with one member has to be added.]_

===== Placement, Extent, and Painting Order of Graphical Items

image::images/GraphicalRepresentation.svg[width=70%, pdfwidth=70%, align="center"]

The clickable icon size is defined by the CoordinateSystem element.
The FMU icon itself may exceed this extent (or bounding box).
The bounding box of the terminals is given by the extent in the terminals element.
Their location is neither limited to the extent of the icon nor the extent of the coordinate system.
_[An importing tool has to determine the outer bounding box enclosing all graphical items.]_

Transparent SVG or PNG files are allowed and wanted. The order of the elements in the XML file defines the order of painting.
The first element in the GraphicalRepresentation is painted first and therefore behind the others, the last element is painted on top of the others and because of that in front of them.
_[So the FMU icon should be placed first in the XML file, terminal below.]_

==== Definition of Vendor Annotations (VendorAnnotations)

Element `VendorAnnotations` of `fmiModelDescription` is defined as:

image::images/VendorAnnotations_schema.png[width=80%, align="center"]

`VendorAnnotations` consist of an ordered set of annotations that are identified by the name of the tool that can interpret the `any` element.
The `any` element can be an arbitrary XML data structure defined by the tool.
Attribute `name` must be unique with respect to all other elements of the `VendorAnnotation` list.

==== Definition of Model Variables (ModelVariables) [[definition-of-model-variables]]

The `ModelVariables` element of `fmiModelDescription` is the central part of the model description.
It provides the static information of all exposed variables and is defined as:

image::images/ModelVariables_schema.png[width=100%, align="center"]

The `ModelVariables` element consists of an ordered set of `Variable` elements (see figure above).
`Variable` elements can uniformly represent variables of primitive (atomic) types, like single real or integer variables, or as well as arrays of an arbitrary (but fixed) number of dimensions. The schema definition is present in a separate file `fmi3Variable.xsd`.

`Variable` elements representing array variables must contain a `Dimensions` element specifying the array dimensions.
The `Dimensions` element contains a sequence of `Dimension` elements, each specifying the size of one dimension of the array:

- If the `<<start>> attribute of the `Dimension` element is present, it defines a constant size for this dimension, namely the integer value of the <<start>> attribute.
The <<variability>> of the dimension size is <<constant>> in this case.

- If the <<valueReference>> attribute of the `Dimension` element is present, it defines the size of this dimension to be the value of the `Variable` with the value reference given by the <<valueReference>> attribute.
The referenced variable must be a variable of integer type, and must either be a constant (i.e. with <<variability>> = <<constant>>) or a <<structuralParameter,`structural parameter`>>(i.e. with <<causality>> = <<structuralParameter>>).
The <<variability>> of the dimension size is in this case the <<variability>> of the referenced variable.

These two options are mutually exclusive, i.e. for each `Dimension` element either a <<start>> attribute or an <<valueReference>> attribute can be supplied, but not both.
However different dimension sizes can be specified using different mechanisms and can have differing <<variability>> attributes.

All initial dimension sizes (i.e. prior to any configuration or reconfiguration) must be positive integers (i.e. not zero), so that no dimension is initially vanished.
Changes to dimension sizes are constrained by the `min`/`max` attributes of the referenced <<structuralParameter,`structural parameters`>>, which can be any non-negative integer, including zero.
Specifying a minimum size of zero on a <<structuralParameter,`structural parameter`>>allows any related dimension sizes to be changed to zero in *Configuration Mode* or *Reconfiguration Mode*, thus causing the respective array size to go to zero, which leaves the respective array variable without any active elements.

Changing any dimension of a variable in *Configuration Mode* or *Reconfiguration Mode* invalidates the variable's current value (including its <<start>> value).
It should be noted that changing a <<structuralParameter,`structural parameter`>>might might affect dimension sizes of several variables.

It is not possible to use a variable of type `Clock` in arrays, since array elements do not have individual <<valueReference>> and the access to <<clock,`clocks`>> requires a unique <<valueReference>> information.

The attributes of `Variable` are:

image::images/ScalarVariable_schema.png[width=90%, align="center"]

[cols="1,5a",options="header"]
|====
|_Attribute-Name_
|_Description_

|`name`
|The full, unique name of the variable.
Every variable is uniquely identified within an FMU instance by this name.

|`valueReference`
|
[[valueReference,`valueReference`]]
A handle of the variable to efficiently identify the variable value in the model interface and for references within the `modelDescription.xml`.
This handle is a secret of the tool that generated the C functions.
It is required to be unique for an FMU with exception of variables that have identical values (such variables are also called alias variables). `Clock` type variables do not have alias variables and are therefore unique.
This attribute is `required`.

|`description`
|An optional description string describing the meaning of the variable.

|`causality`
|
[[causality,`causality`]]
Enumeration that defines the causality of the variable.
Allowed values of this enumeration:

[[parameter,`parameter`]]
- `parameter`: <<independent>> parameter (a data value that is constant during the simulation and is provided by the environment and cannot be used in connections).
<<variability>> must be <<fixed>> or <<tunable>>.
<<initial>> must be <<exact>> or not present (meaning <<exact>>).

[[calculatedParameter,`calculatedParameter`]]
- `calculatedParameter`: A data value that is constant during the simulation and is computed during initialization or when <<tunable>> <<parameter,`parameters`>> change.
<<variability>> must be <<fixed>> or <<tunable>>.
<<initial>> must be <<approx>>, <<calculated>> or not present (meaning <<calculated>>).

[[input,`input`]]
- `input`: The variable value can be provided from another model or slave.
It is not allowed to define <<initial>>.

[[output,`output`]]
- `output`: The variable value can be used by another model or slave.
The algebraic relationship to the <<input,`inputs`>> is defined via the <<dependencies>> attribute of `<fmiModelDescription><ModelStructure><Outputs><Unknown>`.

[[local,`local`]]
- `local`: Local variable that is calculated from other variables or is a continuous-time <<state>> (see <<ModelStructure>>).
It is not allowed to use the variable value in another model or slave.

[[independent,`independent`]]
- `independent`: The independent variable (usually `time`).
All variables are a function of this <<independent>> variable.
<<variability>> must be <<continuous>>.
At most one `Variable` of an FMU can be defined as <<independent>>.
If no variable is defined as <<independent>>, it is implicitly present with name = `time` and `unit = s`.
If one variable is defined as <<independent>>, it must be defined as `Real` without a <<start>> attribute.
It is not allowed to call function `fmi3SetReal` on an <<independent>> variable.
Instead, its value is initialized with <<fmi3SetupExperiment>> and after initialization set by <<fmi3SetTime>> for Model Exchange and by arguments `currentCommunicationPoint` and `communicationStepSize` of <<fmi3DoStep>> for Co-Simulation.
_[The actual value can be inquired with `fmi3GetReal`.]_

[[structuralParameter,`structuralParameter`]]
- <<structuralParameter>>: <<independent>> parameter (a data value that is constant during the simulation and is provided by the environment and cannot be used in connections). <<variability>> must be <<fixed>> or <<tunable>>. <<initial>> must be <<exact>> or not present (meaning <<exact>>).
This <<causality>> requires the `Variable` not to have a `Dimension` element.

_[_
_Example:_

// TODO: include example from XML
[source, XML]
----
<Variable name="spD" valueReference="126" causality="structuralParameter" variability="fixed">
  <Integer start="3"/>
</Variable>
----

_]_

<<structuralParameter,`structural parameters`>> that are referenced in `Dimension` elements may have a `min` attribute with 0 but the <<start>> attribute, which is mandatory for <<structuralParameter,`structural parameters`>>, must have a value larger than 0 for <<structuralParameter,`structural parameters`>> used in `Dimension` elements. [This allows importing tools to ignore <<structuralParameter,`structural parameters`>> because that <<start>> value reflects the internal default setting of that <<structuralParameter,`structural parameter`>>].

[[inputClock,`input clock`]]
- `input`: the variable defines an <<inputClock>> that is controlled by the master.
Variability must be <<clock>>.
Only a variable of type `Clock` can have this <<causality>>.

[[outputClock,`output clock`]]
- `output`: the variable defines an <<outputClock>> that is controlled by the FMU.
Variability must be <<clock>>.
Only a variable of type `Clock` can have this <<causality>>.

The default of <<causality>> is <<local>>. +
A continuous-time <<state>> must have <<causality>> = <<local>> or <<output>>, see also <<ModelStructure>>.

_[<<causality>> = <<calculatedParameter>> and <<causality>> = <<local>> with <<variability>> = <<fixed>> or <<tunable>> are similar._
_The difference is that a <<calculatedParameter>> can be used in another model or slave, whereas a <<local>> variable cannot._
_For example, when importing an FMU in a Modelica environment, a <<calculatedParameter>> should be imported in a `public` section as `final parameter`, whereas a <<local>> variable should be imported in a `protected` section of the model.]_

|`variability`
|
[[variability,`variability`]]
Enumeration that defines the time dependency of the variable, in other words, it defines the time instants when a variable can change its value.
_[The purpose of this attribute is to define when a result value needs to be inquired and to be stored._
_For example, <<discrete>> variables change their values only at event instants (Model Exchange) or at a communication point (Co-Simulation) and it is therefore only necessary to inquire them with `fmi3GetXXX` and store them at event times.]_
Allowed values of this enumeration:

[[constant,`constant`]]
- `constant`: The value of the variable never changes.

[[fixed,`fixed`]]
- `fixed`: The value of the variable is fixed after initialization, in other words, after <<fmi3ExitInitializationMode>> was called the variable value does not change anymore.

[[tunable,`tunable`]]
- `tunable`: The value of the variable is constant between external events (Model Exchange) and between communication points (Co-Simulation) due to changing variables with <<causality>> = <<parameter>> or <<input>> and <<variability>> = <<tunable>>.
Whenever a <<parameter>> or <<input>> signal with <<variability>> = <<tunable>> changes, an event is triggered externally (Model Exchange), or the change is performed at the next communication point (Co-Simulation) and the variables with <<variability>> = <<tunable>> and <<causality>> = <<calculatedParameter>> or <<output>> must be newly computed.

[[discrete,`discrete`]]
- `discrete`: +
Model Exchange: The value of the variable is constant between external and internal events (= time, state, step events defined implicitly in the FMU). +
Co-Simulation: By convention, the variable is from a real sampled data system and its value is only changed at communication points (also inside the slave).

[[continuous,`continuous`]]
- `continuous`: Only a variable of `type = Real` can be <<continuous>>. +
Model Exchange: No restrictions on value changes. +
Co-Simulation: By convention, the variable is from a differential

[[clock,`clock`]]
- `clock`: Only a variable of type `Clock` can have this variablity.

The default is <<continuous>> for variables of type `Float32` and `Float64`, and <<discrete>> for all other types.

_[Note that the information about continuous <<state,`states`>> is defined with element `fmiModelDescription.ModelStructure.Derivatives`.]_

|`initial`
|
[[initial,`initial`]]
Enumeration that defines how the variable is initialized.
It is not allowed to provide a value for <<initial>> if <<causality>> = <<input>> or <<independent>>:

[[exact,`exact`]]
- = `exact`: The variable is initialized with the <<start>> value (provided under `Real`, `Integer`, `Boolean`, `String` or `Enumeration`).

[[approx,`approx`]]
- = `approx`: The variable is an iteration variable of an algebraic loop and the iteration at initialization starts with the <<start>> value.

[[calculated,`calculated`]]
- = `calculated`: The variable is calculated from other variables during initialization.
It is not allowed to provide a <<start>> value.

If <<initial>> is not present, it is defined by the table below based on <<causality>> and <<variability>>.
If <<initial>> = <<exact>> or <<approx>>, or <<causality>> = <<input>>, a <<start>> value must be provided.
If <<initial>> = <<calculated>>, or <<causality>> = <<independent>>, it is not allowed to provide a <<start>> value.

_[The environment decides when to use the <<start>> value of a variable with <<causality>> = <<input>>.
Examples: (a) automatic tests of FMUs are performed, and the FMU is tested by providing the <<start>> value as <<constant>> <<input>>.
(b) For a Model Exchange FMU, the FMU might be part of an algebraic loop.
If the <<input>> variable is iteration variable of this algebraic loop, then initialization starts with its <<start>> value.]_

If <<causality>> = <<input>> the value for <<initial>> has to be set to <<exact>> and it is required to provide a <<start>> value for describing the expected initial contidion of master <<clock,`clocks`>> for that FMU.
If an <<inputClock>> has `fmi3True` as an <<start>> value the master should activate the <<clock>> the first time it enters event mode.
The master can nevertheless choose different <<start>> values if it is not possible to fulfill the conditions in a simulation setup.

If <<causality>> = <<output>> the <<initial>> attribute value is set to <<calculated>> and no <<start>> value is provided.

If `fmi3SetXXX` is not called on a variable with <<causality>> = <<input>>, then the FMU must use the <<start>> value as value of this <<input>>.

|`canHandleMultipleSetPerTimeInstant`
|
[[canHandleMultipleSetPerTimeInstant,`canHandleMultipleSetPerTimeInstant`]]
Only for Model Exchange (if only Co-Simulation FMU, this attribute must not be present.
If both Model Exchange and Co-Simulation FMU, this attribute is ignored for Co-Simulation): +
Only for variables with <<variability>> = <<input>> : +
If present with value equals `false`, then only one `fmi3SetXXX` call is allowed at one super dense time instant (model evaluation) on this variable.
That is, this <<input>> is not allowed to appear in a (real) algebraic loop requiring multiple calls of `fmi3SetXXX` on this variable _[for example, due to a Newton iteration]_. +
_[This flag must be set by FMUs where (internal) discrete-time <<state,`states`>> are directly updated when assigned (xd := f(xd) instead of xd = f(previous(xd)), and at least one <<output>> depends on this <<input>> and on discrete <<state,`states`>>._ +
_It is strongly recommended that such an FMU checks the fulfillment of the requirement by itself during run-time, because an environment might not be able to check it; usually, there is a generic mechanism to import an FMU in an environment, but the mechanism to connect FMUs together is unrelated to the import mechanism._
_For example, there is no mechanism in the Modelica language to formulate connection restrictions for C functions (the FMU) called in a Modelica model.]_


|`clockReference`
|
[[clockReference,`clockReference`]]
The optional attribute <<clockReference>> is used to define the <<clock,`clocks`>> this variable is assigned to.
This attribute can be used in all variable sub types with restrictions based on the `clockType`  attribute.
The <<clockReference>> holds only <<valueReference>> information for variables with base type `fmi3Clock`.

Clock (`clockType = STClock`): If present, the variable is a clocked variable associated uniquely with the <<clock>> referenced by <<valueReference>> and defined in element ModelVariables.
It is not possible to associate more than one <<clock>> to a variable.

Communication Point Clock (`clockType = CPClock`): If present, the variable is associated with the <<clock>> referenced by <<valueReference>> and defined in element `ModelVariables`.
It is possible to associate multiple <<clock,`clocks`>> to a variable.
Variables that are assigned to a Communication Point Clock are not necessarily `clocked` in the sense of synchronous time clock theory. Such variables can also be continuous-time or discrete-time variables.

If <<outputClock,`output clocks`>> and <<inputClock,`input clocks`>> of `clockType = CPClock` are defined in the `modelDescription.xml` it is possible to define a tick relationship from a <<outputClock>> to an aperiodic <<inputClock>> based on <<clockReference>> (<<clock-relationships-for-communication-point-clocks>>).
This is done for aperiodic <<inputClock,`input clocks`>> that have the clockType = `CPClock` via providing a list of <<valueReference>> of <<outputClock,`output clocks`>> of the same FMU.
If a <<outputClock>> of this <<valueReference>> list ticks the master has to create a tick for the associated aperiodic <<inputClock>> at the same time instant.
It is not allowed to combine <<outputClock,`output clocks`>> with periodic or strict periodic <<inputClock,`input clocks`>> based on <<clockReference>>.

The attribute <<clockReference>> must not be used if <<causality>> = <<output>> for a variable.

|`previous`
|
[[previous,`previous`]]
If present, this variable is a discrete-time <<state>> `xd`.
The value of `xd` at the previous super-dense time instant is stored in the variable with <<valueReference>> <<previous>>.
The <<previous>> variable must have <<initial>> = <<exact>> and a <<start>> value defined.
_[For example, if there are 10 Variables and <<previous>> equals 3 for Variable 8, then at a super-dense time instant Variable 8 holds the value of this discrete <<state>> at the actual time instant and Variable 3 holds the value of this <<state>> from the previous super-dense time instant.]_

|`intermediateAccess`
|
[[intermediateAccess,`intermediateAccess`]]
If this boolean attribute is `true`, the variable can be accessed during a communication step.
Variables with <<causality>> <<parameter>> must not be marked with <<intermediateAccess>> = `true`.
// TODO: link to see math-intermediate-variable-access)
This attribute is only used for Co-Simulation. The default value of this attribute is `false`.
// TODO: default false is not defined in the xsd (yet?)
|====

*fmi3SetXXX* can be called on any variable with <<variability>> &#8800; <<constant>> *before initialization* (before calling <<fmi3EnterInitializationMode>>)

- if <<initial>> = <<exact>> or <<approx>> _[in order to set the corresponding <<start>> value.]_

*fmi3SetXXX* can be called on any variable with <<variability>> &#8800; <<constant>> *during initialization* (after calling <<fmi3EnterInitializationMode>> and before <<fmi3ExitInitializationMode>> is called)

- if <<initial>> = <<exact>> _[in order to set the corresponding <<start>> value]_, or

- if <<causality>> = <<input>> _[in order to provide new values for <<input,`inputs`>>]_,

*fmi3SetXXX* can be called on any variable for *Model Exchange at an event instant* (after calling <<fmi3EnterEventMode>> and before <<fmi3EnterContinuousTimeMode>> is called), and *for Co-Simulation at every communication point*,

- if <<causality>> = <<parameter>> and <<variability>> = <<tunable>> _[in order to change the value of the <<tunable>> <<parameter>> at an event instant or at a communication point]_, or

- if <<causality>> = <<input>> _[in order to provide new values for <<input,`inputs`>>]_

*fmi3SetXXX* can be called on any variable for *Model Exchange in Continuous-Time Mode*

- if <<causality>> = <<input>> and <<variability>> = <<continuous>> +
_[in order to provide new values for <<input,`inputs`>> during continuous integration]_

If <<initial>> is not present, its value is defined by the following tables based on the values of <<causality>> and <<variability>>:

// TODO: <<previous>> variable must have <<initial>> = <<exact>>
// TODO: include <<previous>> attribute information in table or below table

[cols="1,1,1,1,1,1,1,1,1,1,1,1"]
|====
3.2+|
9+^|<<causality>>
^|*structual* <<parameter>>
^|<<parameter>>
^|<<calculated>> <<parameter>>
^|<<input>>
^|<<output>>
^|<<local>>
^|<<independent>>
^|<<input>>
^|<<output>>

.7+^|<<variability>>
.3+^|data
^|<<constant>>
^|[green]#(A) or --#
^|[red]#--#
^|[red]#--#
^|[red]#--#
^|[green]#(A)#
^|[green]#(A)#
^|[red]#--#
^|[red]#--#
^|[red]#--#

^|<<fixed>>
^|[green]#(A)#
^|[green]#(A)#
^|[maroon]#(B)#
^|[red]#--#
^|[red]#--#
^|[maroon]#(B)#
^|[red]#--#
^|[red]#--#
^|[red]#--#

^|<<tunable>>
^|[green]#(A)#
^|[green]#(A)#
^|[maroon]#(B)#
^|[red]#--#
^|[red]#--#
^|[maroon]#(B)#
^|[red]#--#
^|[red]#--#
^|[red]#--#

.2+^|signals
^|<<discrete>>
^|[red]#--#
^|[red]#--#
^|[red]#--#
^|[aqua]#(D)#
^|\(C)
^|\(C)
^|[red]#--#
^|[red]#--#
^|[red]#--#

^|<<continuous>>
^|[red]#--#
^|[red]#--#
^|[red]#--#
^|[aqua]#(D)#
^|\(C)
^|\(C)
^|[purple]#(E)#
^|[red]#--#
^|[red]#--#

1+^|<<clock,`clocks`>>
^|<<clock>>
^|[red]#--#
^|[red]#--#
^|[red]#--#
^|[red]#--#
^|[red]#--#
^|[red]#--#
^|[red]#--#
^|[brown]#(F)#
^|[brown]#(G)#
|====

with

[cols="1,3,3", width=50%, align="center"]
|====
|
2+^|<<initial>>
|
^|*default*
^|*possible values*

|[green]#(A)#
|[green]#exact#
|[green]#exact#

|[maroon]#(B)#
|[maroon]#calculated#
|[maroon]#approx,# +
 [maroon]#calculated#

|\(C)
|<<calculated>>
|<<exact>>, +
<<approx>>, +
<<calculated>>

|[aqua]#(D)#
|[aqua]#---#
|[aqua]#---#

|[purple]#(E)#
|[purple]#---#
|[purple]#---#

|[brown]#(F)#
|[brown]#exact#
|[brown]#exact#

|[brown]#(G)#
|[brown]#calculated#
|[brown]#calculated#
|====

_[Note: (1) If <<causality>> = <<independent>>, it is neither allowed to define a value for <<initial>> nor a value for start._
_(2) If <<causality>> = <<input>>, it is not allowed to define a value for <<initial>> and a value for <<start>> must be defined._
_(3) If \(C) and <<initial>> = <<exact>>, then the variable is explicitly defined by its <<start>> value in Initialization Mode (so directly after calling <<fmi3ExitInitializationMode>>, the value of the variable is either the <<start>> value stored in element `<Variable><XXX start=YYY/>` or the value provided by `fmi3SetXXX`, if this function was called on this variable).]_

The following combinations of <<variability>>/<<causality>> settings are allowed:

[cols="1,1,1,1,1,1,1,1,1,1,1,1"]
|====
3.2+|
9+^|<<causality>>
^|*structural* <<parameter>>
^|<<parameter>>
^|<<calculated>> <<parameter>>
^|<<input>>
^|<<output>>
^|<<local>>
^|<<independent>>
^|<<input>>
^|<<output>>

.6+^|<<variability>>
.3+^|data
^|<<constant>>
^|[red]#--#
^|[red]#-- (a)#
^|[red]#-- (a)#
^|[red]#-- (a)#
^|[green]#(7)#
^|[green]#(10)#
^|[red]#-- (c)#
^|[red]#--#
^|[red]#--#

^|<<fixed>>
^|[green]#(16)#
^|[green]#(1)#
^|[green]#(3)#
^|[red]#-- (d)#
^|[red]#-- (e)#
^|[green]#(11)#
^|[red]#-- (c)#
^|[red]#--#
^|[red]#--#

^|<<tunable>>
^|[green]#(17)#
^|[green]#(2)#
^|[green]#(4)#
^|[red]#-- (d)#
^|[red]#-- (e)#
^|[green]#(12)#
^|[red]#-- (c)#
^|[red]#--#
^|[red]#--#

.2+^|signals
^|<<discrete>>
^|[red]#-- (b)#
^|[red]#-- (b)#
^|[red]#-- (b)#
^|[green]#(5)#
^|[green]#(8)#
^|[green]#(13)#
^|[red]#--(c)#
^|[red]#--#
^|[red]#--#

^|<<continuous>>
^|[red]#-- (b)#
^|[red]#-- (b)#
^|[red]#-- (b)#
^|[green]#(6)#
^|[green]#(9)#
^|[green]#(14)#
^|[green]#(15)#
^|[red]#--#
^|[red]#--#

.1+^|clocks
^|<<clock>>
^|[red]#--#
^|[red]#--#
^|[red]#--#
^|[red]#--#
^|[red]#--#
^|[red]#--#
^|[red]#--#
^|[red]#18#
^|[red]#18#
|====

_[Discussion of the combinations that are not allowed:_

[cols="1,10"]
|====
|
|_Explanation why this combination is not allowed_

^|_[red]#(a)#_
|_The combinations <<constant>> / <<parameter>>, <<constant>> / <<calculatedParameter>> and <<constant>> / <<input>> do not make sense, since <<parameter,`parameters`>> and <<input,`inputs`>> are set from the environment, whereas a constant has always a value._

^|_[red]#(b)#_
|_The combinations <<discrete>> / <<structuralParameter>>, <<discrete>> / <<parameter>>, <<discrete>> / <<calculatedParameter>> , <<continuous>> / <<structuralParameter>>, <<continuous>> / <<parameter>> and <<continuous>> / <<calculatedParameter>> do not make sense, since <<causality>> = <<structuralParameter>>, <<causality>> = <<parameter>> and <<calculatedParameter>> define variables that do not depend on time, whereas <<discrete>> and <<continuous>> define variables where the values can change during simulation._

^|_[red]#(c)#_
|_For an <<independent>> variable only <<variability>> = <<continuous>> makes sense._

^|_[red]#(d)#_
|_A <<fixed>> or <<tunable>> <<input>> has exactly the same properties as a <<fixed>> or <<tunable>> <<parameter>>._
_For simplicity, only <<fixed>> and <<tunable>> <<parameter,`parameters`>> shall be defined._

^|_[red]#(e)#_
|_A <<fixed>> or <<tunable>> <<output>> has exactly the same properties as a <<fixed>> or <<tunable>> <<calculatedParameter>>._
_For simplicity, only <<fixed>> and <<tunable>> <<calculatedParameter,`calculatedParameters`>> shall be defined._
|====

_Discussion of the combinations that are allowed_:

[cols="1,3,8", options="header"]
|====
|
|_Setting_
|_Example_

>|_[green]#(1)#_
|_<<fixed>> <<parameter>>_
|_Non-<<tunable>> <<independent>> <<parameter>>_

>|_[green]#(2)#_
|_<<tunable>> <<parameter>>_
|_<<tunable,`Tunable`>> <<independent>> <<parameter>> (changing such a <<parameter>> triggers an external event (Model Exchange) or takes effect at the next communication point (Co-Simulation), and <<tunable>> <<calculatedParameter>>/<<output>>/<<local>> variables might change their values)._

>|_[green]#(3)#_
|_<<fixed>> <<dependenciesKind,`dependent`>> <<parameter>>_
|_Non-<<tunable>> <<dependenciesKind,`dependent`>> <<parameter>> (variable that is computed directly or indirectly from constants or <<parameter,`parameters`>>)._

>|_[green]#(4)#_
|_<<tunable>> <<dependenciesKind,`dependent`>> <<parameter>>_
|_<<tunable,`Tunable`>> <<dependenciesKind,`dependent`>> <<parameter>> (changing an <<independent>> <<parameter>> triggers an external event (Model Exchange) or takes effect at the next communication point (Co-Simulation), and <<tunable>> <<dependenciesKind,`dependent`>> <<parameter,`parameters`>> and <<tunable>> <<local>> variables might change their values)._

>|_[green]#(5)#_
|_<<discrete>> <<input>>_
|_<<discrete,`Discrete`>> <<input>> variable from another model._

>|_[green]#(6)#_
|_<<continuous>> <<input>>_
|_<<continuous,`Continuous`>> <<input>> variable from another model._

>|_[green]#(7)#_
|_<<constant>> <<output>>_
|_Variable where the value never changes and that can be used in another model._

>|_[green]#(8)#_
|_<<discrete>> <<output>>_
|_<<discrete,`Discrete`>> variable that is computed in the FMU._
_Can be used in another model._

>|_[green]#(9)#_
|_<<continuous>> <<output>>_
|_<<continuous,`Continuous`>> variable that is computed in the FMU and can be used in another model._

>|_[green]#(10)#_
|_<<constant>> <<local>>_
|_Variable where the value never changes._
_Cannot be used in another model._

>|_[green]#(11)#_
|_<<fixed>> <<local>>_
|_Local variable that depends on <<fixed>> <<parameter,`parameters`>> only and is computed in the FMU._
_Cannot be used in another model._
_After initialization, the value of this <<local>> variable cannot change._

>|_[green]#(12)#_
|_<<tunable>> <<local>>_
|_Local variable that depends on <<tunable>> <<parameter,`parameters`>> only and is computed in the FMU._
_Cannot be used in another model._
_The value of this <<local>> variable can only change during initialization and at event instants, provided a <<tunable>> <<parameter>> was changed._

>|_[green]#(13)#_
|_<<discrete>> <<local>>_
|_<<discrete,`Discrete`>> variable that is computed in the FMU and cannot be used in another model._

>|_[green]#(14)#_
|_<<continuous>> <<local>>_
|_<<continuous,`Continous`>> variable that is computed in the FMU and cannot be used in another model._

>|_[green]#(15)#_
|_<<continuous>> <<independent>>_
|_All variables are a function of the continuous-time variable marked as <<independent>>._
_Usually, this is `time`_

>|_[green]#(16)#_
|_<<fixed>> structual <<parameter>>_
|_<<parameter,`Paramter`>> used in  `Dimension` element;  can be changed before initialization in *Configuration Mode* state_

>|_[green]#(17)#_
|_<<tunable>> structual <<parameter>>_
|_<<parameter,`Parameter`>> used in  `Dimension` element;  can be changed before initialization in *Configuration Mode* and in in *Reconfiguration Mode* state_

>|_[green]#(18)#_
|_<<clock>>_
|_Variable that defines a <<clock>>_
|====

_How to treat <<tunable>> variables:_

_A <<parameter>> p is a variable that does not change its value during simulation, in other words, dp/dt = 0._
_If the <<parameter>> p is changing, then Dirac impulses are introduced since dp/dt of a discontinuous <<constant>> variable `p` is a Dirac impulse._
_Even if this Dirac impulse would be modeled correctly by the modeling environment, it would introduce unwanted `vibrations`._
_Furthermore, in many cases the model equations are derived under the assumption of a <<constant>> value (like mass or capacity), and the model equations would be different if `p` would be time varying._

_FMI for Model Exchange:_ +
_Therefore, "tuning a (structural) <<parameter>>" during simulation does not mean to "change the parameter online" during simulation._
_Instead, this is a short hand notation for:_

. _Stop the simulation at an event instant (usually, a step event, in other words, after a successful integration step)._

. _Change the values of the <<tunable>> (structural) <<parameter,`parameters`>>. For <<tunable>> <<structuralParameter,`structural parameters`>>, the *Reconfiguration Mode* state must be entered before and left afterwards._

. _Compute all <<parameter,`parameters`>> (and sizes of variables, <<state,`states`>>, <<derivative,`derivatives`>>, event indicators, ...) that depend on the <<tunable>> (structural) <<parameter,`parameters`>>._

. _Newly start the simulation using as initial values the current values of all <<previous>> variables and the new values of the <<parameter,`parameters`>>._

_Basically this means that a new simulation run is started from the previous FMU state with changed <<parameter>> values._
_With this interpretation, changing <<parameter,`parameters`>> online is "clean", as long as these changes appear at an event instant._

_FMI for Co-Simulation:_
_Changing of <<tunable>> <<parameter,`parameters`>> is allowed before an <<fmi3DoStep>> call (so, whenever an <<input>> can be set with `fmi3SetXXX`) and before <<fmi3ExitInitializationMode>> is called (that is before and during Initialization Mode)._
_The FMU internally carries out event handling if necessary.]_

===== Aliasing of Variables [[aliasing-of-variables]]

Variables of the same base type (like `fmi3Real`) that have identical <<valueReference>> definitions are called alias variables.
The main purpose of alias variables is to enhance efficiency.
If two variables `a` and `b` are alias variables, then this is only allowed if the behavior of the FMU would be exactly the same if `a` and `b` were not treated as alias variables (that is, had different <<valueReference>>pass:[s]).
This requirement leads naturally to the following restrictions:

. Variables `a` and `b` that can both be set with `fmi3SetXXX`, or variable `a` that can be set with `fmi3SetXXX` and variable `b` that is defined with <<causality>> = <<independent>>, cannot be alias variables _[since these variables are <<independent>> variables and alias means that there is a constraint equation between variables (= the values are the same), these variables are no longer <<independent>>._ +
_For example, if variables `a` and `b` have <<causality>> = <<parameter>>, then the value references of `a` and `b` must be different._
_However, if variable a has <<causality>> = <<parameter>> and `b` has <<causality>> = <<calculatedParameter>> and `b := a`, then `a` and `b` can have the same value reference.]_

. At most one variable of the same alias set of variables with <<variability>> = <<constant>> can have a <<start>> attribute _[since <<start>> variables are independent initial values.]_

. A variable with <<variability>> = <<constant>> can only be aliased to another variable with <<variability>> = <<constant>>.
It is then required that the <<start>> values of all aliased (constant) variables are identical.

. All variables of the same alias set must all have either no `<Unit>` element defined, or all of them must have the same `<Unit name>` and the same `<Unit><BaseUnit>` definitions.

The aliasing of variables only means that the `value` of the variables is always identical.
However, aliased variables may have different attributes, such as `min/max/nominal` values or description texts.
_[For example, if v1, v2 are two alias variables with `v1=v2` and `v1.max=10` and `v2.max=5`, then the FMU will trigger an error if either `v1` or `v2` becomes larger than 5.]_

_[The dependency definition in `fmiModelDescription.ModelStructure` is completely unrelated to the alias definition._
_In particular, the "direct dependency" definition can be a superset of the "real" direct dependency definition, even if the alias information shows that this is too conservative._
_For example, if it is stated that the <<output>> `y1` depends on <<input>> `u1` and the <<output>> `y2` depends on <<input>> `u2`, and `y1` is an alias to `y2`, then this definition is fine, although it can be deduced that in reality neither `y1` nor `y2` depend on any <<input>>.]._

Type specific properties are defined in the required choice element, where exactly one of `Real`, `Integer`, `Boolean`, `String`, `Enumeration` must be present in the XML file:

image::images/Real_Schema_large.png[width=50%, align="center"]

image::images/Integer_Schema_large.png[width=50%, align="center"]

image::images/Boolean_Schema_large.png[width=50%, align="center"]

image::images/String_Schema_large.png[width=50%, align="center"]

image::images/Enumeration_Schema_large.png[width=50%, align="center"]

The attributes are defined in <<definition-of-types>> (`TypeDefinitions`), except:

[cols="1,7a", options="header"]
|====
|_Attribute-Name_
|_Description_

|`declaredType`
|If present, name of type defined with `TypeDefinitions / SimpleType`.
The value defined in the corresponding `TypeDefinition` (see <<definition-of-types>>) is used as default.
_[For example, if `min` is present both in `Real` (of `TypeDefinition`) and in `Real` (of `Variable`), then the `min` of `Variable` is actually used.]_
For `Real`, `Integer`, `Boolean`, `String`, this attribute is optional.
For `Enumeration` it is required, because the Enumeration items are defined in `TypeDefinitions / SimpleType`.


|`start`
|
[[start,`start`]]
Initial or guess value of variable.
*This value is also stored in the C functions*.
_[Therefore, calling_ `fmi3SetXXX` _to set <<start>> values is only necessary, if a different value as stored in the XML file is desired.]_ The interpretation of <<start>> is defined by `Variable` / <<initial>>.
A different <<start>> value can be provided with an `fmi3SetXXX` function before <<fmi3ExitInitializationMode>> is called (but not for variables with <<variability>> = <<constant>>).

_[The standard approach is to set the <<start>> value before <<fmi3EnterInitializationMode>>._
_However, if the initialization shall be modified in the calling environment (for example, changing from initialization of states to steady-state initialization), it is also possible to use the <<start>> value as iteration variable of an algebraic loop: using an additional condition in the environment, such as_ latexmath:[\color{blue}{\dot{x} = 0}] _, the actual <<start>> value is determined.]_

If <<initial>> = <<exact>> or <<approx>> or <<causality>> = <<input>>, a <<start>> value must be provided.

If <<initial>> = <<calculated>> or <<causality>> = <<independent>>, it is not allowed to provide a <<start>> value.

Variables with <<causality>> = <<parameter>> or <<input>>, as well as variables with <<variability>> = <<constant>>, must have a <<start>> value.

- If <<causality>> = <<parameter>>, the start-value is the value of it.

- If <<causality>> = <<input>>, the <<start>> value is used by the model as value of the <<input>>, if the <<input>> is not set by the environment.

- If <<variability>> = <<constant>>, the <<start>> value is the value of the constant.

- If <<causality>> = <<output>> or <<local>>, then the <<start>> value is either an <<initial>> or a `guess` value, depending on the setting of attribute <<initial>>.

|`derivative`
|
[[derivative,`derivative`]]
If present, this variable is the derivative of variable with `Variable` value reference `derivative`.
_[For example, if there are 10 `Variable`pass:[s] and `derivative = 3` for `Variable` 8, then `Variable` 8 is the derivative of `Variable` 3 with respect to the <<independent>> variable (usually time)._
_This information might be especially used if an <<input>> or an <<output>> is the derivative of another <<input>> or <<output>>, or to define the <<state,`states`>>.]_

The <<state>> <<derivative,`derivatives`>> of an FMU are listed under element `<ModelStructure><Derivatives>`.
All `Variable`pass:[s] listed in this element must have attribute `derivative` (in order that the continuous-time <<state,`states`>> are uniquely defined).

|`reinit`
|Only for Model Exchange (if only Co-Simulation FMU, this attribute must not be present.
If both Model Exchange and Co-Simulation FMU, this attribute is ignored for Co-Simulation): +
Can only be present for a continuous-time <<state>>. +
If `true`, <<state>> can be reinitialized at an event by the FMU. +
If `false`, <<state>> will not be reinitialized at an event by the FMU.

|`min / max`
|The optional attributes `min` and `max` in element `Enumeration` restrict the allowed values of the enumeration.
The `min/max` definitions are information from the FMU to the environment defining the region in which the FMU is designed to operate, see also comment in <<definition-of-types>>.
_[If, for example, an `Enumeration` is defined with `name1 = -4`, `name2 = 1`, `name3 = 5`, `name4 = 11` and min=-2, max = 5, then only `name2` and `name3` are allowed.]_
|====

With element `Annotations` additional, tool specific data can be defined:

image::images/Annotations_schema.png[width=80%]

With `Tool.name` the name of the tool is defined that can interpret the `any` element.
The `any` element can be an arbitrary XML data structure defined by the tool.
_[Typically, additional data is defined here how to build up the menu for the variable, including the graphical layout and enabling/disabling an input field based on the values of other <<parameter,`parameters`>>.]_

==== Definition of the Model Structure (ModelStructure) [[ModelStructure]]

The structure of the model is defined in element `ModelStructure` within `fmiModelDescription`.
This structure is with respect to the underlying model equations, independently how these model equations are solved.
_[For example, when exporting a model both in Model Exchange and Co-Simulation format; then the model structure is identical in both cases._
_The Co-Simulation FMU has either an integrator included that solves the model equations, or the discretization formula of the integrator and the model equations are solved together ("inline integration")._
_In both cases the model has the same continuous-time <<state,`states`>>._
_In the second case the internal implementation is a discrete-time system, but from the outside this is still a continuous-time model that is solved with an integration method.]_

The required part defines an ordering of the <<output,`outputs`>> and of the (exposed) <<derivative,`derivatives`>>, and defines the unknowns that are available during Initialization _[Therefore, when linearizing an FMU, every tool will use the same ordering for the <<output,`outputs`>>, <<state,`states`>>, and <<derivative,`derivatives`>> for the linearized model.
The ordering of the <<input,`inputs`>> should be performed in this case according to the ordering in `ModelVariables`.]_
A Model Exchange FMU must expose all <<derivative,`derivatives`>> of its continuous-time <<state,`states`>> in element `Derivatives`.
A Co- Simulation FMU does not need to expose these state derivatives.
_[If a Co-Simulation FMU exposes its state derivatives, they are usually not utilized for the co-simulation, but, for example, to linearize the FMU at a communication point.]_

The optional part defines in which way <<derivative,`derivatives`>> and <<output,`outputs`>> depend on <<input,`inputs`>>, and continuous-time <<state,`states`>> at the current super dense time instant (Model Exchange) or at the current communication point (Co-Simulation).
_[The listed <<dependencies>> declare the dependencies between whole (multi-dimensional-)variables and not individual elements of the variables.]_
_[A simulation environment can utilize this information to improve the efficiency, for example, when connecting FMUs together, or when computing the partial derivative of the <<derivative,`derivatives`>> with respect to the <<state,`states`>> in the simulation engine.]_

`ModelStructure` has the following definition:

image::images/ModelStructure_schema.png[width=80%]

`fmi3VariableDependency` is defined as:

image::images/Unknown_schema.png[width=80%]

Elements of the <<InitialUnknowns>> list:

image::images/InitialUnknowns_schema.png[width=50%]

image::images/Unknown_schema_2.png[width=80%]

Note that attribute <<dependenciesKind>> for element <<InitialUnknowns>> has less enumeration values as <<dependenciesKind>> in the other lists.

ModelStructure consists of the following elements (see also figures above; the symbols of the mathematical equations describing the dependency are defined in <<math-model-exchange>>):

[cols="1,5",options="header"]
|====
|_Element-Name_
|_Description_

|`Outputs`
|Ordered list of all outputs, in other words, a list of `Variable` value references where every corresponding `Variable` must have <<causality>> = <<output>> (and *every variable with <<causality>> = <<output>> must be listed here*).
_[Note that all <<output>> variables are listed here, especially <<discrete>> and <<continuous>> <<output,`outputs`>>._
_The ordering of the variables in this list is defined by the exporting tool._
_Usually, it is best to order according to the declaration order in the source model, since then the `Outputs` list does not change if the declaration order of <<output,`outputs`>> in the source model is not changed._
_This is for example, important for linearization, in order that the interpretation of the output vector does not change for a re-exported FMU.]_
Attribute <<dependencies>> defines the dependencies of the <<output,`outputs`>> from the knowns at the current super dense time instant in Event and in Continuous-Time Mode (Model Exchange) and at the current communication point (Co-Simulation).
The functional dependency is defined as (dependencies of variables that are fixed in Event and Continuous-Time Mode and at communication points are not shown): +
[blue]#latexmath:[\color{blue}{(\mathbf{y}_c, \mathbf{y}_d) := \mathbf{f}_{output}(\mathbf{x}_c, \mathbf{u}_c, \mathbf{u}_d, t, \mathbf{p}_{tune})}]#

|`Derivatives`
|Ordered list of all state derivatives, in other words, a list of `Variable` value references where every corresponding `Variable` must be a state derivative.
_[Note that only <<continuous>> Real variables are listed here._
_If a <<state>> or a <<derivative>> of a <<state>> shall not be exposed from the FMU, or if states are not statically associated with a variable (due to dynamic state selection), then dummy `Variable`pass:[s] have to be introduced, for example, `x[4]`, or `xDynamicStateSet2[5]`._
_The ordering of the variables in this list is defined by the exporting tool._
_Usually, it is best to order according to the declaration order of the <<state,`states`>> in the source model, since then the <Derivatives> list does not change if the declaration order of states in the source model is not changed._
_This is for example, important for linearization, in order that the interpretation of the state vector does not change for a re-exported FMU.]_
The corresponding continuous-time <<state,`states`>> are defined by attribute <<derivative>> of the corresponding `Variable` state derivative element.
_[Note that higher order derivatives must be mapped to first order derivatives but the mapping definition can be preserved due to attribute <<derivative>>._
_Example: if_ latexmath:[\color{blue}{\frac{\text{ds}}{\text{dt}} = v,\ \frac{\text{dv}}{\text{dt}} =f(..)}] _,then_ latexmath:[\color{blue}{\left\{ v,\ \frac{\text{dv}}{\text{dt}} \right\}}] _is the vector of state derivatives and attribute <<derivative>> of_ latexmath:[\color{blue}{v}] _references_ latexmath:[\color{blue}{s}] _, and attribute <<derivative>> of_ latexmath:[\color{blue}{\frac{\text{dv}}{\text{dt}}}] _references_ latexmath:[\color{blue}{v}] _.]_ +
For Co-Simulation, element `Derivatives` is ignored if capability flag `providesDirectionalDerivative` has a value of `false`, in other words, it cannot be computed.
_[This is the default._
_If an FMU supports both Model Exchange and Co-Simulation, then the `Derivatives` element might be present, since it is needed for Model Exchange._
_If the above flag is set to `false` for the Co-Simulation case, then the `Derivatives` element is ignored for Co-Simulation._
_If "inline integration" is used for a Co-Simulation slave, then the model still has continuous-time <<state,`states`>> and just a special solver is used (internally the implementation results in a discrete-time system, but from the outside, it is still a continuous-time system).]_ +
Attribute <<dependencies>> defines the dependencies of the state derivatives from the knowns at the current super dense time instant in Event and in Continuous-Time Mode (Model Exchange) and at the current communication point (Co-Simulation).
The functional dependency is defined as (dependencies of variables that are fixed in Event and Continuous-Time Mode and at communication points are not shown): +
[blue]#latexmath:[\color{blue}{\dot{\mathbf{x}_c} := \mathbf{f}_{der}(\mathbf{x}_c, \mathbf{u}_c, \mathbf{u}_d, t, \mathbf{p}_{tune})}]#

|`InitialUnknowns`
a|
[[InitialUnknowns,`InitialUnknowns`]]
Ordered list of all exposed <<Unknown,`Unknowns`>> in Initialization Mode.
This list consists of all variables with

. <<causality>> = <<output>> and (<<initial>> = <<approx>> or <<calculated>>), and

. <<causality>> = <<calculatedParameter>> and

. all continuous-time <<state,`states`>> and all state derivatives (defined with element `<Derivatives>` from `<ModelStructure>`) with <<initial>> = <<approx>> or <<calculated>> _[if a Co-Simulation FMU does not define the <Derivatives> element, (3) cannot be present]_.

The resulting list is not allowed to have duplicates (for example, if a <<state>> is also an <<output>>, it is included only once in the list). +
Attribute <<dependencies>> defines the dependencies of the <<Unknown,`Unknowns`>> from the `Knowns` in Initialization Mode at the initial time.
The functional dependency is defined as:

[blue]#latexmath:[\color{blue}{\dot{\mathbf{v}}_{initialUnknowns} := \mathbf{f}_{init}(\mathbf{u}_c, \mathbf{u}_d, t_0, \mathbf{v}_{initial=exact})}]#

Since, <<output,`outputs`>>, continuous-time <<state,`states`>> and state derivatives are either present as `Knowns` (if <<initial>> = <<exact>>) or as <<Unknown,`Unknowns`>> (if <<initial>> = <<approx>> or <<calculated>>), they can be inquired with `fmi3GetXXX` in InitializationMode.

_[Example: Assume an FMU is defined in the following way:_

latexmath:[\color{blue}{(\mathbf{y}_{c+d}, \dot{\mathbf{x}}_c) := \mathbf{f}_{init}(\mathbf{x}_c, \mathbf{u}_{c+d}, t_0, \mathbf{p})}] +

latexmath:[\color{blue}{(\mathbf{y}_{c+d}, \dot{\mathbf{x}}_c) := \mathbf{f}_{sim}(\mathbf{x}_c, \mathbf{u}_{c+d}, t_i, \mathbf{p})}] +

_Therefore, the initial state latexmath:[\color{blue}{\mathbf{x}_c(t_0)}] has <<initial>> = <<exact>> and the initial state derivative latexmath:[\color{blue}{\dot{\mathbf{x}}_c(t_0)}] has <<initial>> = <<calculated>>._
_The environment can still initialize this FMU in steady-state, by using latexmath:[\color{blue}{\mathbf{x}_c(t_0)}] as iteration variables and adding the equations latexmath:[\color{blue}{\mathbf{x}_c(t_0) = \mathbf{0}}] in the environment.]_

|`Unknown`
|
[[Unknown,`Unknown`]]
An element of one of the lists above defining the unknown with a reference to the corresponding `Variable` element.
It is assumed that at a super-dense time instant latexmath:[\color{blue}{t = (t_R, t_I)}] (Model Exchange) and at a communication point (Co-Simulation) the following relationship holds:

latexmath:[\color{blue}{v_{unknown} = h(\mathbf{v}_{known}, \mathbf{v}_{freeze})}]

where

- latexmath:[\color{blue}{v_{unknown}}] is the unknown variable defined with this element _[for example, an <<output>> or a state derivative]._

- latexmath:[\color{blue}{\mathbf{v}_{known}}] is the vector of input arguments of function `h` that changes its value in the actual Mode _[for example, continuous-time <<input,`inputs`>> in Continuous-Time Mode]_.

- latexmath:[\color{blue}{\mathbf{v}_{freeze}}] is the set of input arguments of function `h` that do not change their values in this Mode, but change their values in other Modes _[for example, <<fixed>> <<parameter,`parameters`>> in Continuous-Time Mode]_.

Attribute <<dependencies>> of <<Unknown>> defines the dependency of latexmath:[\color{blue}{v_{unknown}}] with respect to latexmath:[\color{blue}{\mathbf{v}_{known}}]. +
_[If, for example, a continuous-time <<output>>_ latexmath:[\color{blue}{y_{2}}] _is a function of the continuous-time <<input,`inputs`>>_ latexmath:[\color{blue}{u_{3}}] _and_ latexmath:[\color{blue}{u_{5}}], _and these <<input,`inputs`>> have changed, then_ `fmi3SetXXX` _on_ latexmath:[\color{blue}{u_{3}}] _and_ latexmath:[\color{blue}{u_{5}}] _must always be called before calling_ `fmi3GetXXX` _on_ latexmath:[\color{blue}{y_{2}}] _.]_

|`DiscreteStates`
|Ordered list of all exposed discrete <<state,`states`>>, in other words a list of Variable indices.
Every corresponding Variable may have attribute <<previous>> defined. Discrete <<state,`states`>> must have a <<clockReference>> attribute.
// TODO: unclear why this is not solved or updated yet
//
// [There are three cases:
// (1) discrete states are not exposed, like in FMI 2.0,
// (2) discrete states are exposed through modelDescription with <<previous>> values,
// (3) discrete states are exposed without <<previous>> values.
// It could be a combination of all three in one FMU. Discussion and conclusion:
// Introduce a flag `hasInternalState`, see also #148.]
//  [Need to clarify causality of discrete states (<<local>>, <<output>>?) and if `fmi3SetReal` is allowed for continuous states, see #243.]
// Attribute <<dependencies>> defines the dependencies of the discrete states from the known <<input,`inputs`>>, continuous-time states and previous discrete-time states.
|====

Element <<Unknown>> in `Outputs`, `Derivatives` and <<InitialUnknowns>> has the following attributes:

[cols="1,5", options="header"]
|====
|_Attribute-Name_
|_Description_

|`valueReference`
|The `Variable` value reference of the <<Unknown>> latexmath:[\color{blue}{v_{\text{unknown}}}].


|`dependencies`
|
[[dependencies,`dependencies`]]
Optional attribute defining the dependencies of the unknown latexmath:[\color{blue}{v_{\text{unknown}}}] (directly or indirectly via auxiliary variables) with respect to latexmath:[\color{blue}{\mathbf{v}_{\text{known}}}].
If not present, it must be assumed that the <<Unknown>> depends on all `Knowns`.
If present as empty list, the <<Unknown>> depends on none of the `Knowns`.
Otherwise the <<Unknown>> depends on the `Knowns` defined by the given `Variable` value references. +
`Knowns` latexmath:[\color{blue}{\mathbf{v}_{\text{known}}}] in Event and Continuous-Time Mode (Model Exchange) and at communication points (Co-Simulation) for elements `Outputs`, `Derivatives`:

- inputs (variables with <<causality>> = <<input>>)

- continuous-time states

- <<independent>> variable (usually time; <<causality>> = <<independent>>).
If an <<independent>> variable is not explicitly defined under `Variable`pass:[s], it is assumed that the <<Unknown>> depends explicitly on the <<independent>> variable.

`Knowns` latexmath:[\color{blue}{\mathbf{v}_{\text{known}}}] in Initialization Mode (for elements <<InitialUnknowns>>):

- inputs (variables with <<causality>> = <<input>>)

- variables with <<initial>> = <<exact>> +
_[for example, <<independent>> <<parameter,`parameters`>> or initial <<state,`states`>>.]_

- <<independent>> variable (usually time; <<causality>> = <<independent>>).
If an <<independent>> variable is not explicitly defined under `Variable`pass:[s], it is assumed that the <<Unknown>> depends explicitly on the <<independent>> variable.

For Co-Simulation, <<dependencies>> does not list the dependency on continuous-time, if the capability flag `providesDirectionalDerivative` has a value of `false`.
In other words, the respective partial derivatives cannot be computed.

// TODO: should be discussed after Karl's return
// TODO: is it helpful to include also <<clock>> dependencies here --> i.e. changing this variable will lead to a <<outputClock>> tick.

|`dependenciesKind`
|
[[dependenciesKind, `dependenciesKind`]]
If not present, it must be assumed that the <<Unknown>> latexmath:[\color{blue}{v_{\text{unknown}}}] depends on the `Knowns` latexmath:[\color{blue}{\mathbf{v}_{\text{known}}}] without a particular structure.
Otherwise, the corresponding `Known` latexmath:[\color{blue}{v_{known,i}}] enters the equation as:

If <<dependenciesKind>> is present, <<dependencies>> must be present and must have the same number of list elements.

`= dependent`: no particular structure, latexmath:[\color{blue}{{h(..,\ v}_{known,i}}],..)

Only for Real unknowns latexmath:[\color{blue}{v_{\text{unknown}}}]:

`=` <<constant>>: constant factor, latexmath:[\color{blue}{c \cdot v_{known,i}}] where latexmath:[\color{blue}{c}] is an expression that is evaluated before <<fmi3EnterInitializationMode>> is called.

Only for Real unknowns latexmath:[\color{blue}{v_{\text{unknown}}}] in Event and Continuous-Time Mode (Model Exchange) and at communication points (Co-Simulation), and not for <<InitialUnknowns>> for Initialization Mode:

`=` <<fixed>>: fixed factor, latexmath:[\color{blue}{p \cdot v_{known,i}}] where latexmath:[\color{blue}{p}] is an expression that is evaluated before <<fmi3ExitInitializationMode>> is called.

`=` <<tunable>>: tunable factor, latexmath:[\color{blue}{p \cdot v_{known,i}}] where latexmath:[\color{blue}{p}] is an expression that is evaluated before <<fmi3ExitInitializationMode>> is called and in Event Mode due to an external event (Model Exchange) or at a communication point (Co-Simulation)

`=` <<discrete>>: discrete factor, latexmath:[\color{blue}{d \cdot v_{known,i}}] where latexmath:[\color{blue}{d}] is an expression that is evaluated before <<fmi3ExitInitializationMode>> is called and in Event Mode due to an external or internal event or at a communication point (Co-Simulation).

If <<dependenciesKind>> is present, <<dependencies>> must be present and must have the same number of list elements.
|====

_[Example 1:_

_An FMU is defined by the following equations:_

[latexmath]
++++
\begin{align*}

\frac{d}{\text{dt}}\begin{bmatrix}
x_{1} \\
x_{2} \\
x_{3} \\
\end{bmatrix}

&=

\begin{bmatrix}
f_{1}\left( x_{2} \right) \\
f_{2}\left( x_{1} \right) + 3 \cdot p^{2} \cdot x_{2} + 2 \cdot u_{1} + 3 \cdot u_{3} \\
f_{3}\left( x_{1},x_{3},u_{1},u_{2},u_{3} \right) \\
\end{bmatrix}

\\

y &= g_1(x_2, x_3)

\end{align*},
++++

_where_ latexmath:[\color{blue}{u_{1}}] _is a continuous-time <<input>> (<<variability>> = <<continuous>>),_ latexmath:[\color{blue}{u_{2}}] _is any type of <<input>>,_ latexmath:[\color{blue}{u_{3}}] _is a Real discrete-time <<input>> (<<variability>> = "discrete"`), and_ latexmath:[\color{blue}{p}] _is a <<fixed>> <<parameter>> (<<variability>> = <<fixed>>)._
_The initialization is defined by:_

[latexmath]
++++
x_1 = 1.1, \frac{dx_2}{dt} = 0, y = 3.3,
++++

_and therefore, the initialization equations are:_

[latexmath]
++++
\begin{align*}
x_{2} &= \frac{1}{3 \cdot p^{2}} \cdot ( f_{2}\left( x_{1} \right) + 2 \cdot u_{1} + 3 \cdot u_{3} )
\\
x_{3} &= g_{1}^{- 1}( x_{2}, y)
\end{align*}
++++

_This equation system can be defined as:_

[source, xml]
----
include::examples/model_structure_example1.xml[tags=VariablesAndStructure]
----

_Example 2:_

[latexmath]
++++
y = \left\{ \begin{matrix}
2 \cdot u \ \mathrm{if} \ u > 0 \\
3 \cdot u \ \mathrm{else} \\
\end{matrix}\right.
++++

_where_ latexmath:[\color{blue}{u}] _is a continuous-time <<input>> with <<valueReference>> = `1` and_ latexmath:[\color{blue}{y}] _is a continuous-time <<output>> with <<valueReference>> = `2`._
_The definition of the model structure is then:_

[source, xml]
----
include::examples/model_structure_example2.xml[tags=ModelStructure]
----

_[Note that_ latexmath:[\color{blue}{y = d \cdot u}] _where_ latexmath:[\color{blue}{d}] _changes only during Event Mode (_ latexmath:[\color{blue}{d = 2 \cdot u}] _or_ latexmath:[\color{blue}{3 \cdot u\ }] _depending on relation_ latexmath:[\color{blue}{u > 0}] _that changes only at Event Mode)._
_Therefore <<dependenciesKind>> = <<discrete>>.]_

_Example 3:_

[latexmath]
++++
y = \left\{ \begin{matrix}
2\ \ \mathrm{if}\ \ u > 0 \\
3\ \ \mathrm{else} \\
\end{matrix}\right.
++++

_where_ latexmath:[\color{blue}{u}] _is a continuous-time <<input>> with <<valueReference>> = `1` and_ latexmath:[\color{blue}{y}] _is a continuous-time <<output>> with <<valueReference>> = `2`._
_The definition of the model structure is then:_

[source, xml]
----
include::examples/model_structure_example3.xml[tags=ModelStructure]
----

_[Note that_ latexmath:[\color{blue}{y = c}] _where_ latexmath:[\color{blue}{c}] _changes only during Event Mode (_ latexmath:[\color{blue}{c = 2}] _or_ latexmath:[\color{blue}{3\ }] _depending on relation_ latexmath:[\color{blue}{u > 0}] _that changes only at Event Mode)._
_Therefore <<dependenciesKind>> = <<dependenciesKind,`dependent`>> because it is not a linear relationship on_ latexmath:[\color{blue}{u}]. _]_

_Defining FMU features with the_ <<dependencies>> _list:_

_[Note that via the <<dependencies>> list the supported features of the FMU can be defined._
_Examples:_

- _If a state derivative `der_x` is a function of a <<parameter>> p (so of a <<start>> value of a variable with <<causality>> = <<parameter>> and <<variability>> = <<fixed>>), and the FMU does not support an iteration over `p` during `InitializationMode` (for example, to iterate over p such that the state derivative `der_x` is zero), then the <<dependencies>> list of `der_x` should not include `p`._
_If an FMU is imported in an environment and such an iteration is set up, then the tool can figure out that the resulting algebraic system of equations is structurally singular and therefore can reject such a definition._

- _For standard Co-Simulation FMUs, it is common that no algebraic loops over the <<input>> / <<output>> variables nor over start-values is supported._
_In such a case, all <<dependencies>> lists for <<output>> variables under the <<InitialUnknowns>> element should be defined as empty lists defining that the setting of <<input,`inputs`>> and/or of <<start>> values does not influence the <<output,`outputs`>>._
_As a result, it is not possible to formulate algebraic loops of connected FMUs during InitializationMode.]_

==== Variable Naming Conventions (variableNamingConvention) [[variableNamingConvention]]

With attribute `variableNamingConvention` of element `fmiModelDescription`, the convention is defined how the `Variable.name`pass:[s] have been constructed.
If this information is known, the environment may be able to represent the names in a better way (for example, as a tree and not as a linear list).

In the following definitions, the http://en.wikipedia.org/wiki/Extended_BNF[EBNF] is used:

----
=   production rule
[ ] optional
{ } repeat zero or more times
|   or
----

The following conventions for scalar names are defined:

*`variableNamingConvention = flat`*

----
name = Unicode-char { Unicode-char } // identical to xs:normalizedString
Unicode-char = any Unicode character without carriage return (#xD),
line feed (#xA) nor tab (#x9)
----

The names must be unique, non-empty strings. +
_[It is recommended that the names are visually clearly different from each other; but it is not required.]_

*`variableNamingConvention` = structured`*

Structured names are hierarchical using "." as a separator between hierarchies.
A name consists of "pass:[_]", letters and digits or may consist of any characters enclosed in single apostrophes.
A name may identify an array element on every hierarchical level using "[...]" to identify the respective array index.
A <<derivative>> of a variable is defined with `der(name)` for the first time derivative and `der(name,N)` for the N-th derivative.
Examples:

----
vehicle.engine.speed
resistor12.u
v_min
robot.axis.'motor #234'
der(pipe[3,4].T[14],2) // second time derivative of pipe[3,4].T[14]
----

The precise syntax is footnote:[This definition is identical to the syntax of an identifier in Modelica version 3.2.]:

----
name            = identifier | "der(" identifier ["," unsignedInteger ] ")"
identifier      = B-name [ arrayIndices ] {"." B-name [ arrayIndices ] }
B-name          = nondigit { digit | nondigit } | Q-name
nondigit        = "pass:[_]" | letters "a" to "z" | letters "A" to "Z"
digit           = "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"
Q-name          = "'" ( Q-char | escape ) { Q-char | escape } "'"
Q-char          = nondigit | digit | "!" | "#" | "$" | "%" | "&" | "(" | ")" |
                                     "*" | "+" | "," | "-" | "." | "/" | ":" |
                                     ";" | "<" | ">" | "=" | "?" | "@" | "[" |
                                     "]" | "^" | "{" | "}" | "|" | "~" | " "
escape          = "\'" | "\"" | "\?" | "\\" | "\a" | "\b" |
                  "\f" | "\n" | "\r" | "\t" | "\v"
arrayIndices    = "[" unsignedInteger {"," unsignedInteger} "]"
unsignedInteger = digit { digit }
----

The tree of names is mapped to an ordered list of `Variable.name`pass:[s] in http://en.wikipedia.org/wiki/Depth-first_search[depth-first] order.
Example:

----
vehicle
  transmission
    ratio
    outputSpeed
  engine
    inputSpeed
    temperature
----

is mapped to the following list of `Variable.name`pass:[s]:

----
vehicle.transmission.ratio
vehicle.transmission.outputSpeed
vehicle.engine.inputSpeed
vehicle.engine.temperature
----

All array elements are given in a consecutive sequence of `Variable`pass:[s].
Elements of multi-dimensional arrays are ordered according to "row major" order that is elements of the last index are given in sequence.

_[For example, the vector `centerOfMass` in body `arm1` is mapped to the following `Variable`pass:[s]:_

----
robot.arm1.centerOfMass[1]
robot.arm1.centerOfMass[2]
robot.arm1.centerOfMass[3]
----

_For example, a table `T[4,3,2]` (first dimension 4 entries, second dimension 3 entries, third dimension 2 entries) is mapped to the following `Variable`pass:[s]:_

----
T[1,1,1]
T[1,1,2]
T[1,2,1]
T[1,2,2]
T[1,3,1]
T[1,3,2]
T[2,1,1]
T[2,1,2]
T[2,3,1]
...
----
_]_

It might be that not all elements of an array are present.
If they are present, they are given in consecutive order in the XML file.
