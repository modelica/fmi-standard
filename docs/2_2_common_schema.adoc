=== FMI Description Schema [[fmi-description-schema]]

All static information related to the core functionality of an FMU is stored in the text file `modelDescription.xml` in XML format as specified by the XML schema file `fmi3ModelDescription.xsd`.
Especially, the FMU variables and their attributes such as `name`, `unit`, default <<initial>> value, etc. are stored in this file.
Additional optional information about the graphical representation and the grouping of FMU variables into terminals is stored in the optional text file `icon/terminalsAndIcons.xml` in XML format as specified by the XML schema file `fmi3TerminalsAndIcons.xsd`.

It is not allowed to change the `modelDescription.xml` file.
_[Reason: The `modelDescription.xml` file has to be consistent with the binary or source code implementations._
_Specifically, changes to the start values are not allowed.]_

The structure of the XML files is defined with the schema files `fmi3ModelDescription.xsd` and the optional `fmi3TerminalsAndIcons.xsd`.
These schema files utilize several helper schema files.

In this section these schema files are discussed.
The normative definition are the above mentioned schema files.
Below, optional elements are marked with a dashed box.
The required data types (like: `xs:normalizedString`) are defined in https://www.w3.org/TR/xmlschema-2/[XML Schema Part 2: Datatypes Second Edition].
The types used in the FMI schema files are:

[cols="1,3,1"]
|====
|XML
|Description (http://www.w3.org/TR/xmlschema-2/)
|Mapping to C

|`double`
|IEEE 754 double-precision 64-bit floating point type _[An IEEE 754 double-precision floating point value can have up to 17 significant digits in its decimal representation.
In order to not loose precision, either an appropriate minimal printer algorithm should be used, or alternatively a number of this type should be stored in XML files with at least 17 significant digits.]_
|`double`

|`single`
|IEEE 754 single-precision 32-bit floating point type _[An IEEE 754 single-precision floating point value can have up to 9 significant digits in its decimal representation.
In order to not loose precision, either an appropriate minimal printer algorithm should be used, or alternatively a number of this type should be stored in XML files with at least 9 significant digits.]_
|`float`

|`byte`
|Integer number with maximum value 127 and minimum value -128 (8 bit signed integer)
|`int8_t`

|`unsignedByte`
|Integer number with maximum value 255 and minimum value 0 (8 bit unsigned integer)
|`uint8_t`

|`short`
|Integer number with maximum value 32767 and minimum value -32768 (16 bit signed integer)
|`int16_t`

|`unsignedShort`
|Integer number with maximum value 65535 and minimum value 0 (16 bit unsigned integer)
|`uint16_t`

|`int`
|Integer number with maximum value 2147483647 and minimum value -2147483648 (32 bit signed integer)
|`int32_t`

|`unsignedInt`
|Integer number with maximum value 4294967295 and minimum value 0 (32 bit unsigned integer)
|`uint32_t`

|`long`
|Integer number with maximum value 9223372036854775807 and minimum value -9223372036854775808 (64 bit signed integer)
|`int64_t`

|`unsignedLong`
|Integer number with maximum value 18446744073709551615 and minimum value 0 (64 bit unsigned integer)
|`uint64_t`

|`boolean`
|Boolean number. Legal literals: `false`, `true`, `0`, `1`
|`int`

|`string`
|Any number of characters
|`char*`

|`normalizedString`
|String without carriage return, line feed, and tab characters
|`char*`

|`hexBinary`
|Arbitrary hex-encoded binary data
|`char*`

|`dateTime`
|Date, time and time zone (for details see the link above).
Example: `2002-10-23T12:00:00Z` (noon on October 23, 2002, Greenwich Mean Time)
|tool specific
|====

The first line of an XML file, such as `modelDescription.xml`, must contain the encoding scheme of the XML file.
It is required that the encoding scheme is always UTF-8:

[source, xml]
----
include::examples/co_simulation.xml[lines=1]
----

The FMI schema files (`fmi3*.xsd`) are also stored in UTF-8. +
_[Note that the definition of an encoding scheme is a prerequisite in order for the XML file to contain letters outside of the 7 bit ANSI ASCII character set, such as German umlauts, or Asian characters._
_Furthermore, note the FMI calling interface requires that strings are encoded in UTF-8._
_Since the XML files are also required to be encoded in UTF-8, string variables need not to be transformed when reading from the XML files in to C string variables.]._

The special values `NaN`, `+INF`, `-INF` for variables values are not allowed in the FMI XML files.

_[Note that child information items, such as elements in a sequence are ordered lists according to document order, whereas attribute information items are unordered sets (see http://www.w3.org/TR/XML-infoset/#infoitem.element)._
_The FMI schema is based on ordered lists in a sequence and therefore parsing must preserve this order._
_For example, the information stored in `<ModelVariables><Derivative>` is only correct if this property is fulfilled.]_

==== Definition of an FMU (fmiModelDescription) [[fmiModelDescription]]

This is the root-level schema file and contains the following definition (the figure below contains all elements in the schema file.
Data is defined by attributes to these elements):

[[system_overview]]
image::images/schema/fmiModelDescription.png[width=70%]

On the top level, the schema consists of the following elements (see xref:system_overview[figure above]).
_[If an optional element is present and defines a list (such as `<UnitDefinitions>`), the list must have at least one element (such as `<Unit>`).]_

[cols="1,3",options="header"]
|====
|Element
|Description

|`<ModelExchange>`
|If present, the FMU is based on FMI for Model Exchange (<<fmi-for-model-exchange>>) _[(in other words, the FMU includes the model or the communication to a tool that provides the model, and the environment provides the simulation engine)]_.

|`<BasicCoSimulation>`
|If present, the FMU is based on FMI for Basic Co-Simulation (<<fmi-for-basic-co-simulation>>) _[(in other words, the FMU includes the model and the simulation engine, or a communication to a tool that provides the model and the simulation engine, and the environment provides the master algorithm to run coupled FMU Co-Simulation slaves together)]_.

|`<HybridCoSimulation>`
|If present, the FMU is based on FMI for Hybrid Co-Simulation (<<fmi-for-hybrid-co-simulation>>).

|`<ScheduledCoSimulation>`
|If present, the FMU is based on FMI for Scheduled Co-Simulation (<<fmi-for-scheduled-co-simulation>>).

|`<BuildConfiguration>`
|If present, instructs how to compile sources of a C-code FMU.

|`<UnitDefinitions>`
|A global list of unit and display unit definitions _[for example, used to convert display units into the units used in the model equations]_.
These definitions are used in the XML element `<ModelVariables>`.

|`<TypeDefinitions>`
|A global list of type definitions that are utilized in `<ModelVariables>`.

|`<LogCategories>`
|A global list of log categories that can be set to define the log information that is supported from the FMU.

|`<DefaultExperiment>`
|Providing default settings for the integrator, such as stop time and relative tolerance.

|`<VendorAnnotations>`
|Additional data that a vendor might want to store and that other vendors might ignore.

|`<ModelVariables>`
|The central FMU data structure defining all variables of the FMU that are visible/accessible via the FMU functions.

|`<ModelStructure>`
|Defines the structure of the model.
Especially, the ordered lists of <<output,`outputs`>>, continuous-time <<state,`states`>>, initial unknowns (the unknowns during *Initialization Mode*) and the event indicators are defined here.
For more details on `<ModelStructure>`, see <<ModelStructure>>.
Furthermore, the dependency of the unknowns from the knowns can be optionally defined for <<output,`outputs`>>, continuous-time <<state,`states`>> and initial unknowns.
_[This information can be, for example, used to compute efficiently a sparse Jacobian for simulation, or to utilize the <<input>> / <<output>> dependency in order to detect that in some cases there are actually no algebraic loops when connecting FMUs together]_.
Dependencies for event indicators are not provided.
_[The calculation of derivatives of event indicators is not provided.]_.
|====

At least one element of `<ModelExchange>`, `<BasicCoSimulation>`, `<HybridCoSimulation>` or `<ScheduledCoSimulation>` must be present to identify the type of the FMU.
If both elements are defined, different types of models are included in the FMU.
The details of these elements are defined in <<ModelExchange>>, <<fmi-for-basic-co-simulation>>, <<fmi-for-hybrid-co-simulation>> or <<fmi-for-scheduled-co-simulation>>.

The XML attributes of `<fmiModelDescription>` are:

[cols="1,3",options="header"]
|====
|Attribute
|Description

|`fmiVersion`
|Version of FMI that was used to generate the XML file.
The value for this version is `3.0`.
Future minor revisions are denoted as `3.1`, `3.2` ...

_[During development prototype FMU implementations can indicate compliance with a certain development version based on the tags available at https://github.com/modelica/fmi-standard/tags._
_For example the value for the FMI 3.0 Alpha 2 release is `3.0-alpha.2`.]_

|`modelName`
|The name of the model as used in the modeling environment that generated the XML file, such as `Modelica.Mechanics.Rotational.Examples.CoupledClutches`.

|`instantiationToken`
|The `instantiationToken` is a string that can be used by the FMU to check that the XML file is compatible with the implementation of the FMU.
For this purpose the importing tool must pass the `instantiationToken` from the `modelDescription.xml` to the <<fmi3Instantiate>> function call.

|`description`
|Optional string with a brief description of the model.

|`author`
|Optional string with the name and organization of the model author.

|`version`
|Optional version of the model _[for example `1.0`]_.

|`copyright`
|Optional information on the intellectual property copyright for this FMU _[for example `(C) My Company 2011`]_.

|`license`
|Optional information on the intellectual property licensing
for this FMU _[for example `BSD license <license text or link to license>`]_.

|`generationTool`
|Optional name of the tool that generated the XML file.

|`generationDateAndTime`
|Optional date and time when the XML file was generated.
The format is a subset of `dateTime` and should be: `YYYY-MM-DDThh:mm:ssZ` (with one `T` between date and time; `Z` characterizes the Zulu time zone, in other words, Greenwich meantime) _[for example `2009-12-08T14:33:22Z`]_.

|`variableNamingConvention`
|Defines whether the variable names in `<ModelVariables>` and in `<TypeDefinitions>` follow a particular convention.
For the details, see <<variableNamingConvention>>. Currently standardized are:

- `flat`: A list of strings (the default).

- `structured`: Hierarchical names with `.` as hierarchy separator, and with array elements and derivative characterization.

|====

==== Definition of Units (UnitDefinitions)

In this section, the units of the variables are defined.

_[Unit support is important for technical systems since otherwise it is very easy for errors to occur._
_Unit handling is a difficult topic, and there seems to be no method available that is really satisfactory for all applications, such as unit check, unit conversion, unit propagation or dimensional analysis._
_In FMI, a pragmatic approach is used that takes into account that every software system supporting units has potentially its own specific technique to describe and utilize units._
_The approach used here is slightly different than FMI 1.0 to reduce the need for standardized string representations.]_

Element `<fmiModelDescription><UnitDefinitions>` is defined as:

image::images/schema/UnitDefinitions.png[width=90%]

It consists of zero or more `Unit` definitions.
If no units are defined, element `<UnitDefinitions>` must not be present.
If 1 or more units are defined, this element must be present.

A `Unit` is defined by its `name` attribute such as `N.m` or `N*m` or `Nm`, which must be unique with respect to all other defined elements of the `<UnitDefinitions>` list.
If a variable is associated with a `Unit`, then the value set (resp. get) with functions `fmi3Set{VariableType}` (resp. `fmi3Get{VariableType}`) has this `Unit`.
_[The purpose of the name is to uniquely identify a unit and, for example, use it to display the unit in menus or in plots._
_Since there is no standard to represent units in strings, and there are different ways how this is performed in different tools, no specific format for the string representation of the unit is required.]_

Optionally, a value given in unit `Unit` can be converted to a value with respect to unit `<BaseUnit>` utilizing the conversion `factor` and `offset` attributes:

image::images/schema/BaseUnit.png[width=50%, align="center"]

Besides `factor` and `offset`, the `<BaseUnit>` definition consists of the exponents of the 7 SI base units `kg`, `m`, `s`, `A`, `K`, `mol`, `cd`, and of the exponent of the SI derived unit `rad`.
_[The additional `rad` base unit helps to handle the often occurring quantities in technical systems that depend on an angle.]_

A value with respect to `Unit` (abbreviated as `Unit_value`) is converted with respect to `<BaseUnit>` (abbreviated as `BaseUnit_value`) by the equation:

`BaseUnit_value = factor * Unit_value + offset`

_[For example, if_ latexmath:[\color{blue}{p_{bar}}] _is a pressure value in unit `bar`, and_ latexmath:[\color{blue}{p_{Pa}}] _is the pressure value in `<BaseUnit>`, then_

latexmath:[\color{blue}{p_{Pa} = 10^5 p_{bar}}]

_and therefore, `factor = 1.0e5` and `offset = 0.0`._

_In the following table several unit examples are given (Note that if in column `exponents` the definition "latexmath:[\color{blue}{kgm^2 / s^2}]" is present, then the attributes of `<BaseUnit>` are: `kg=1, m=2, s=-2`):_

[cols="1,1,1,1,1"]
|====
.2+|Quantity
.2+|Unit.name +
(examples)

3+|Unit.BaseUnit
|exponents
|factor
|offset

|_Torque_
|`N.m`
|latexmath:[\color{blue}{kg \cdot m^2 / s^2}]
|`1.0`
|`0.0`

|_Energy_
|`J`
|latexmath:[\color{blue}{kg \cdot m^2 / s^2}]
|`1.0`
|`0.0`

|_Pressure_
|`bar`
|latexmath:[\color{blue}{\frac{kg}{m \cdot s^2}}]
|`1.0e5`
|`0.0`

|_Angle_
|`deg`
|`rad`
|`0.01745329251994330 (= pi/180)`
|`0.0`

|_Angular velocity_
|`rad/s`
|`rad/s`
|`1.0`
|`0.0`

|_Angular velocity_
|`rpm`
|`rad/s`
|`0.1047197551196598 (=2*pi/60)`
|`0.0`

|_Frequency_
|`Hz`
|`rad/s`
|`6.283185307179586` +
`(= 2*pi)`
|`0.0`

|_Temperature_
|`&#176;F`
|`K`
|`0.5555555555555556` +
`(= 5/9)`
|`255.3722222222222` +
`(= 273.15-32*5/9)`

|_Per cent by length_
|`%/m`
|`1/m`
|`0.01`
|`0.0`

|_Parts per million_
|`ppm`
|`1`
|`1.0e-6`
|`0.0`

|_Length_
|`km`
|`m`
|`1000`
|`0.0`

|_Length_
|`yd`
|`m`
|`0.9144`
|`0.0`
|====

_Note that `Hz` is typically used as `Unit.name` for a frequency quantity, but it can also be used as `<DisplayUnit>` for an angular velocity quantity (since `revolution/s`).]_

_The `<BaseUnit>` definitions can be utilized for different purposes (the following application examples are optional and a tool may also completely ignore the `Unit` definitions):_

Signal connection check::
+
_When two signals v1 and v2 are connected together, and on at least one of the signals no `<BaseUnit>` element is defined, then the connection equation "v2 = v1" holds (if v1 is an <<output>> of an FMU and v2 is an <<input>> of another FMU, with `fmi3Get{VariableType}` the value of v1 is inquired and used as value for v2 by calling `fmi3Set{VariableType}`)._
+
_When two signals v1 and v2 are connected together, and for both of them `<BaseUnit>` elements are defined, then they must have identical exponents of their `<BaseUnit>`._
_If `factor` and `offset` are also identical, again the connection equation `v2 = v1` holds._
_If `factor` and `offset` are not identical, the tool may either trigger an error or, if supported, perform a conversion; in other words, use the connection equation (in this case the `relativeQuantity` of the `<TypeDefinition>`, see below, has to be taken into account in order to determine whether `offset` shall or shall not be utilized):_
+
`factor(v1) * v1 + offset(v1) = factor(v2) * v2 + offset(v2)`
+
_As a result, wrong connections can be detected (for example, connecting a force with an angle signal would trigger an error) and conversions between, say, US and SI units can be either automatically performed or, if not supported, an error is triggered as well._
+
_[Note that this approach is not satisfactory for variables belonging to different quantities that have, however, the same `<BaseUnit>`, such as quantities `Energy` and `Torque`, or `AngularVelocity` and `Frequency`._
_To handle such cases, quantity definitions have to be taken into account (see `<TypeDefinitions>`) and quantity names need to be standardized.]_
+
_This approach allows a general treatment of units, without being forced to standardize the grammar and allowed values for units (for example, in FMI 1.0, a unit could be defined as `N.m` in one FMU and as `N*m` in another FMU, and a tool would have to reject a connection, since the units are not identical. In FMI 2.0, the connection would be accepted, provided both elements have the same `<BaseUnit>` definition)._

Dimensional analysis of equations::
+
_In order to check the validity of equations in a modeling language, the defined units can be used for dimensional analysis, by using the `<BaseUnit>` definition of the respective unit._
_For this purpose, the `<BaseUnit>` `rad` has to be treated as `1`._
_Example:_
+
[latexmath]
++++
\begin{align*}
J \cdot \alpha = \tau \rightarrow [kg.m^2]*[rad/s^2] = [kg.m^2/s^2] & \quad \text{// o.k. ("rad" is treated as "1")} \\
J \cdot \alpha = f \rightarrow [kg.m^2]*[rad/s^2] = [kg.m/s^2] & \quad \text{// error, since dimensions do not agree}
\end{align*}
++++

Unit propagation::
+
_If unit definitions are missing for signals, they might be deduced from the equations where the signals are used._
_If no unit computation is needed, `rad` is propagated._
_If a unit computation is needed and one of the involved units has `rad` as a `<BaseUnit>`, then unit propagation is not possible._
_Examples:_
+
- _a = b + c, and `Unit` of c is provided, but not `Unit` of a and b:_ +
_The Unit definition of `c` (in other words, `Unit.name`, `<BaseUnit>`, `<DisplayUnit>`) is also used for `a` and `b`._
_For example, if BaseUnit(c) = `rad/s`, then BaseUnit(a) = BaseUnit(b) = `rad/s`._
+
- _a = b*c, and `Unit` of a and of c is provided, but not `Unit` of b:_ +
_If `rad` is either part of the `<BaseUnit>` of `a` and/or of `c`, then the `<BaseUnit>` of `b` cannot be deduced (otherwise it can be deduced)._
_Example: If `BaseUnit(a) = kg.m/s2` and `BaseUnit(c) = m/s2`, then the `BaseUnit(b) can be deduced to be `kg`._
_In such a case `Unit.name` of b cannot be deduced from the `Unit.name` of `a` and `c`, and a tool would typically construct the `Unit.name` of `b` from the deduced `<BaseUnit>`._

_]_

Additionally to the unit definition, optionally a set of display units can be defined. These can be utilized for <<input>> / <<output>> of a value:

image::images/schema/DisplayUnit.png[width=60%, align="center"]

A `<DisplayUnit>` is defined by `name`, `factor` and `offset`.
The attribute `name` must be unique with respect to all other `names` of the `<DisplayUnit>` definitions of the same `Unit` [(different `Unit` elements may have the same `<DisplayUnit>` names)].
A value with respect to Unit (abbreviated as `Unit_value`) is converted with respect to `<DisplayUnit>` (abbreviated as `DisplayUnit_value`) by the equation:

`DisplayUnit_value = factor * Unit_value + offset`

_[For example, `offset` is needed for temperature units.]_

_[For example, if latexmath:[\color{blue}{T_K}] is the temperature value of `Unit.name` (in `K`) and latexmath:[\color{blue}{T_F}] is the temperature value of `<DisplayUnit>` (in `&#176;F`), then_

[latexmath]
++++
T_F = (9/5) * (T_K - 273.15) + 32
++++

_and therefore, `factor = 1.8 (=9/5)` and `offset = -459.67 (= 32 - 273.15*9/5)`._

_Both the `DisplayUnit.name` definitions as well as the `Unit.name` definitions are used in the variable elements._
_Example of a definition:_

[source, xml]
----
include::examples/unit_definition.xml[tags=UnitDefinitions]
----
_]_

The schema definition is present in a separate file `fmi3Unit.xsd`.

==== Definition of Types (TypeDefinitions) [[definition-of-types]]

Element `<fmiModelDescription><TypeDefinitions>` is defined as:

image::images/schema/TypeDefinitions.png[width=70%, align="center"]

This element consists of a set of `<TypeDefinition>` elements according to schema `fmi3TypeDefinition` in file `fmi3Type.xsd`.
Each `<TypeDefinition>` has attributes `name` and `description`.
Attribute `name` must be unique with respect to all other elements of the `<TypeDefinitions>` list.
Furthermore, `name` of a `<TypeDefinition>` must be different to all `name` attributes of variables _[if the same names would be used, then this would nearly always give problems when importing the FMU in an environment such as Modelica, where a type name cannot be used as instance name]_.

Additionally, one variable type element must be present.
Each variable type has its own attributes which can be consulted in the schema.
The following are representative examples:

image::images/schema/Float64.png[width=60%, align="center"]

image::images/schema/Int32.png[width=50%, align="center"]

image::images/schema/Boolean.png[width=50%, align="center"]

image::images/schema/Binary.png[width=70%, align="center"]

image::images/schema/Enumeration.png[width=75%, align="center"]


The type elements are referred to in variable elements to declare their type.
_[The alternative would be to define a type per variable. However, this would lead to a situation where, e.g., the definition of a `Torque` type would have to be repeated over and over.]_
The attributes and elements have the following meaning:

[cols="1,5",options="header"]
|====
|Attribute or Elements
|Description

|`quantity`
|Physical quantity of the variable. _[For example, `Angle`, or `Energy`.
The quantity names are not standardized]_

|`unit`
|Unit of the variable defined with attribute `name` of `<UnitDefinitions><Unit>` that is used for the model equations.
_[For example, `N.m`: in this case a `Unit.name = `N.m` must be present under `<UnitDefinitions>`.]_
_[Note that for variables that are without a unit, the element should not have a `unit` attribute.]_
_[Giving an empty string as a `unit` attribute specifies a valid unit that needs to be defined among the unit definitions.]_

|[[displayUnit,`displayUnit`]] `displayUnit`
|Default display unit. The conversion to the `unit` is defined with the element `<fmiModelDescription><UnitDefinitions>`.
If the corresponding `displayUnit` is not defined under `<UnitDefinitions><Unit><DisplayUnit>`, then `displayUnit` is ignored.
It is an error if `displayUnit` is defined as variable type element, but `unit` is not, or unit is not defined under `<UnitDefinitions><Unit>`.

|`mimeType`
|Indicates the type of data passed as a binary.
Defaults to `application/octet-stream`, which is unspecific.
Implementations can use this information to provide guidance to the user about valid/useful connections.

|`relativeQuantity`
|If this attribute is `true`, then the `offset` of `displayUnit` must be ignored.
_[For example, 10 degree Celsius = 10 Kelvin if `relativeQuantity = true` and not 283.15 Kelvin.]_

|`min`
|Minimum value of variable (variable value latexmath:[\geq] `min`).
If not defined, the minimum is the largest negative number that can be represented on the machine.
The `min` definition is information from the FMU to the environment defining the region in which the FMU is designed to operate, see also comment after this table.

|`max`
|Maximum value of variable (variable value latexmath:[\leq] `max`).
If not defined, the maximum is the largest positive number that can be represented on the machine.
The `max` definition is information from the FMU to the environment defining the region in which the FMU is designed to operate, see also comment after this table.

|`nominal`
|Nominal value of variable.
If not defined and no other information about the nominal value is available, then `nominal = 1` is assumed. +
_[The nominal value of a variable can be, for example, used to determine the absolute tolerance for this variable as needed by numerical algorithms:_ +
`absoluteTolerance = nominal * tolerance * 0.01` +
_where `tolerance` is, for example, the relative tolerance defined in <<DefaultExperiment>>.]_

|`unbounded`
|If `true`, indicates that during time integration, the variable gets a value much larger than its nominal value `nominal`.
_[Typical examples are the monotonically increasing rotation angles of crank shafts and the longitudinal position of a vehicle along the track in long distance simulations._
_This information can, for example, be used to increase numerical stability and accuracy by setting the corresponding bound for the relative error to zero (relative tolerance = 0.0), if the corresponding variable is a continuous <<state>> variable.]_

|`Item`
|`<Item>` of an enumeration has a sequence of `name` and `value` pairs.
The values can be any integer number but must be unique within the same enumeration (in order that the mapping between `name` and `value` is bijective).
An `<Enumeration>` element must have at least one `<Item>`.
|====

_[Attributes `min` and `max` can be set for variables of numeric type or `<Enumeration>`._
_The question is how `fmi3Set{VariableType}`, `fmi3Get{VariableType}` shall utilize this definition._
_There are several conflicting requirements:_ +
_Avoiding forbidden regions (for example, if `u` is an <<input>> and "sqrt(u)" is computed in the FMU, `min = 0` on `u` shall guarantee that only values of `u` in the allowed regions are provided)._
_Numerical algorithms (solvers or optimizers) do not guarantee constraints._
_If a variable is outside of the bounds, the solver tries to bring it back into the bounds._
_As a consequence, calling `fmi3Get{VariableType}` during an iteration of such a solver might return values that are not in the defined min/max region._
_After the iteration is finalized, it is only guaranteed that a value is within its bounds up to a certain numerical precision._ +
_In debug mode checks on min/max should be performed._
_For maximum performance on a real-time system, the checks might not be performed._ +
_The approach in FMI is therefore that min/max definitions are an information from the FMU to the environment defining the region in which the FMU is designed to operate._
_The environment is free to utilize this information (typically, in debug mode of the environment the min/max is checked in the cases as stated above)._
_In any case, it is expected that the FMU handles variables appropriately where the region definition is critical._
_For example, dividing by an <<input>> (so the <<input>> should not be in a small range of zero) or taking the square root of an <<input>> (so the <<input>> should not be negative) may either result in `fmi3Error`, or the FMU is able to handle this situation in other ways._

_If the FMU is generated so that min/max shall be checked whenever meaningful (for example, for debug purposes), then the following strategy should be used:_

_If `fmi3Set{VariableType}` is called violating the min/max attribute settings of the corresponding variable, the following actions are performed:_

- _On a <<fixed>> or <<tunable>> <<parameter>> `fmi3Status = fmi3Discard` is returned._
- _On an <<input>>, the FMU decides what to return (If no computation is possible, it could return `fmi3Status = fmi3Discard`, in other situations it may return `fmi3Warning` or `fmi3Error`, or `fmi3OK`, if it is uncritical)._

_If an FMU defines min/max values for integer types and `<Enumeration>` variables (<<local>> and <<output>> variables), then the expected behavior of the FMU is that `fmi3Get{VariableType}` functions return values in the defined range._

_If an FMU defines min/max values for numeric types, then the expected behavior of the FMU is that `fmi3Get{VariableType}` returns values at the solution (accepted steps of the integrators) in the defined range with a certain uncertainty related to the tolerances of the numerical algorithms.]_

===== Clock Type Definition [[clock-type-definition]]

Clocks are integrated in the element `<fmiModelDescription><ModelVariables>` as a variable element with the base type `fmi3Clock`.
The variable sub type `fmi3Clock` provides additional attributes for defining <<clock,`clocks`>>.

[cols="1,5",options="header"]
|====
|Attribute
|Description

|`clockType`
|The type of <<clock,`clocks`>> is defined based on the mandatory attribute `clockType`.
If the properties of a <<clock>> adhere to synchronous clock theory it is defined with `clockType = synchronousTime`.
Otherwise, if the <<clock>> is to be used in FMI for Hybrid Co-Simulation, FMI for Scheduled Co-Simulation, or can be associated to model partitions in continuous parts of the FMU, then `clockType = communicationPoint`.
The ticks of these clocks define the sampling points (i.e. communication points) for the variables of these model partitions.
These clocks are ignored by Model Exchange, and it is not allowed to include <<clock,`clocks`>> of different `clockType` in one FMU.
`clockType` is a required attribute.

|`priority`
|The <<clock,`clocks`>> are ordered descending based on their priorities.
The priority of a <<clock>> has to be defined via the unsigned integer attribute `priority` - smaller values have a higher priority.
It is possible to define multiple <<clock,`clocks`>> with the same priority.
No ordering is defined for <<clock,`clocks`>> of the same priority.
If a computational order information is needed, different priorities have to be defined.

_[For periodic <<clock,`clocks`>> it is recommended to derive the priorities based on a rate monotonic scheduling scheme (smallest period leads to highest priority, that is, has the smallest priority value.]_

`priority` is a required attribute.

|`periodic`
|Clocks can be periodic or non-periodic. If a <<clock>> is periodic, the attribute `periodic = true`.

`periodic` is an optional attribute. The default value is `false`.

|`strict`
|If a periodic <<clock>> is strictly periodic, the `strict` attribute is `true`.
If the optional attribute `strict` is set to `true`, then the FMU and the simulation master have to respect the predefined interval and offset.
If the optional attribute `strict` is set to `false` another interval or offset can be used, derived from the current simulation setup.

`strict` is an optional attribute. The default value is `false`.
The FMU exporter is not allowed to set `strict` to `true` if `periodic = false`.

|`intervalCounter`, `shiftCounter`, `resolution`
|The interval of <<output>> or <<input>> periodic <<clock,`clocks`>> is a rational number defined with unsignedLong valued `intervalCounter` and `resolution`:

`interval = intervalCounter / resolution`.

The initial tick of periodic <<clock,`clocks`>> may be delayed by defining a `shiftCounter` (default value 0). This results in the actual

`offset = interval * shiftCounter / resolution`.

More information about clock intervals:
 <<additional-clock-properties>>.

The attributes `intervalCounter`, `shiftCounter` and `resolution` are interval <<start>> values for periodic <<clock,`clocks`>> and must not be used together with non-periodic <<clock,`clocks`>>.
If `strict = true` it is required to provide values for `intervalCounter`, `shiftCounter` and `resolution`.

`intervalCounter` and `resolution` have no default value.
|====

[#TypeDefinitions]
image::images/schema/Clock.png[width=55%, align="center"]

==== Definition of Log Categories (`LogCategories`) [[definition-of-log-categories]]

Element `<fmiModelDescription><LogCategories>` is defined as:

image::images/schema/LogCategories.png[width=80%, align="center"]

`<LogCategories>` defines an unordered set of category strings that can be utilized to define the log output via function <<logMessage>>, see <<creation-destruction-and-logging>>.
A tool is free to use any `normalizedString` for a category value.
The `name` attribute of `<Category>` must be unique with respect to all other elements of the `<LogCategories>` list.

There are the following standardized names for `<Category>` and these names should be used if a tool supports the corresponding log category.
If a tool supports one of these log categories and wants to expose it, then an element `<Category>` with this name should be added to `<LogCategories>` _[To be clear, only the `<Category>` names listed under `<LogCategories>` in the XML file are known to the importer of the FMU.]_

[cols="1,3",options="header"]
|====
|Category
|Description

|`logEvents`
|Log all events (during initialization and simulation).

|`logSingularLinearSystems`
|Log the solution of linear systems of equations if the solution is singular (and the tool picked one solution of the infinitely many solutions).

|`logNonlinearSystems`
|Log the solution of nonlinear systems of equations.

|`logDynamicStateSelection`
|Log the dynamic selection of <<state,`states`>>.

|`logStatusWarning`
|Log messages when returning `fmi3Warning` status from any function.

|`logStatusDiscard`
|Log messages when returning `fmi3Discard` status from any function.

|`logStatusError`
|Log messages when returning `fmi3Error` status from any function.

|`logStatusFatal`
|Log messages when returning `fmi3Fatal` status from any function.

|`logAll`
|Log all messages.
|====

The optional attribute `description` shall contain a description of the respective log category.
_[Typically, this string can be shown by a tool if more details for a log category are presented.]_

_[This approach to define `<LogCategories>` has the following advantages:_

. _A simulation environment can present the possible log categories in a menu and the user can select the desired one (in the FMI 1.0 approach, there was no easy way for a user to figure out from a given FMU what log categories could be provided)._ +
_Note that since element `<LogCategories>` is optional, an FMU does not need to expose its log categories._

. _The log output is drastically reduced, because via <<fmi3SetDebugLogging>> exactly the categories are set that shall be logged and therefore the FMU only has to print the messages with the corresponding categories to the <<logMessage>> function._
_In FMI 1.0, it was necessary to provide all log output of the FMU to the <<logMessage>> and then a filter in the <<logMessage>> could select what to show to the end-user._
_The approach introduced in FMI 2.0 is therefore much more efficient.]_

==== Definition of a Default Experiment (DefaultExperiment) [[DefaultExperiment]]

Element `<fmiModelDescription><DefaultExperiment>` is defined as:

image::images/schema/DefaultExperiment.png[width=60%, align="center"]

`<DefaultExperiment>` consists of the optional default start time, stop time, relative tolerance, and step size for the first simulation run.
A tool may ignore this information.
However, it is convenient for a user that `startTime`, `stopTime`, `tolerance` and `stepSize` have already a meaningful default value for the model at hand.
Furthermore, for Co-Simulation FMUs the `stepSize` defines the preferred `communicationStepSize`.

==== Definition of Terminals and Icons (fmiTerminalsAndIcons) [[fmiTerminalsAndIcons]]

This is the root element of the XML file `icon/terminalsAndIcons.xml`, and is defined as:

[[terminals_and_icons_overview]]
image::images/schema/fmiTerminalsAndIcons.png[width=60%, align="center"]

On the top level, the schema consists of the following elements (see xref:terminals_and_icons_overview[figure above]).

[cols="1,3",options="header"]
|====
|Element
|Description

|`<GraphicalRepresentation>`
|If present, contains information for authoring tools to draw graphical representations of the FMU in a system view.

|`<Terminals>`
|If present, this allows combining input and output signals into logical groups to ease connections on a system level.
|====

===== Definition of a Graphical Representation (GraphicalRepresentation) [[graphicalRepresentation]]


====== Overview

The graphical representation of the FMU and terminals are needed in order to more easily comprehend the meaning of connected FMUs and to help an importing tool to display the terminals and the FMU icon in the way the exporter intended.

The graphical representation is fully optional.
The graphical representation of terminals is separate from the terminal definitions in the `<Terminals>` element.

There are two optional elements in the `<GraphicalRepresentation>`:

. The `<CoordinateSystem>` defines the extent of the whole icon (graphical items may exceed that rectangle).
. The `<Icon>` defines an image source for the FMU.


image::images/schema/GraphicalRepresentation.png[width=100%, align="center"]

====== CoordinateSystem

image::images/schema/CoordinateSystem.png[width=70%, align="center"]

The `<CoordinateSystem>` element and its defined extent is used as reference for other graphical items. It also provides a scaling factor to millimeter.

The coordinate system is defined by the coordinates of two points, the lower left (`x1`, `y1`) corner and the upper right (`x2`, `y2`) corner, where the coordinates of the first point shall be less than the coordinates of the second point _[a first quadrant coordinate system]_.
The x-axis is directed to the right, the y-axis is directed upwards.

_[The exporting tool should define how the coordinate system unit relates to mm display or print out size._
_However, an importing tool might choose to use the factor from the default coordinate system extent to the actual coordinate system extent to calculate a scaling factor, to match the default icon size in the importing tool._

_The area defined by the coordinate system is suggested to be used as "clickable icon size" in other tools._
_A `<Terminal>` might be placed outside of this area, so the visible bounding box has to be determined by the importing tool.]_

The coordinate system default is `x1=-100, y1=-100, x2=100, y2=100`. This extent is used if the `<CoordinateSystem>` element is missing.
The default `suggestedScalingFactorTo_mm` is 0.1.
So the default coordinate system display size should be 20 mm width and 20 mm height.

The FMU icon and all graphical representations provide the position and extent with the attributes `x1`, `y1`, `x2`, `y2`.
The values of these attributes directly relate to this coordinate system and are not normalized.
Flipping of the FMU icon or a terminal can be realized by setting its attributes `x2 < x1` or `y2 < y1` without changing the coordinate system.

====== Icon

image::images/schema/Icon.png[width=40%, align="center"]

The extent and position of the FMU icon are defined in the `<Icon>` element.
The optional image file of the FMU icon is placed at the path `icon/icon.png` in the ZIP archive of the FMU. The terminals should not be visible in the image.
Optionally an SVG file can be provided if also the PNG file is present.
This enables high quality rendering and printing in importing tools.
This SVG file has to be placed at the path `icon/icon.svg` in the ZIP archive.

The point (`x1`, `y1`) maps to the left lower corner of the PNG image or SVG viewport.
The point (`x2`, `y2`) maps to the right upper corner of the PNG image or SVG viewport.

====== Placement, Extent, and Painting Order of Graphical Items

image::images/GraphicalRepresentation.svg[width=70%, pdfwidth=70%, align="center"]

The clickable icon size is defined by the `<CoordinateSystem>` element.
The FMU icon itself may exceed this extent (or bounding box).
The bounding box of the terminals is given by the extent in the terminals element.
Their location is neither limited to the extent of the icon nor the extent of the coordinate system.
_[An importing tool has to determine the outer bounding box enclosing all graphical items.]_

Transparent SVG or PNG files are allowed and wanted. The order of the elements in the XML file defines the order of painting.
The first element in the `<GraphicalRepresentation>` is painted first and therefore behind the others, the last element is painted on top of the others and because of that in front of them.
_[So the FMU icon should be placed first in the XML file, terminal below.]_

===== Definition of Terminals (Terminals)

====== Overview

Terminals are fully optional and can be ignored by any importing tool.

Definition `<Terminal>`: A terminal is...

* a structured interface for connections to other models
* intended to be used for signal flow between models, parameter propagation, and compatibility checks of the model configuration
* a sequence of references to variables with connection meta data

Predefined rules for variable matching in a connection are given below.
Predefined variable kinds are used to describe how the member variables have to be handled.
Domain specific connection rules, terminals and their member variables can be provided by other standards.

_[Co-simulation errors are not addressed by the terminals._
_The co-simulation algorithm has to be chosen and implemented by the importing tool._
_Features that might be required for specific co-simulation algorithms had to be implemented by the FMU exporting tool._

_Algebraic loops in systems of connected Model Exchange FMUs are not addressed or resolved by the terminals._
_It is not required that the <<causality>> of the terminal member variables in connected terminals match._

_The SSP standard refers to a `connectorKind`._
_This `connectorKind` is not related to the `terminalKind` or `variableKind` described in the following sections.]_

====== Terminals

Element `<fmiTerminalsAndIcons><Terminals>` is defined as:

image::images/schema/Terminals.png[width=80%, align="center"]

All instances of `<Terminal>` have the type `fmi3Terminal` and are listed in the `<Terminals>` sequence.

The normalized string attribute `name` of the `<Terminal>` element is the instance name of the terminal. The terminal name must be unique on each level.
//_[The terminal name may contain dots, to enable structured terminals.]_

The normalized string attribute `matchingRule` describes the rules for variable matching in a connection.
There are three predefined matching rules: plug, bus, and sequence.
Other standards may define new matching rules.
_[It is recommended that vendor specific rules start with `_vendorName` or `_toolName` to avoid namespace clashes.]_

There is a sequence of terminal member variables, terminal stream member variables, nested terminals, and an optional `<GraphicalRepresentation>` element in the `<Terminal>` element.
The member variables are the exchanged variables.
The type of the nested terminals is `fmi3Terminal`, and they can be used to implement structured terminals.

[cols="1,3",options="header"]
|====
|`matchingRule`
|Description

[[plug,`plug`]]
|`plug`
|Matching of the variables is based on `memberName`.
An importing tool should connect terminals only if all member variables are present and match.

[[bus,`bus`]]
|`bus`
|Matching of the variables is based on `memberName`.
An importing tool may connect terminals if some or no terminal member variables are present.

[[sequence,`sequence`]]
|`sequence`
|Matching of the variables is based on the order of the terminal member variables.
An importing tool should connect terminals only if the number of member variables matches.

|====

The normalized string `terminalKind` is an optional attribute. Other standards may define terminal kinds.
It is intended that the `terminalKind` is used to define domain specific member variable sequences, member names and order, or high level restrictions for connections.

_[Other terminal kinds should refer to the predefined `matchingRule`._
_Vendor specific terminal kinds should start with `_vendorName` or `_toolName` to avoid namespace clashes._

_Examples for `terminalKind`: `StandardXXX_Mechanical_Translational`, `Modelica.Mechanics.Translational.Interfaces.Flange_a`, `vendorNameA_customTypeA`, `_vendorNameB_customLibrary_customTypeB`._

_The structured naming convention of the `<ModelVariables>` is <<independent>> from the terminal names and member variable names._

_A tool may choose to connect terminals with a different or unknown `terminalKind`, if the `matchingRule` matches.]_

====== Terminal Member Variable

The `<TerminalMemberVariable>` is defined as:

image::images/schema/TerminalMemberVariable.png[width=70%, pdfwidth=50%, align="center"]

The normalized string `variableKind` is used to provide general information about the variable.
This information defines how the connection of this variable has to be implemented (e.g. Kirchhoff's current law or common signal flow).

If the `matchingRule` `plug` and `bus` are used, then the normalized string `memberName` is used for member variable matching. So the `memberName` attribute is required for `plug` and `bus` and it has to be unique for a terminal. The `memberName` is not required for `matchingRule` `sequence`.

The normalized string `variableName` is used to identify the terminal member variable in the element `<ModelVariables>`. The information about minimum, maximum, and nominal values is available in there.

One variable can be part of several terminals.

_[The suggested variable naming scheme for the structured naming convention is <ModelVariable name> = <terminalName>.<memberName>._

_Not all `<ModelVariables>` which have the prefix "<terminalName>." are a member variable, and there may exist member variables which don't have this prefix._

_Example 1 (suggested scheme): <ModelVariable name> is `portA.U`, <terminalName> is `portA`, <memberName> is `U`._

_Example 2 (suggested scheme): <ModelVariable name> is `hierarchConn.innerConn.U`, <outer terminal name> is `hierarchConn`, <inner terminal name> is `innerConn`, <memberName> is `U`._

_Example 3 (no prefix): <ModelVariable name> is `u`, <terminalName> is `portA`, <memberName> is `u`._

_Example 4 (prefix but not a member): <ModelVariable name> is `portA.u`, there is a terminal with <terminalName> `portA`, but this variable is not a terminal member._

_The suggested variable naming scheme for the non-structured naming convention is: <ModelVariable name> = <memberName>_

_Matching is not restricted by <<variability>>, <<causality>> or variable type._
_Example: A <<fixed>> variable may be connected to a <<tunable>> variable, a variable of type `fmi3Float64` may be connected to a variable of type `fmi3Int32`._
_However, it is recommended that the variable types and variabilities are equal._

_The `matchingRule` refers to the `<TerminalMemberVariable>` on the same level only. Nested terminals can have different `matchingRule`s._

_There is no special handling of <<derivative,`derivatives`>>._
_If a <<derivative>> is a terminal member variable then it is considered as normal member variable._
_However, if a <<derivative>> of a terminal member variable is not terminal member, then this <<derivative>> information may be used by an importing tool.]_

The predefined variable kinds are:
[cols="1,3",options="header"]
|====
|`variableKind`
|Description

[[signal,`signal`]]
|`signal`
|The values in connected terminals are intended to be equal.
Restricted to <<input>> and <<output>>, <<parameter>> and <<calculatedParameter>>.
_[Example: Signal flow, parameter propagation, equality checks]_

[[inoutflow,`inflow/outflow`]]
|`inflow` / `outflow`
|Variables which fulfill Kirchhoff's current law.
Restricted to <<input>> and <<output>>, <<parameter>> and <<calculatedParameter>>.
_[Example: Electric current]_
|====

====== General remark on signal

_[The signal `variableKind` can be applied for different use cases._
_The first use case is a signal flow from an <<output>> of one FMU to an <<input>> of another FMU. The <<output>> value has to be forwarded to the <<input>>._

_The signal flow can cause algebraic loops._
_If variables in connected terminals have the <<causality>> <<output>>, then an importing tool may iterate an undefined <<input>> of an FMU to ensure that the connected output values are equal._

_Another use case is the parameter propagation._
_If a variable in both connected terminals has the <<causality>> <<parameter>>, then an importing tool could ask the user for the value of one of those <<parameter,`parameters`>> only, and propagate this value to the other FMU._
_If only one of the variables has <<causality>> <<parameter>>, and the other is a <<constant>> <<output>> or <<calculatedParameter>>, then the importing tool could also propagate the <<parameter>> value without presenting a parameter to the user._
_One example of use would be the name of a substance flowing through a pipe._
_If the fluid flows from one pipe FMU to another, the substance should be the same._
_This substance name could be propagated over several FMUs._

_Finally the `variableKind` `signal` can be applied to implement compatibility checks._
_If for example the <<variability>> of the variables in connected terminals are <<constant>>, then the importing tool can implement an equality assertion._
_This is also possible with <<calculated>> <<parameter,`parameters`>>._
_One example of use would be the cross sectional flow area in pipes which is calculated from geometry parameters._
_A change in the cross sectional flow area is relevant for the momentum equation, and therefore the connection has to be deemed incompatible if these variables are present and unequal.]_

====== General remark on inflow and outflow

_[Flow variables have a direction and must fulfill a zero sum constraint i.e. the sum of all flow variables connected together must be zero (Kirchhoff's current law)._
_In addition because different tools might have different direction definitions both, `inflow` and `outflow` are available as `variableKind`._
_For variables with `inflow` a positive value means that the flow is inwards, and for `outflow` a positive value means that the flow is outwards._
_For the sake of simplicity in the following latexmath:[\dot{m}_i] denotes an inflowing quantity:_

_latexmath:[0 = \sum{\dot{m}_i}]_

_[Connecting a single <<output>> `outflow` to a single <<input>> `inflow`, or vice versa automatically fulfills the flow constraint, while connecting two single signals of the same flow type requires a negation of the signal._

_`inflow` and `outflow` is only used as a sign convention for scalar flow quantities which obey Kirchhoff's current law (sum up to zero)._
_Other, nonscalar, quantities which also sum up to zero, like a mechanical force in 3D space according to D'Alembert's principle, are not covered by this sign convention._
_This is the case since Kirchhoff's current law only holds for scalars where a sign convention is sufficient._
_Other definitions are beyond the scope of this terminal specification and need clear definition in other specifications on top of this.]_

====== Terminal Stream Member Variable

The `<TerminalStreamMemberVariable>` is defined as:

image::images/schema/TerminalStreamMemberVariable.png[width=80%, pdfwidth=60%, align="center"]

This element is used for variables which fulfill the balance equation for transported quantities.
It is restricted to <<input>> and <<output>>, <<parameter>> and <<calculatedParameter>>.

The Stream concept is described in the appendix D.3 of the Modelica specification.
Only one terminal member variable with the `variableKind` `inflow` or `outflow` per terminal is allowed, if a `<TerminalStreamMemberVariable>` is present.
_[More sophisticated structures can be implemented using hierarchical terminals.]_

The attribute `inStreamVariableName` and `outStreamVariableName` are used to identify the `<ModelVariables>`.
If the referenced model variables are arrays, then the size of the `inStreamVariableName` and `outStreamVariableName` has to be equal.
A terminal may have more than one `<TerminalStreamMemberVariable>`.
The `inStreamMemberName` and `outStreamMemberName` describe the terminal member name for matching purposes, similar to the `memberName` attribute in the `<TerminalMemberVariable>`.

_[An example of use for an array of stream variables is a gas mixture flow._
_The gas composition could be implemented as a mass fraction vector._
_The `outStreamVariableName` refers to_ latexmath:[portA.q_\textit{outStream}\textit{[\]}] _and the `inStreamVariableName` refers to_  latexmath:[portA.q_\textit{inStream}\textit{[\]}] _._
_The `inStreamMemberName` and `outStreamMemberName` are "_ latexmath:[q_\textit{inStream}\textit{[\]}] _" and "_ latexmath:[q_\textit{outStream}\textit{[\]}] _"._

_Balance equation for transported quantities:_

_latexmath:[0 = \sum{q_i\dot{m}_i}]_

_latexmath:[0 = \sum{\dot{m}_i}\cdot
\left\{\begin{array}{ll}
q_{\textit{$i$, outStream}} &\textit{if $\dot{m}$ is outflowing through terminal $i$}\\
q_{\textit{$i$, inStream}} &\textit{if $\dot{m}$ is inflowing through terminal $i$}
\end{array}\right.]_

_The_ latexmath:[q_\textit{$i$, outStream}] _is the convective quantity in case the matter flows out of the FMU._
latexmath:[q_\textit{$i$, inStream}] _is the convective quantity in case the matter flows into the FMU. Both variables are present in the terminal._
_The outStream variable has the <<causality>> <<output>> or <<calculatedParameter>> because this information has to be provided by each FMU._
_The inStream variable has the <<causality>> <<input>> or <<parameter>>._
_To display the actual value in an importing tool, this actual value has to be selected depending on the sign of the terminal member variable with `variableKind` `inflow` or `outflow`._
_However, calculating the actual value is not necessary._

_If only two terminals with a variable are connected and their <<causality>> matches, then the values of the outStream variables can be forwarded to the corresponding inStream values._

_In Modelica the inStream variable is not directly visible, the value can only be accessed using "inStream()", therefore an additional model variable has to be added during the export._
_It is suggested that Modelica tools exporting an FMU derive the member name for the inStream variable according to the scheme "<outStream name>_inStream"._
_E.g. if the outStream name is "h_outflow" then the inStream name should be "h_outflow_inStream".]_

====== Graphical Representation of Terminals

image::images/schema/TerminalGraphicalRepresentation.png[width=75%, pdfwidth=60%, align="center"]

The description of the general attributes can be found in <<graphicalRepresentation>>.
The `iconBaseName` attribute is mandatory.
This attribute defines the base name of the image file as a relative URI according to RFC 3986.
The base URI that this relative URI is resolved against is the URI of the `icon/terminalsAndIcons.xml` file in the FMU ZIP archive.
Implementations are only REQUIRED to support relative URIs, excluding relative URIs that move beyond the baseURI (i.e. go "up" a level via ..).
Implementations are NOT REQUIRED to support any absolute URIs and any specific URI schemes.
The PNG file with the extension '.png' has to be provided. An additional SVG file with extension '.svg' is optional.

_[Note that this specification is functionally equivalent to looking up image sources from the icon folder of the FMU ZIP archive after dot removal from the path as per section 5.2.4 of RFC 3986.]_

The default connection stroke size and color can be provided, to define the intended connection line layout in the importing tool. The stroke size is given relative to the coordinate system extent.
The stroke color is given in RGB values from 0 to 255. E.g.: `255 255 0`.

_[Nested terminals may have a `<GraphicalRepresentation>` element. However, if and how nested terminals are displayed, is up to the importing tool.]_

_[The order of painting of the `<GraphicalRepresentation>` of terminals on each level is equal to the order of appearance in the `<Terminal>` element. So graphical representations appearing first, are painted first, are behind graphical representations which appear below.]_

The `<VendorAnnotations>` element can be used by vendors to store additional information for the graphical representation.
_[It is suggested that Modelica tools store the Modelica annotation of the connector under the tool name `Modelica3Annotation` in the attribute `annotation` of an element `connector`._
_The attribute `name` of the connector element is equal to the `name` attribute of the referenced `fmi3Terminal`.]_

_[If the graphical representation is used for an <<input>> or <<output>> (e.g. a `fmi3Float64` <<input>> `u`), then a `<Terminal>` has to be added to the `<Terminals>` element which has one `<TerminalMemberVariable>`.]_

==== Definition of Vendor Annotations (VendorAnnotations)

Element `<fmiModelDescription><VendorAnnotations>` is defined as:

image::images/schema/VendorAnnotations.png[width=80%, align="center"]

`<VendorAnnotations>` consist of an ordered set of annotations that are identified by the name of the tool that can interpret the `any` element.
The `any` element can be an arbitrary XML data structure defined by the tool.
The attribute `name` must be unique with respect to all other elements of the `<VendorAnnotations>` list.

==== Definition of Model Variables (ModelVariables) [[definition-of-model-variables]]

The element of `<fmiModelDescription><ModelVariables>` is the central part of the model description.
It provides the static information of all exposed variables and is defined as follows.

image::images/schema/ModelVariables.png[width=60%, align="center"]

The `<ModelVariables>` element consists of an ordered set of variable elements (see figure above).
Variable elements can uniformly represent variables of primitive (atomic) types, like single floating point or integer variables, or as well as arrays of an arbitrary (but fixed) number of dimensions. The schema definition is present in a separate file `fmi3Variable.xsd`.

Variable elements representing array variables must contain at least one `<Dimension>` element.
Each `<Dimension>` element specifies the size of one dimension of the array:

- If the <<start>> attribute of the `<Dimension>` element is present, it defines a constant unsigned 64-bit integer size for this dimension.
The <<variability>> of the dimension size is <<constant>> in this case.

- If the <<valueReference>> attribute of the `<Dimension>` element is present, it defines the size of this dimension to be the value of the variable with the value reference given by the <<valueReference>> attribute.
The referenced variable must be a variable of type `<UInt64>`, and must either be a constant (i.e. with <<variability>> = <<constant>>) or a <<structuralParameter,`structural parameter`>>(i.e. with <<causality>> = <<structuralParameter>>).
The <<variability>> of the dimension size is in this case the <<variability>> of the referenced variable.

These two options are mutually exclusive, i.e. for each `<Dimension>` element either a <<start>> attribute or an <<valueReference>> attribute can be supplied, but not both.
However different dimension sizes can be specified using different mechanisms and can have differing <<variability>> attributes.

All initial dimension sizes (i.e. prior to any configuration or reconfiguration) must be positive integers (i.e. not zero), so that no dimension is initially vanished.
Changes to dimension sizes are constrained by the `min`/`max` attributes of the referenced <<structuralParameter,`structural parameters`>>, which can be any non-negative integer, including zero.
Specifying a minimum size of zero on a <<structuralParameter,`structural parameter`>>allows any related dimension sizes to be changed to zero in *Configuration Mode* or *Reconfiguration Mode*, thus causing the respective array size to go to zero, which leaves the respective array variable without any active elements.

The actual dimension sizes of arrays are also constrained by the FMU platform, due to memory and addressing constraints:
Since the API functions to access variables and their values are constrained to `size_t` individual elements, platforms with addresses of less than 64-bit width will not be able to access elements beyond their addressing limits, neither will they be able to allocate enough memory or address space to represent such arrays.
For these reasons implementations must take platform-specific constraints into account when changing dimension sizes, and must be prepared to handle the inability of the FMU to adjust to the desired sizes during *Configuration Mode* or *Reconfiguration Mode*.

Changing any dimension of a variable in *Configuration Mode* or *Reconfiguration Mode* invalidates the variable's current value (including its <<start>> value).
It should be noted that changing a <<structuralParameter,`structural parameter`>> might affect dimension sizes of several variables.

A variable can have any number of `<Alias>` elements that define a variable alias.
Each variable alias has a required attribute `name` whose value must be unique among all variables and variable aliases, and an optional attribute `description`.
Variable aliases of floating point variables may additionally have a <<displayUnit>> that follows the same rules as for variables.

Example:

[source, xml]
----
include::examples/alias_example.xml[tags=VariableAliases]
----

The attributes of variables are:

image::images/schema/fmi3VariableBase.png[width=80%, align="center"]

[cols="1,5a",options="header"]
|====
|Attribute
|Description

|`name`
|The full, unique name of the variable.
Every variable is uniquely identified within an FMU instance by this name.

|`valueReference`
|
[[valueReference,`valueReference`]]
A handle of the variable to efficiently identify the variable value in the model interface and for references within the `modelDescription.xml`.
This handle is a secret of the tool that generated the C functions.
It is required to be unique for an FMU.
This attribute is `required`.

|`description`
|An optional description string describing the meaning of the variable.

|`causality`
|
[[causality,`causality`]]
Enumeration that defines the causality of the variable.
Allowed values of this enumeration:

[[parameter,`parameter`]]
- `parameter`: independent parameter (a data value that is constant during the simulation and is provided by the environment and cannot be used in connections).
<<variability>> must be <<fixed>> or <<tunable>>.
<<initial>> must be <<exact>> or not present (meaning <<exact>>).

[[calculatedParameter,`calculatedParameter`]]
- `calculatedParameter`: A data value that is constant during the simulation and is computed during initialization or when <<tunable>> <<parameter,`parameters`>> change.
<<variability>> must be <<fixed>> or <<tunable>>.
<<initial>> must be <<approx>>, <<calculated>> or not present (meaning <<calculated>>).

[[input,`input`]]
- `input`: The variable value can be provided from another model or slave.
It is not allowed to define <<initial>>.

[[output,`output`]]
- `output`: The variable value can be used by another model or slave.
The algebraic relationship to the <<input,`inputs`>> is defined via the <<dependencies>> attribute of `<fmiModelDescription><ModelStructure><Output>`.

[[local,`local`]]
- `local`: Local variable that is calculated from other variables or is a continuous-time <<state>> or an event indicator (see <<ModelStructure>>).
It is not allowed to use the variable value in another model or slave.

[[independent,`independent`]]
- `independent`: The independent variable (usually `time`).
All variables are a function of this <<independent>> variable.
<<variability>> must be <<continuous>>.
At most one variable of an FMU can be defined as <<independent>>.
If no variable is defined as <<independent>>, it is implicitly present with `name = time` and `unit = s`.
If one variable is defined as <<independent>>, it must be defined with a floating point type without a <<start>> attribute.
It is not allowed to call function `fmi3Set{VariableType}` on an <<independent>> variable.
Instead, its value is initialized with <<fmi3EnterInitializationMode>> and after initialization set by <<fmi3SetTime>> for Model Exchange and by arguments `currentCommunicationPoint` and `communicationStepSize` of <<fmi3DoStep>> for Co-Simulation FMUs.
_[The actual value can be inquired with `fmi3Get{VariableType}`.]_

[[structuralParameter,`structuralParameter`]]
- `structuralParameter`: parameter (a data value that is constant during the simulation and is provided by the environment and cannot be used in connections). <<variability>> must be <<fixed>> or <<tunable>>. <<initial>> must be <<exact>> or not present (meaning <<exact>>).
This <<causality>> requires the variable not to have a `<Dimension>` element.

_[_
_Example:_

// TODO: include example from XML AND remove change Variable into an existing element type
[source, XML]
----
<Variable name="spD" valueReference="126" causality="structuralParameter" variability="fixed">
  <Integer start="3"/>
</Variable>
----

_]_

<<structuralParameter,`structural parameters`>> that are referenced in `<Dimension>` elements may have a `min` attribute with 0 but the <<start>> attribute, which is mandatory for <<structuralParameter,`structural parameters`>>, must have a value larger than 0 for <<structuralParameter,`structural parameters`>> used in `<Dimension>` elements. _[This allows importing tools to ignore <<structuralParameter,`structural parameters`>> because that <<start>> value reflects the internal default setting of that <<structuralParameter,`structural parameter`>>]_.

[[inputClock,`input clock`]]
- `input`: the variable defines an <<inputClock>> that is controlled by the master.
Variability must be <<clock>>.
Only a variable of type `<Clock>` can have this <<causality>>.

[[outputClock,`output clock`]]
- `output`: the variable defines an <<outputClock>> that is controlled by the FMU.
Variability must be <<clock>>.
Only a variable of type `<Clock>` can have this <<causality>>.

The default of <<causality>> is <<local>>. +
A continuous-time <<state>> or a event indicator must have <<causality>> = <<local>> or <<output>>, see also <<ModelStructure>>.

_[<<causality>> = <<calculatedParameter>> and <<causality>> = <<local>> with <<variability>> = <<fixed>> or <<tunable>> are similar._
_The difference is that a <<calculatedParameter>> can be used in another model or slave, whereas a <<local>> variable cannot._
_For example, when importing an FMU in a Modelica environment, a <<calculatedParameter>> should be imported in a `public` section as `final parameter`, whereas a <<local>> variable should be imported in a `protected` section of the model.]_

|`variability`
|
[[variability,`variability`]]
Enumeration that defines the time dependency of the variable, in other words, it defines the time instants when a variable can change its value.
_[The purpose of this attribute is to define when a result value needs to be inquired and to be stored._
_For example, <<discrete>> variables change their values only at event instants (ME) or at a communication point (xCS) and it is therefore only necessary to inquire them with `fmi3Get{VariableType}` and store them at event times.]_
Allowed values of this enumeration:

[[constant,`constant`]]
- `constant`: The value of the variable never changes.

[[fixed,`fixed`]]
- `fixed`: The value of the variable is fixed after initialization, in other words, after <<fmi3ExitInitializationMode>> was called the variable value does not change anymore.

[[tunable,`tunable`]]
- `tunable`: The value of the variable is constant between external events (ME) and between communication points (xCS) due to changing variables with <<causality>> = <<parameter>> or <<input>> and <<variability>> = <<tunable>>.
Whenever a <<parameter>> or <<input>> signal with <<variability>> = <<tunable>> changes, an event is triggered externally (ME), or the change is performed at the next communication point (xCS) and the variables with <<variability>> = <<tunable>> and <<causality>> = <<calculatedParameter>> or <<output>> must be newly computed.

[[discrete,`discrete`]]
- `discrete`: +
Model Exchange: The value of the variable is constant between external and internal events (= time, state, step events defined implicitly in the FMU). +
Co-Simulation: By convention, the variable is from a real sampled data system and its value is only changed at communication points (also inside the slave).
// TODO how does this work with IVA?

[[continuous,`continuous`]]
- `continuous`: Only a variable of `type = fmi3GetFloat32` or `type = fmi3GetFloat64` can be <<continuous>>. +
Model Exchange: No restrictions on value changes. +
Co-Simulation: By convention, the variable is part of a differential equation.

[[clock,`clock`]]
- `clock`: Only a variable of type `<Clock>` can have this variability.

The default is <<continuous>> for variables of type `<Float32>` and `<Float64>`, and <<discrete>> for all other types.

_[Note that the information about continuous <<state,`states`>> is defined with elements `<ModelStructure><Derivative>`.]_

|`initial`
|
[[initial,`initial`]]
Enumeration that defines how the variable is initialized.
It is not allowed to provide a value for <<initial>> if <<causality>> = <<input>> or <<independent>>:

[[exact,`exact`]]
- = `exact`: The variable is initialized with the <<start>> value (provided under the variable type element).

[[approx,`approx`]]
- = `approx`: The variable is an iteration variable of an algebraic loop and the iteration at initialization starts with the <<start>> value.

[[calculated,`calculated`]]
- = `calculated`: The variable is calculated from other variables during initialization.
It is not allowed to provide a <<start>> value.

If <<initial>> is not present, it is defined by the table below based on <<causality>> and <<variability>>.
If <<initial>> = <<exact>> or <<approx>>, or <<causality>> = <<input>>, a <<start>> value must be provided.
If <<initial>> = <<calculated>>, or <<causality>> = <<independent>>, it is not allowed to provide a <<start>> value.

_[The environment decides when to use the <<start>> value of a variable with <<causality>> = <<input>>.
Examples: (a) automatic tests of FMUs are performed, and the FMU is tested by providing the <<start>> value as <<constant>> <<input>>.
(b) For a Model Exchange FMU, the FMU might be part of an algebraic loop.
If the <<input>> variable is iteration variable of this algebraic loop, then initialization starts with its <<start>> value.]_

If <<causality>> = <<input>> the value for <<initial>> has to be set to <<exact>> and it is required to provide a <<start>> value for describing the expected initial contidion of master <<clock,`clocks`>> for that FMU.
If an <<inputClock>> has `fmi3True` as an <<start>> value the master should activate the <<clock>> the first time it enters *Event Mode*.
The master can nevertheless choose different <<start>> values if it is not possible to fulfill the conditions in a simulation setup.

If <<causality>> = <<output>> the <<initial>> attribute value is set to <<calculated>> and no <<start>> value is provided.

If `fmi3Set{VariableType}` is not called on a variable with <<causality>> = <<input>>, then the FMU must use the <<start>> value as value of this <<input>>.

|`canHandleMultipleSetPerTimeInstant`
|
[[canHandleMultipleSetPerTimeInstant,`canHandleMultipleSetPerTimeInstant`]]
Only for Model Exchange (if only a Co-Simulation FMU, this attribute must not be present.
If both Model Exchange and Co-Simulation FMU, this attribute is ignored for co-simulation): +
Only for variables with <<variability>> = <<input>> : +
If present with value equals `false`, then only one `fmi3Set{VariableType}` call is allowed at one super-dense time instant (model evaluation) on this variable.
That is, this <<input>> is not allowed to appear in a (real) algebraic loop requiring multiple calls of `fmi3Set{VariableType}` on this variable _[for example, due to a Newton iteration]_. +
_[This flag must be set by FMUs where (internal) discrete-time <<state,`states`>> are directly updated when assigned (xd := f(xd) instead of xd = f(previous(xd)), and at least one <<output>> depends on this <<input>> and on discrete <<state,`states`>>._ +
_It is strongly recommended that such an FMU checks the fulfillment of the requirement by itself during run-time, because an environment might not be able to check it; usually, there is a generic mechanism to import an FMU in an environment, but the mechanism to connect FMUs together is unrelated to the import mechanism._
_For example, there is no mechanism in the Modelica language to formulate connection restrictions for C functions (the FMU) called in a Modelica model.]_


|`clockReference`
|
[[clockReference,`clockReference`]]
The optional attribute <<clockReference>> is used, in conjunction with the <<clockElementIndex>> attribute, to define the <<clock,`clocks`>> this variable is assigned to.
This attribute can be used in all variable sub types with restrictions based on the `clockType`  attribute.
The <<clockReference>> holds only <<valueReference>> information for variables with base type `fmi3Clock`.

Clock (`clockType = STClock`): If present, the variable is a clocked variable associated uniquely with the <<clock>> referenced by <<valueReference>> and defined in element `<ModelVariables>`.
It is not possible to associate more than one <<clock>> to a variable.

Communication Point Clock (`clockType = communicationPoint`): If present, the variable is associated with the <<clock>> referenced by <<valueReference>> and defined in element `<ModelVariables>`.
It is possible to associate multiple <<clock,`clocks`>> to a variable.
Variables that are assigned to a Communication Point Clock are not necessarily `clocked` in the sense of synchronous time clock theory. Such variables can also be continuous-time or discrete-time variables.

If <<outputClock,`output clocks`>> and <<inputClock,`input clocks`>> of `clockType = communicationPoint` are defined in the `modelDescription.xml` it is possible to define a tick relationship from a <<outputClock>> to an aperiodic <<inputClock>> based on <<clockReference>> (<<clock-relationships-for-communication-point-clocks>>).
This is done for aperiodic <<inputClock,`input clocks`>> that have the `clockType = communicationPoint` via providing a list of <<valueReference>> of <<outputClock,`output clocks`>> of the same FMU.
If a <<outputClock>> of this <<valueReference>> list ticks the master has to create a tick for the associated aperiodic <<inputClock>> at the same time instant.
It is not allowed to combine <<outputClock,`output clocks`>> with periodic or strict periodic <<inputClock,`input clocks`>> based on <<clockReference>>.

The attribute <<clockReference>> must not be used if <<causality>> = <<output>> for a variable.

|`clockElementIndex`
|
[[clockElementIndex,`clockElementIndex`]]
The optional attribute <<clockElementIndex>> is used in conjuction with the <<clockReference>> attribute to define the element index of the <<clock,`clocks`>> this variable is assigned to for array clock variables.
The element index is the 1-based index of the element (with serialization of indices for multi-dimensional arrays in the usual row-major order).
For scalar clock variables this attribute must not be specified or must be specified as 0.

|`intermediateAccess`
|
[[intermediateAccess,`intermediateAccess`]]
If this boolean attribute is `true`, the variable can be accessed during a communication step.
Variables with <<causality>> <<parameter>> must not be marked with <<intermediateAccess,`intermediateAccess = fmi3True`>>.
// TODO: link to see math-intermediate-variable-access)
This attribute is only used for Basic Co-Simulation and Hybrid Co-Simulation. The default value of this attribute is `false`.
// TODO: default false is not defined in the xsd (yet?)
|====

*fmi3Set{VariableType}* can be called on any variable with <<variability>> latexmath:[\neq] <<constant>> *before initialization* (before calling <<fmi3EnterInitializationMode>>)

- if <<initial>> = <<exact>> or <<approx>> _[in order to set the corresponding <<start>> value.]_
_[Note that this prevents any changes to the input before <<fmi3EnterInitializationMode>> is called.]_

*fmi3Set{VariableType}* can be called on any variable with <<variability>> latexmath:[\neq] <<constant>> *during initialization* (after calling <<fmi3EnterInitializationMode>> and before <<fmi3ExitInitializationMode>> is called)

- if <<initial>> = <<exact>> _[in order to set the corresponding <<start>> value]_, or

- if <<causality>> = <<input>> _[in order to provide new values for <<input,`inputs`>>]_,

// TODO: Check the following for Co-Simulation, i.e. IVA?
*fmi3Set{VariableType}* can be called on any variable for *Model Exchange at an event instant* (after calling <<fmi3EnterEventMode>> and before <<fmi3EnterContinuousTimeMode>> is called), and *for Co-Simulation at every communication point*,

- if <<causality>> = <<parameter>> and <<variability>> = <<tunable>> _[in order to change the value of the <<tunable>> <<parameter>> at an event instant or at a communication point]_, or

- if <<causality>> = <<input>> _[in order to provide new values for <<input,`inputs`>>]_

*fmi3Set{VariableType}* can be called on any variable for *Model Exchange in Continuous-Time Mode*

- if <<causality>> = <<input>> and <<variability>> = <<continuous>> +
_[in order to provide new values for <<input,`inputs`>> during continuous integration]_

If <<initial>> is not present, its value is defined by the following tables based on the values of <<causality>> and <<variability>>:

[cols="1,1,1,1,1,1,1,1,1,1,1,1"]
|====
3.2+|
9+^|<<causality>>
^|<<structuralParameter>>
^|<<parameter>>
^|<<calculatedParameter>>
^|<<input>>
^|<<output>>
^|<<local>>
^|<<independent>>
^|<<input>>
^|<<output>>

.7+^|<<variability>>
.3+^|data
^|<<constant>>
^|[green]#(A) or --#
^|[red]#--#
^|[red]#--#
^|[red]#--#
^|[green]#(A)#
^|[green]#(A)#
^|[red]#--#
^|[red]#--#
^|[red]#--#

^|<<fixed>>
^|[green]#(A)#
^|[green]#(A)#
^|[maroon]#(B)#
^|[red]#--#
^|[red]#--#
^|[maroon]#(B)#
^|[red]#--#
^|[red]#--#
^|[red]#--#

^|<<tunable>>
^|[green]#(A)#
^|[green]#(A)#
^|[maroon]#(B)#
^|[red]#--#
^|[red]#--#
^|[maroon]#(B)#
^|[red]#--#
^|[red]#--#
^|[red]#--#

.2+^|signals
^|<<discrete>>
^|[red]#--#
^|[red]#--#
^|[red]#--#
^|[aqua]#(D)#
^|\(C)
^|\(C)
^|[red]#--#
^|[red]#--#
^|[red]#--#

^|<<continuous>>
^|[red]#--#
^|[red]#--#
^|[red]#--#
^|[aqua]#(D)#
^|\(C)
^|\(C)
^|[purple]#(E)#
^|[red]#--#
^|[red]#--#

1+^|<<clock,`clocks`>>
^|<<clock>>
^|[red]#--#
^|[red]#--#
^|[red]#--#
^|[red]#--#
^|[red]#--#
^|[red]#--#
^|[red]#--#
^|[brown]#(F)#
^|[brown]#(G)#
|====

with

[cols="1,3,3", width=50%, align="center"]
|====
|
2+^|<<initial>>
|
^|default
^|possible values

|[green]#(A)#
|[green]#exact#
|[green]#exact#

|[maroon]#(B)#
|[maroon]#calculated#
|[maroon]#approx,# +
 [maroon]#calculated#

|\(C)
|<<calculated>>
|<<exact>>, +
<<approx>>, +
<<calculated>>

|[aqua]#(D)#
|[aqua]#---#
|[aqua]#---#

|[purple]#(E)#
|[purple]#---#
|[purple]#---#

|[brown]#(F)#
|[brown]#exact#
|[brown]#exact#

|[brown]#(G)#
|[brown]#calculated#
|[brown]#calculated#
|====

_[Note: (1) If <<causality>> = <<independent>>, it is neither allowed to define a value for <<initial>> nor a value for start._
_(2) If <<causality>> = <<input>>, it is not allowed to define a value for <<initial>> and a value for <<start>> must be defined._
_(3) If \(C) and <<initial>> = <<exact>>, then the variable is explicitly defined by its <<start>> value in *Initialization Mode* (so directly after calling <<fmi3ExitInitializationMode>>, the value of the variable is either the <<start>> value stored in a variable element `<XXX start=YYY/>` or the value provided by `fmi3Set{VariableType}`, if this function was called on this variable).]_

The following combinations of <<variability>>/<<causality>> settings are allowed:

[cols="1,1,1,1,1,1,1,1,1,1,1,1"]
|====
3.2+|
9+^|<<causality>>
^|<<structuralParameter>>
^|<<parameter>>
^|<<calculatedParameter>>
^|<<input>>
^|<<output>>
^|<<local>>
^|<<independent>>
^|<<input>>
^|<<output>>

.6+^|<<variability>>
.3+^|data
^|<<constant>>
^|[red]#--#
^|[red]#-- (a)#
^|[red]#-- (a)#
^|[red]#-- (a)#
^|[green]#(7)#
^|[green]#(10)#
^|[red]#-- (c)#
^|[red]#--#
^|[red]#--#

^|<<fixed>>
^|[green]#(16)#
^|[green]#(1)#
^|[green]#(3)#
^|[red]#-- (d)#
^|[red]#-- (e)#
^|[green]#(11)#
^|[red]#-- (c)#
^|[red]#--#
^|[red]#--#

^|<<tunable>>
^|[green]#(17)#
^|[green]#(2)#
^|[green]#(4)#
^|[red]#-- (d)#
^|[red]#-- (e)#
^|[green]#(12)#
^|[red]#-- (c)#
^|[red]#--#
^|[red]#--#

.2+^|signals
^|<<discrete>>
^|[red]#-- (b)#
^|[red]#-- (b)#
^|[red]#-- (b)#
^|[green]#(5)#
^|[green]#(8)#
^|[green]#(13)#
^|[red]#--(c)#
^|[red]#--#
^|[red]#--#

^|<<continuous>>
^|[red]#-- (b)#
^|[red]#-- (b)#
^|[red]#-- (b)#
^|[green]#(6)#
^|[green]#(9)#
^|[green]#(14)#
^|[green]#(15)#
^|[red]#--#
^|[red]#--#

.1+^|clocks
^|<<clock>>
^|[red]#--#
^|[red]#--#
^|[red]#--#
^|[red]#--#
^|[red]#--#
^|[red]#--#
^|[red]#--#
^|[red]#18#
^|[red]#18#
|====

_[Discussion of the combinations that are not allowed:_

[cols="1,10"]
|====
|
|_Explanation why this combination is not allowed_

^|_[red]#(a)#_
|_The combinations <<constant>> / <<parameter>>, <<constant>> / <<calculatedParameter>> and <<constant>> / <<input>> do not make sense, since <<parameter,`parameters`>> and <<input,`inputs`>> are set from the environment, whereas a constant has always a value._

^|_[red]#(b)#_
|_The combinations <<discrete>> / <<structuralParameter>>, <<discrete>> / <<parameter>>, <<discrete>> / <<calculatedParameter>> , <<continuous>> / <<structuralParameter>>, <<continuous>> / <<parameter>> and <<continuous>> / <<calculatedParameter>> do not make sense, since <<causality>> = <<structuralParameter>>, <<causality>> = <<parameter>> and <<calculatedParameter>> define variables that do not depend on time, whereas <<discrete>> and <<continuous>> define variables where the values can change during simulation._

^|_[red]#(c)#_
|_For an <<independent>> variable only <<variability>> = <<continuous>> makes sense._

^|_[red]#(d)#_
|_A <<fixed>> or <<tunable>> <<input>> has exactly the same properties as a <<fixed>> or <<tunable>> <<parameter>>._
_For simplicity, only <<fixed>> and <<tunable>> <<parameter,`parameters`>> shall be defined._

^|_[red]#(e)#_
|_A <<fixed>> or <<tunable>> <<output>> has exactly the same properties as a <<fixed>> or <<tunable>> <<calculatedParameter>>._
_For simplicity, only <<fixed>> and <<tunable>> <<calculatedParameter,`calculatedParameters`>> shall be defined._
|====

_Discussion of the combinations that are allowed_:

[cols="1,3,8", options="header"]
|====
|
|_Setting_
|_Example_

>|_[green]#(1)#_
|_<<fixed>> <<parameter>>_
|_Non-<<tunable>> <<independent>> <<parameter>>_

>|_[green]#(2)#_
|_<<tunable>> <<parameter>>_
|_<<tunable,`Tunable`>> <<independent>> <<parameter>> (changing such a <<parameter>> triggers an external event (ME) or takes effect at the next communication point (xCS), and <<tunable>> <<calculatedParameter>>/<<output>>/<<local>> variables might change their values)._

>|_[green]#(3)#_
|_<<fixed>> <<dependenciesKind,`dependent`>> <<parameter>>_
|_Non-<<tunable>> <<dependenciesKind,`dependent`>> <<parameter>> (variable that is computed directly or indirectly from constants or <<parameter,`parameters`>>)._

>|_[green]#(4)#_
|_<<tunable>> <<dependenciesKind,`dependent`>> <<parameter>>_
|_<<tunable,`Tunable`>> <<dependenciesKind,`dependent`>> <<parameter>> (changing an <<independent>> <<parameter>> triggers an external event (ME) or takes effect at the next communication point (xCS), and <<tunable>> <<dependenciesKind,`dependent`>> <<parameter,`parameters`>> and <<tunable>> <<local>> variables might change their values)._

>|_[green]#(5)#_
|_<<discrete>> <<input>>_
|_<<discrete,`Discrete`>> <<input>> variable from another model._

>|_[green]#(6)#_
|_<<continuous>> <<input>>_
|_<<continuous,`Continuous`>> <<input>> variable from another model._

>|_[green]#(7)#_
|_<<constant>> <<output>>_
|_Variable where the value never changes and that can be used in another model._

>|_[green]#(8)#_
|_<<discrete>> <<output>>_
|_<<discrete,`Discrete`>> variable that is computed in the FMU._
_Can be used in another model._

>|_[green]#(9)#_
|_<<continuous>> <<output>>_
|_<<continuous,`Continuous`>> variable that is computed in the FMU and can be used in another model._

>|_[green]#(10)#_
|_<<constant>> <<local>>_
|_Variable where the value never changes._
_Cannot be used in another model._

>|_[green]#(11)#_
|_<<fixed>> <<local>>_
|_Local variable that depends on <<fixed>> <<parameter,`parameters`>> only and is computed in the FMU._
_Cannot be used in another model._
_After initialization, the value of this <<local>> variable cannot change._

>|_[green]#(12)#_
|_<<tunable>> <<local>>_
|_Local variable that depends on <<tunable>> <<parameter,`parameters`>> only and is computed in the FMU._
_Cannot be used in another model._
_The value of this <<local>> variable can only change during initialization and at event instants, provided a <<tunable>> <<parameter>> was changed._

>|_[green]#(13)#_
|_<<discrete>> <<local>>_
|_<<discrete,`Discrete`>> variable that is computed in the FMU and cannot be used in another model._

>|_[green]#(14)#_
|_<<continuous>> <<local>>_
|_<<continuous,`Continous`>> variable that is computed in the FMU and cannot be used in another model._

>|_[green]#(15)#_
|_<<continuous>> <<independent>>_
|_All variables are a function of the continuous-time variable marked as <<independent>>._
_Usually, this is `time`._

>|_[green]#(16)#_
|_<<fixed>> <<structuralParameter>>_
|_<<parameter,`Paramter`>> used in  `<Dimension>` element;  can be changed before initialization in *Configuration Mode*._

>|_[green]#(17)#_
|_<<tunable>> <<structuralParameter>>_
|_<<parameter,`Parameter`>> used in  `<Dimension>` element;  can be changed before initialization in *Configuration Mode* and in *Reconfiguration Mode*._

>|_[green]#(18)#_
|_<<clock>>_
|_Variable that defines a <<clock>>_
|====

_How to treat <<tunable>> variables:_

_A <<parameter>> p is a variable that does not change its value during simulation, in other words, dp/dt = 0._
_If the <<parameter>> p is changing, then Dirac impulses are introduced since dp/dt of a discontinuous <<constant>> variable `p` is a Dirac impulse._
_Even if this Dirac impulse would be modeled correctly by the modeling environment, it would introduce unwanted `vibrations`._
_Furthermore, in many cases the model equations are derived under the assumption of a <<constant>> value (like mass or capacity), and the model equations would be different if `p` would be time varying._

_FMI for Model Exchange:_ +
_Therefore, "tuning a (structural) <<parameter>>" during simulation does not mean to "change the parameter online" during simulation._
_Instead, this is a short hand notation for:_

. _Stop the simulation at an event instant (usually, a step event, in other words, after a successful integration step)._

. _Change the values of the <<tunable>> (structural) <<parameter,`parameters`>>. For <<tunable>> <<structuralParameter,`structural parameters`>>, the *Reconfiguration Mode* must be entered before and left afterwards._

. _Compute all <<parameter,`parameters`>> (and sizes of variables, <<state,`states`>>, <<derivative,`derivatives`>>, event indicators, ...) that depend on the <<tunable>> (structural) <<parameter,`parameters`>>._

. _Newly start the simulation using as initial values previously stored values and the new values of the <<parameter,`parameters`>>._

_Basically this means that a new simulation run is started from the previous FMU state with changed <<parameter>> values._
_With this interpretation, changing <<parameter,`parameters`>> online is "clean", as long as these changes appear at an event instant._

_FMI for Basic Co-Simulation and FMI for Hybrid Co-Simulation:_
_Changing of <<tunable>> <<parameter,`parameters`>> is allowed before an <<fmi3DoStep>> call (so, whenever an <<input>> can be set with `fmi3Set{VariableType}`) and before <<fmi3ExitInitializationMode>> is called (that is before and during *Initialization Mode*)._
_The FMU internally carries out event handling if necessary.]_

Type specific properties are defined in the required choice element, where exactly one of the numeric types or an `<Enumeration>` must be present in the XML file:
The following are representative examples:

image::images/schema/Variable_Float64.png[width=70%, align="center"]

image::images/schema/Variable_Int32.png[width=70%, align="center"]

image::images/schema/Variable_Boolean.png[width=70%, align="center"]

image::images/schema/Variable_Binary.png[width=70%, align="center"]

image::images/schema/Variable_Enumeration.png[width=70%, align="center"]

The attributes are defined in <<definition-of-types>> (`<TypeDefinitions>`), except:

[cols="1,7a", options="header"]
|====
|Attribute
|Description

|`declaredType`
|If present, name of type defined with `<TypeDefinitions><TypeDefinition>`.
The value defined in the corresponding `<TypeDefinition>` (see <<definition-of-types>>) is used as default.
_[For example, if `min` is present both in variable type element of `<TypeDefinition>` and in the concrete variable type element of the variable, then the `min` of the variable is actually used.]_
For numeric types and `<String>`, this attribute is optional.
For `<Enumeration>` it is required, because the `<Enumeration>` items are defined in `<TypeDefinitions><TypeDefinition>`.


|`start`
|
[[start,`start`]]
Initial or guess value of variable.
This value is also stored in the C functions.
_[Therefore, calling_ `fmi3Set{VariableType}` _to set <<start>> values is only necessary, if a different value as stored in the XML file is desired._
_It is not allowed to change the start values in the `modelDescription.xml` file of an FMU, as this would break the consistency with the hard-coded start values in the C-Code._
_This could lead to unpredictable behavior of the FMU in different importing tools, as it is not mandatory to call `fmi3Set{VariableType}` to set start values during initialization._
_Instead it is recommended to use the SSP Standard (https://ssp-standard.org/) to handle modified parameters of FMUs or different parameter sets.]_

The interpretation of <<start>> is defined by variable attribute <<initial>>.
A different <<start>> value can be provided with an `fmi3Set{VariableType}` function before <<fmi3ExitInitializationMode>> is called (but not for variables with <<variability>> = <<constant>>).

_[The standard approach is to set the <<start>> value before <<fmi3EnterInitializationMode>>._
_However, if the initialization shall be modified in the calling environment (for example, changing from initialization of states to steady-state initialization), it is also possible to use the <<start>> value as iteration variable of an algebraic loop: using an additional condition in the environment, such as_ latexmath:[\color{blue}{\dot{x} = 0}] _, the actual <<start>> value is determined.]_

If <<initial>> = <<exact>> or <<approx>> or <<causality>> = <<input>>, a <<start>> value must be provided.

If <<initial>> = <<calculated>> or <<causality>> = <<independent>>, it is not allowed to provide a <<start>> value.

Variables with <<causality>> = <<parameter>> or <<input>>, as well as variables with <<variability>> = <<constant>>, must have a <<start>> value.

- If <<causality>> = <<parameter>>, the <<start>> value is the value of it.

- If <<causality>> = <<input>>, the <<start>> value is used by the model as value of the <<input>>, if the <<input>> is not set by the environment.

- If <<variability>> = <<constant>>, the <<start>> value is the value of the constant.

- If <<causality>> = <<output>> or <<local>>, then the <<start>> value is either an <<initial>> or a `guess` value, depending on the setting of attribute <<initial>>.

|`derivative`
|
[[derivative,`derivative`]]
If present, this variable is the derivative of variable with value reference `derivative`.
_[For example, if there are 10 variables and `derivative = 3` for variable 8, then variable 8 is the derivative of variable 3 with respect to the <<independent>> variable (usually time)._
_This information might be especially used if an <<input>> or an <<output>> is the derivative of another <<input>> or <<output>>, or to define the <<state,`states`>>.]_

The <<state>> <<derivative,`derivatives`>> of an FMU are listed as elements `<ModelStructure><Derivative>`.
All variables listed in this element must have attribute `derivative` (in order that the continuous-time <<state,`states`>> are uniquely defined).

|`reinit`
|Only for Model Exchange (if only a Co-Simulation FMU, this attribute must not be present.
If both Model Exchange and a Co-Simulation FMU, this attribute is ignored for co-simulation): +
Can only be present for a continuous-time <<state>>. +
If `true`, <<state>> can be reinitialized at an event by the FMU. +
If `false`, <<state>> will not be reinitialized at an event by the FMU.

|`min / max`
|The optional attributes `min` and `max` in element `<Enumeration>` restrict the allowed values of the enumeration.
The `min/max` definitions are information from the FMU to the environment defining the region in which the FMU is designed to operate, see also comment in <<definition-of-types>>.
_[If, for example, an `<Enumeration>` is defined with `name1 = -4`, `name2 = 1`, `name3 = 5`, `name4 = 11` and `min = -2`, `max = 5`, then only `name2` and `name3` are allowed.]_
|====

With element `<Annotations>` additional, tool specific data can be defined:

image::images/schema/Annotations.png[width=80%]

With the attribute `name` of `<Tool>` the name of the tool is defined that can interpret the `any` element.
The `any` element can be an arbitrary XML data structure defined by the tool.
_[Typically, additional data is defined here how to build up the menu for the variable, including the graphical layout and enabling/disabling an input field based on the values of other <<parameter,`parameters`>>.]_
The attribute `name` must be unique with respect to all other elements of the `<Annotations>` list.

==== Definition of the Model Structure (ModelStructure) [[ModelStructure]]

The structure of the model is defined in element `<fmiModelDescription><ModelStructure>`.
This structure is with respect to the underlying model equations, independently how these model equations are solved.
_[For example, when exporting a model in more than one FMI format; then the model structure is identical in all cases._
_E.g. a Basic Co-Simulation FMU has either an integrator included that solves the model equations, or the discretization formula of the integrator and the model equations are solved together ("inline integration")._
_In all cases the model has the same continuous-time <<state,`states`>>._
_In the case of a Model-Exchange FMU, the internal implementation is a discrete-time system, but from the outside this is still a continuous-time model that is solved with an integration method.]_

The required part defines an ordering of the <<output,`outputs`>>, the (exposed) <<derivative,`derivatives`>>, the event indicators, and the unknowns that are available during Initialization _[Therefore, when linearizing an FMU, every tool will use the same ordering for the <<output,`outputs`>>, <<state,`states`>>, and <<derivative,`derivatives`>> for the linearized model.
The ordering of the <<input,`inputs`>> should be performed in this case according to the ordering in `<ModelVariables>`.]_
A Model Exchange FMU must expose all <<derivative,`derivatives`>> of its continuous-time <<state,`states`>> in elements `<ModelStructure><Derivative>` and must expose all event indicators in elements `<EventIndicator>`.
A Co-Simulation FMU does not need to expose these state derivatives and event indicators.
_[If a Basic Co-Simulation FMU exposes its state derivatives, they are usually not utilized for the co-simulation, but, for example, to linearize the FMU at a communication point.]_

The optional part defines in which way <<derivative,`derivatives`>>, <<output,`outputs`>>, and initial unknowns, depend on <<input,`inputs`>>, and continuous-time <<state,`states`>>, at the current super-dense time instant (ME) or at the current communication point (xCS).
_[The listed <<dependencies>> declare the dependencies between whole (multi-dimensional-)variables and not individual elements of the variables.]_
_[A simulation environment can utilize this information to improve the efficiency, for example, when connecting FMUs together, or when computing the partial derivative of the <<derivative,`derivatives`>> with respect to the <<state,`states`>> in the simulation engine.]_

`<ModelStructure>` has the following definition:

image::images/schema/ModelStructure.png[width=90%]

Note that attribute <<dependenciesKind>> for element <<InitialUnknown>> has less enumeration values as <<dependenciesKind>> in the other lists, see below.

`<ModelStructure>` consists of the following elements (see also figures above; the symbols of the mathematical equations describing the dependency are defined in <<math-model-exchange>>):

[cols="1,5",options="header"]
|====
|Element
|Description

|`Output`
|Ordered list of all outputs, in other words, a list of value references where every corresponding variable must have <<causality>> = <<output>> (and *every variable with <<causality>> = <<output>> must be listed here*).
_[Note that all <<output>> variables are listed here, especially <<discrete>> and <<continuous>> <<output,`outputs`>>._
_The ordering of the variables in this list is defined by the exporting tool._
_Usually, it is best to order according to the declaration order in the source model, since then the `<Output>` list does not change if the declaration order of <<output,`outputs`>> in the source model is not changed._
_This is for example, important for linearization, in order that the interpretation of the output vector does not change for a re-exported FMU.]_
Attribute <<dependencies>> defines the dependencies of the <<output,`outputs`>> from the knowns at the current super-dense time instant in Event and in *Continuous-Time Mode* (ME) and at the current communication point (xCS).
Beside the knowns, the <<output,`outputs`>> also depend on the freeze variables (= variables which cannot be changed in the current mode) but these freeze variables are not listed as <<dependencies>>.
The functional dependency is defined as (dependencies of variables that are fixed in Event and *Continuous-Time Mode* and at communication points are not shown): +
[blue]#latexmath:[\color{blue}{(\mathbf{y}_c, \mathbf{y}_d) := \mathbf{f}_{output}(\mathbf{x}_c, \mathbf{u}_c, \mathbf{u}_d, t, \mathbf{p}_{tune})}]#

|`Derivative`
|Ordered list of all state derivatives, in other words, a list of value references where every corresponding variable must be a state derivative.
_[Note that only <<continuous>> floating point variables are listed here._
_If a <<state>> or a <<derivative>> of a <<state>> shall not be exposed from the FMU, or if states are not statically associated with a variable (due to dynamic state selection), then dummy variables have to be introduced, for example, `x[4]`, or `xDynamicStateSet2[5]`._
_The ordering of the variables in this list is defined by the exporting tool._
_Usually, it is best to order according to the declaration order of the <<state,`states`>> in the source model, since then the `<ModelStructure><Derivative>` list does not change if the declaration order of states in the source model is not changed._
_This is for example, important for linearization, in order that the interpretation of the state vector does not change for a re-exported FMU.]_

The corresponding continuous-time <<state,`states`>> are defined by attribute <<derivative>> of the corresponding variable state derivative element.
_[Note that higher order derivatives must be mapped to first order derivatives but the mapping definition can be preserved due to attribute <<derivative>>._
_Example: if_ latexmath:[\color{blue}{\frac{\text{ds}}{\text{dt}} = v,\ \frac{\text{dv}}{\text{dt}} =f(..)}] _,then_ latexmath:[\color{blue}{\left\{ v,\ \frac{\text{dv}}{\text{dt}} \right\}}] _is the vector of state derivatives and attribute <<derivative>> of_ latexmath:[\color{blue}{v}] _references_ latexmath:[\color{blue}{s}] _, and attribute <<derivative>> of_ latexmath:[\color{blue}{\frac{\text{dv}}{\text{dt}}}] _references_ latexmath:[\color{blue}{v}] _.]_ +
For Co-Simulation, elements `<Derivative>` are ignored if capability flag `providesDirectionalDerivative` has a value of `false`, in other words, it cannot be computed.
_[This is the default._
_If an FMU supports more than Model Exchange , then the `<Derivative>` elements might be present, since it is needed for Model Exchange._
_If the above flag is set to `false` for the Co-Simulation cases, then the `<Derivative>` elements are ignored for Co-Simulation._
_If "inline integration" is used for a co-simulation slave, then the model still has continuous-time <<state,`states`>> and just a special solver is used (internally the implementation results in a discrete-time system, but from the outside, it is still a continuous-time system).]_ +
Attribute <<dependencies>> defines the dependencies of the state derivatives from the knowns at the current super-dense time instant in Event and in *Continuous-Time Mode* (ME) and at the current communication point (xCS).
Beside the knowns the derivatives also depend on the freeze variables (= variables which cannot be changed in the current mode) but these freeze variables are not listed as <<dependencies>>.
The functional dependency is defined as (dependencies of variables that are fixed in Event and *Continuous-Time Mode* and at communication points are not shown): +
[blue]#latexmath:[\color{blue}{\dot{\mathbf{x}_c} := \mathbf{f}_{der}(\mathbf{x}_c, \mathbf{u}_c, \mathbf{u}_d, t, \mathbf{p}_{tune})}]#

|`InitialUnknown`
|
[[InitialUnknown,`<InitialUnknown>`]]
Ordered list of all exposed unknowns in *Initialization Mode*.
This list consists of all variables with

. <<causality>> = <<output>> and (<<initial>> = <<approx>> or <<calculated>>), and

. <<causality>> = <<calculatedParameter>> and

. all continuous-time <<state,`states`>> and all state derivatives (defined with elements `<ModelStructure><Derivative>`) with <<initial>> = <<approx>> or <<calculated>> _[if a Basic Co-Simulation FMU does not define the `<ModelStructure><Derivative>` elements, (3) cannot be present]_.

The resulting list is not allowed to have duplicates (for example, if a <<state>> is also an <<output>>, it is included only once in the list). +
Attribute <<dependencies>> defines the dependencies of the unknowns from the knowns in *Initialization Mode* at the initial time.
Beside the knowns the initial unknowns also depend on the freeze variables (= variables which cannot be changed in the current mode) but these freeze variables are not listed as <<dependencies>>.
The functional dependency is defined as:

[blue]#latexmath:[\color{blue}{\mathbf{v}_{initialUnknowns} := \mathbf{f}_{init}(\mathbf{u}_c, \mathbf{u}_d, t_0, \mathbf{v}_{initial=exact})}]#

Since, <<output,`outputs`>>, continuous-time <<state,`states`>> and state derivatives are either present as knowns (if <<initial>> = <<exact>>) or as unknowns (if <<initial>> = <<approx>> or <<calculated>>), they can be inquired with `fmi3Get{VariableType}` in *Initialization Mode*.

_[Example: Assume an FMU is defined in the following way:_

latexmath:[\color{blue}{(\mathbf{y}_{c+d}, \dot{\mathbf{x}}_c) := \mathbf{f}_{init}(\mathbf{x}_c, \mathbf{u}_{c+d}, t_0, \mathbf{p})}] +

latexmath:[\color{blue}{(\mathbf{y}_{c+d}, \dot{\mathbf{x}}_c) := \mathbf{f}_{sim}(\mathbf{x}_c, \mathbf{u}_{c+d}, t_i, \mathbf{p})}] +

_Therefore, the initial state latexmath:[\color{blue}{\mathbf{x}_c(t_0)}] has <<initial>> = <<exact>> and the initial state derivative latexmath:[\color{blue}{\dot{\mathbf{x}}_c(t_0)}] has <<initial>> = <<calculated>>._
_The environment can still initialize this FMU in steady-state, by using latexmath:[\color{blue}{\mathbf{x}_c(t_0)}] as iteration variables and adding the equations latexmath:[\color{blue}{\dot{\mathbf{x}}_c(t_0) = \mathbf{0}}] in the environment.]_

|`EventIndicator`
|
[[EventIndicator,`<EventIndicator>`]]
Ordered list of all event indicators, in other words, a list of value references where every corresponding variable must be a event indicator.
_[Note that only <<continuous>> floating point variables are listed here._
_If an event indicator shall not be exposed from the FMU, or if event indicators are not statically associated with a variable (due to dynamic event indicator selection), then dummy variables have to be introduced, for example, `eventIndocator[4]`._
_The ordering of the variables in this list is defined by the exporting tool.]_

For Co-Simulation, elements `<EventIndicator>` are ignored.
_[If an FMU supports both Model Exchange and Co-Simulation, then the `<EventIndicator>` elements might be present, since it is needed for Model Exchange.]_

// TODO: unclear why this is not solved or updated yet
// |`DiscreteStates`
// |Ordered list of all exposed discrete <<state,`states`>>, in other words a list of variable indices.
// Every corresponding variable may have attribute <<previous - does not exist anymore!!>> defined. Discrete <<state,`states`>> must have a <<clockReference>> attribute.
//
// [There are three cases:
// (1) discrete states are not exposed, like in FMI 2.0,
// (2) discrete states are exposed through modelDescription with <<previous - does not exist anymore!>> values,
// (3) discrete states are exposed without <<previous - does not exist anymore!>> values.
// It could be a combination of all three in one FMU. Discussion and conclusion:
// Introduce a flag `hasInternalState`, see also #148.]
//  [Need to clarify causality of discrete states (<<local>>, <<output>>?) and if `fmi3Set{VariableType}` is allowed for continuous states, see #243.]
// Attribute <<dependencies>> defines the dependencies of the discrete states from the known <<input,`inputs`>>, continuous-time states and previous discrete-time states.
|====

Elements `<Output>`, `<Derivative>` and `<InitialUnknown>` have the following attributes:

[cols="1,5", options="header"]
|====
|Attribute
|Description

|`valueReference`
|The value reference of the unknown latexmath:[\color{blue}{v_{\text{unknown}}}].


|`dependencies`
|
[[dependencies,`dependencies`]]
Optional attribute defining the dependencies of the unknown latexmath:[\color{blue}{v_{\text{unknown}}}] (directly or indirectly via auxiliary variables) with respect to latexmath:[\color{blue}{\mathbf{v}_{\text{known}}}].
If not present, it must be assumed that the unknown depends on all knowns.
If present as empty list, the unknown depends on none of the knowns.
Otherwise the unknown depends on the knowns defined by the given value references. +
Knowns latexmath:[\color{blue}{\mathbf{v}_{\text{known}}}] in *Event Mode* and *Continuous-Time Mode* (ME) and at communication points (xCS) for `<Output>` and `<Derivative>` elements:

- inputs (variables with <<causality>> = <<input>>)

- continuous-time states

- <<independent>> variable (usually time; <<causality>> = <<independent>>).
If an <<independent>> variable is not explicitly defined under variables, it is assumed that the unknown depends explicitly on the <<independent>> variable.

_[<<parameter,`parameters`>> and <<tunable>> <<parameter,`parameters`>> must not be listed as knowns in this mode. This may change in a future FMI version which implies the possibility to calculate derivatives with respect to parameters.]_

`Knowns` latexmath:[\color{blue}{\mathbf{v}_{\text{known}}}] in *Initialization Mode* (for elements <<InitialUnknown>>):

- inputs (variables with <<causality>> = <<input>>)

- variables with <<initial>> = <<exact>> _[for example, <<independent>> <<parameter,`parameters`>> or initial <<state,`states`>>]_

- <<independent>> variable (usually time; <<causality>> = <<independent>>).
If an <<independent>> variable is not explicitly defined under variables, it is assumed that the unknown depends explicitly on the <<independent>> variable.

For Co-Simulation, if the capability flag `providesDirectionalDerivative` has a value of `false`, then <<dependencies>> does not list the dependency on continuous-time.
In other words, the respective partial derivatives cannot be computed.

// TODO: should be discussed after Karl's return
// TODO: is it helpful to include also <<clock>> dependencies here --> i.e. changing this variable will lead to a <<outputClock>> tick.

|`dependenciesKind`
|
[[dependenciesKind, `dependenciesKind`]]
If <<dependenciesKind>> is present, <<dependencies>> must be present and must have the same number of list elements.
If not present, it must be assumed that the unknown latexmath:[\color{blue}{v_{\text{unknown}}}] depends on the knowns latexmath:[\color{blue}{\mathbf{v}_{\text{known}}}] without a particular structure.
Otherwise, the corresponding known latexmath:[\color{blue}{v_{known,i}}] enters the equation as:

`= dependent`: no particular structure, latexmath:[\color{blue}{{h(..,\ v}_{known,i}}],..)

Only for floating point type unknowns latexmath:[\color{blue}{v_{\text{unknown}}}]:

`=` <<constant>>: constant factor, latexmath:[\color{blue}{c \cdot v_{known,i}}] where latexmath:[\color{blue}{c}] is an expression that is evaluated before <<fmi3EnterInitializationMode>> is called.

Only for floating point type unknowns latexmath:[\color{blue}{v_{\text{unknown}}}] in Event and *Continuous-Time Mode* (ME) and at communication points (xCS), and not for <<InitialUnknown>> for *Initialization Mode*:

`=` <<fixed>>: fixed factor, latexmath:[\color{blue}{p \cdot v_{known,i}}] where latexmath:[\color{blue}{p}] is an expression that is evaluated before <<fmi3ExitInitializationMode>> is called.

`=` <<tunable>>: tunable factor, latexmath:[\color{blue}{p \cdot v_{known,i}}] where latexmath:[\color{blue}{p}] is an expression that is evaluated before <<fmi3ExitInitializationMode>> is called and in *Event Mode* due to an external event (ME) or at a communication point (xCS)

`=` <<discrete>>: discrete factor, latexmath:[\color{blue}{d \cdot v_{known,i}}] where latexmath:[\color{blue}{d}] is an expression that is evaluated before <<fmi3ExitInitializationMode>> is called and in *Event Mode* due to an external or internal event or at a communication point (xCS).
|====

_[Example 1:_

_An FMU is defined by the following equations:_

[latexmath]
++++
\begin{align*}

\frac{d}{\text{dt}}\begin{bmatrix}
x_{1} \\
x_{2} \\
x_{3} \\
\end{bmatrix}

&=

\begin{bmatrix}
f_{1}\left( x_{2} \right) \\
f_{2}\left( x_{1} \right) + 3 \cdot p^{2} \cdot x_{2} + 2 \cdot u_{1} + 3 \cdot u_{3} \\
f_{3}\left( x_{1},x_{3},u_{1},u_{2},u_{3} \right) \\
\end{bmatrix}

\\

y &= g_1(x_2, x_3)

\end{align*},
++++

_where_ latexmath:[\color{blue}{u_{1}}] _is a continuous-time <<input>> (<<variability>> = <<continuous>>),_ latexmath:[\color{blue}{u_{2}}] _is any type of <<input>>,_ latexmath:[\color{blue}{u_{3}}] _is a floating point discrete-time <<input>> (<<variability>> = "discrete"`), and_ latexmath:[\color{blue}{p}] _is a <<fixed>> <<parameter>> (<<variability>> = <<fixed>>)._
_The initialization is defined by:_

[latexmath]
++++
x_1 = 1.1, \frac{dx_2}{dt} = 0, y = 3.3,
++++

_and therefore, the initialization equations are:_

[latexmath]
++++
\begin{align*}
x_{2} &= \frac{1}{3 \cdot p^{2}} \cdot ( f_{2}\left( x_{1} \right) + 2 \cdot u_{1} + 3 \cdot u_{3} )
\\
x_{3} &= g_{1}^{- 1}( x_{2}, y)
\end{align*}
++++

_This equation system can be defined as:_

[source, xml]
----
include::examples/model_structure_example1.xml[tags=VariablesAndStructure]
----

_Example 2:_

[latexmath]
++++
y = \left\{ \begin{matrix}
2 \cdot u \ \mathrm{if} \ u > 0 \\
3 \cdot u \ \mathrm{else} \\
\end{matrix}\right.
++++

_where_ latexmath:[\color{blue}{u}] _is a continuous-time <<input>> with <<valueReference>> = `1` and_ latexmath:[\color{blue}{y}] _is a continuous-time <<output>> with <<valueReference>> = `2`._
_The definition of the model structure is then:_

[source, xml]
----
include::examples/model_structure_example2.xml[tags=ModelStructure]
----

_[Note that_ latexmath:[\color{blue}{y = d \cdot u}] _where_ latexmath:[\color{blue}{d}] _changes only during *Event Mode* (_ latexmath:[\color{blue}{d = 2 \cdot u}] _or_ latexmath:[\color{blue}{3 \cdot u\ }] _depending on relation_ latexmath:[\color{blue}{u > 0}] _that changes only at *Event Mode*)._
_Therefore <<dependenciesKind>> = <<discrete>>.]_

_Example 3:_

[latexmath]
++++
y = \left\{ \begin{matrix}
2\ \ \mathrm{if}\ \ u > 0 \\
3\ \ \mathrm{else} \\
\end{matrix}\right.
++++

_where_ latexmath:[\color{blue}{u}] _is a continuous-time <<input>> with <<valueReference>> = `1` and_ latexmath:[\color{blue}{y}] _is a continuous-time <<output>> with <<valueReference>> = `2`._
_The definition of the model structure is then:_

[source, xml]
----
include::examples/model_structure_example3.xml[tags=ModelStructure]
----

_[Note that_ latexmath:[\color{blue}{y = c}] _where_ latexmath:[\color{blue}{c}] _changes only during *Event Mode* (_ latexmath:[\color{blue}{c = 2}] _or_ latexmath:[\color{blue}{3\ }] _depending on relation_ latexmath:[\color{blue}{u > 0}] _that changes only at *Event Mode*)._
_Therefore <<dependenciesKind>> = <<dependenciesKind,`dependent`>> because it is not a linear relationship on_ latexmath:[\color{blue}{u}]. _]_

_Example 4:_

[latexmath]
++++
\frac{dx}{dt}=u, y=x
++++

where `u` is continuous-time input value reference `1`, `y` is a continuous-time output with value reference `2` and `dxdt` is a continuous-time derivative with value reference `4`.
The definition of the model structure is then:

[source, xml]
----
include::examples/model_structure_example4.xml[tags=VariablesAndStructure]
----

_Defining FMU features with the_ <<dependencies>> _list:_

_[Note that via the <<dependencies>> list the supported features of the FMU can be defined._
_Examples:_

- _If a state derivative `der_x` is a function of a <<parameter>> p (so of a <<start>> value of a variable with <<causality>> = <<parameter>> and <<variability>> = <<fixed>>), and the FMU does not support an iteration over `p` during *Initialization Mode* (for example, to iterate over p such that the state derivative `der_x` is zero), then the <<dependencies>> list of `der_x` should not include `p`._
_If an FMU is imported in an environment and such an iteration is set up, then the tool can figure out that the resulting algebraic system of equations is structurally singular and therefore can reject such a definition._

- _For Basic Co-Simulation FMUs, it is common that no algebraic loops over the <<input>> / <<output>> variables nor over <<start>> values is supported._
_In such a case, all <<dependencies>> lists for <<output>> variables under the <<InitialUnknown>> element should be defined as empty lists defining that the setting of <<input,`inputs`>> and/or of <<start>> values does not influence the <<output,`outputs`>>._
_As a result, it is not possible to formulate algebraic loops of connected FMUs during *Initialization Mode*.]_

==== Variable Naming Conventions (variableNamingConvention) [[variableNamingConvention]]

With attribute `variableNamingConvention` in `<fmiModelDescription>`, the convention is defined how the variable names have been constructed.
If this information is known, the environment may be able to represent the names in a better way (for example, as a tree and not as a linear list).

In the following definitions, the http://en.wikipedia.org/wiki/Extended_BNF[EBNF] is used:

----
=   production rule
[ ] optional
{ } repeat zero or more times
|   or
----

The names must be unique, non-empty strings. +
_[It is recommended that the names are visually clearly different from each other; but it is not required.]_

The following conventions for scalar names are defined:

*`variableNamingConvention = flat`*

----
name = Unicode-char { Unicode-char } // identical to xs:normalizedString
Unicode-char = any Unicode character without carriage return (#xD),
line feed (#xA) nor tab (#x9)
----

*`variableNamingConvention = structured`*

Structured names are hierarchical using "." as a separator between hierarchies.
A name consists of "pass:[_]", letters and digits or may consist of any characters enclosed in single apostrophes.
A name may identify an array element on every hierarchical level using "[...]" to identify the respective array index.
If an array is a leaf node of the variable hierarchy then the array can also be represented as a single variable of type array.
A <<derivative>> of a variable is defined with `der(name)` for the first time derivative and `der(name,N)` for the N-th derivative.
Examples:

----
vehicle.engine.speed
resistor12.u
v_min
robot.axis.'motor #234'
der(pipe[3,4].T[14],2) // second time derivative of pipe[3,4].T[14]
----

The precise syntax is:

----
name            = identifier | "der(" identifier ["," unsignedInteger ] ")"
identifier      = B-name [ arrayIndices ] {"." B-name [ arrayIndices ] }
B-name          = nondigit { digit | nondigit } | Q-name
nondigit        = "pass:[_]" | letters "a" to "z" | letters "A" to "Z"
digit           = "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"
Q-name          = "'" ( Q-char | escape ) { Q-char | escape } "'"
Q-char          = nondigit | digit | "!" | "#" | "$" | "%" | "&" | "(" | ")" |
                                     "*" | "+" | "," | "-" | "." | "/" | ":" |
                                     ";" | "<" | ">" | "=" | "?" | "@" | "[" |
                                     "]" | "^" | "{" | "}" | "|" | "~" | " "
escape          = "\'" | "\"" | "\?" | "\\" | "\a" | "\b" |
                  "\f" | "\n" | "\r" | "\t" | "\v"
arrayIndices    = "[" unsignedInteger {"," unsignedInteger} "]"
unsignedInteger = digit { digit }
----

_[This definition is identical to the syntax of an identifier in Modelica version 3.2.]_

The tree of names is mapped to an ordered list of variable names in http://en.wikipedia.org/wiki/Depth-first_search[depth-first] order.
Example:

----
vehicle
  transmission
    ratio
    outputSpeed
  engine
    inputSpeed
    temperature
----

is mapped to the following list of variable names:

----
vehicle.transmission.ratio
vehicle.transmission.outputSpeed
vehicle.engine.inputSpeed
vehicle.engine.temperature
----

All flattened array elements are given in a consecutive sequence of variables.
Elements of multi-dimensional arrays are ordered according to "row major" order that is elements of the last index are given in sequence.

_[For example, the vector `centerOfMass` in body `arm1` is mapped to the following variables:_

----
robot.arm1.centerOfMass[1]
robot.arm1.centerOfMass[2]
robot.arm1.centerOfMass[3]
----

_For example, a table `T[4,3,2]` (first dimension 4 entries, second dimension 3 entries, third dimension 2 entries) is mapped to the following variables:_

----
T[1,1,1]
T[1,1,2]
T[1,2,1]
T[1,2,2]
T[1,3,1]
T[1,3,2]
T[2,1,1]
T[2,1,2]
T[2,3,1]
...
----
_]_

It might be that not all elements of an array are present.
If they are present, they are given in consecutive order in the XML file.
