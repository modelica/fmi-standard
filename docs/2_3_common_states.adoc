=== State Machine and Semantics [[common-state-machine]]

All FMI interface types share a number of states in their respective state machines.
This chapter describes these common modes.
FMI specific state-machine modes will be described in their respective chapters.

.Common calling sequence for C functions of common states for all three FMI types.
[#figure-common-state-machine]
image::images/state-machines-common-states.svg[width=80%, align="center"]

==== Super State: FMU State Setable [[FMUStateSetable]]

The description of the super state *FMU State Setable* generally describes functions that deal with instantiation, destruction and logging of FMUs.

This state is entered when any of the following functions is called: <<fmi3InstantiateModelExchange>>, <<fmi3InstantiateCoSimulation>> and <<fmi3InstantiateScheduledExecution>>.
The state is left by either calling <<fmi3FreeInstance>> or when any of the functions called during *FMU State Setable* returns <<fmi3Fatal>>.
If any function called in super state *FMU State Setable* returns <<fmi3Error>>, the FMU enters state *Terminated*.

Allowed Function Calls::

[[fmi3InstantiateModelExchange,`fmi3InstantiateModelExchange`]]
Function `fmi3InstantiateModelExchange`::
FMU with initialization and events; between events, the simulation of continuous systems is performed with external integrators from the environment (see <<fmi-for-model-exchange>>).
The <<modelDescription.xml>> has to include a `<ModelExchange>` element to allow calling `fmi3InstantiateModelExchange`.

[[fmi3InstantiateCoSimulation,`fmi3InstantiateCoSimulation`]]
Function `fmi3InstantiateCoSimulation`::
Black box interface for Co-Simulation (see <<fmi-for-co-simulation>>).
The <<modelDescription.xml>> has to include a `<CoSimulation>` element to allow calling `fmi3InstantiateCoSimulation`.

[[fmi3InstantiateScheduledExecution,`fmi3InstantiateScheduledExecution`]]
Function `fmi3InstantiateScheduledExecution`::
Black box interface for Scheduled Execution (see <<fmi-for-scheduled-execution>>).
The <<modelDescription.xml>> has to include a `<ScheduledExecution>` element to allow calling `fmi3InstantiateScheduledExecution`.

[[fmi3Instantiate,`fmi3InstantiateXXX`]]
[source, C]
----
include::../headers/fmi3FunctionTypes.h[tags=Instantiate]
----

These functions return a new instance of an FMU with the respective interface type.
If a null pointer is returned, then instantiation failed.
In that case, <<logMessage>> is called with detailed information about the reason.
An FMU can be instantiated many times (provided capability flag `canBeInstantiatedOnlyOncePerProcess = false`).

The arguments of the instantiation functions are detailed as follows:

* `instanceName` is a unique identifier for the FMU instance.
It is used to name the instance, for example, in error or information messages generated by one of the `fmi3XXX` functions.
The argument `instanceName` must be a non empty string (in other words, must have at least one character that is not a white space).
_[If only one FMU is simulated, as `instanceName` attribute `modelName` or `<ModelExchange|CoSimulation|ScheduledExecution modelIdentifier="..">` from the XML schema `fmi3ModelDescription` might be used.]_

* `instantiationToken` can be used by the FMU to check that the <<modelDescription.xml>> file (see <<fmu-distribution>>) is compatible with the implementation of the FMU.
It is an opaque string generated by the FMU exporter that is stored in the xml file as mandatory attribute `instantiationToken` (see <<fmiModelDescription>>).
It must be passed unchanged to the FMU.
This argument must not be a null pointer.

[[resourceLocation,`resourceLocation`]]
* `resourceLocation` is a URI according to the http://datatracker.ietf.org/doc/rfc3986/[IETF RFC3986] syntax to indicate the location to the `resources` directory of the unzipped FMU archive.
The following schemes must be understood by the FMU:

** Mandatory -- `file` with absolute path (either including or omitting the authority component); +
** Optional -- `http`, `https`, `ftp`.

+
_[Example: An FMU is unzipped in directory `C:\temp\MyFMU`, then <<resourceLocation>> = `file:///C:/temp/MyFMU/resources` or `file:/C:/temp/MyFMU/resources`._ +
_The <<fmi3Instantiate>> functions are then able to read all needed resources from this directory, for example maps or tables used by the FMU.]_ +
A NULL pointer is supplied for <<resourceLocation>>, if no resource location can be provided to the FMU, which may occur

** if the FMU does not contain a resources folder, or
** if the environment is not able to provide an URI to the resources folder _[e.g., if the environment does not have a file system._
_If the FMU in such a case cannot be simulated, as it depends on the resources folder, it shall terminate with an error.]_


* `visible == fmi3False` defines that the interaction with the user should be reduced to a minimum (no application window, no plotting, no animation, etc.).
In other words, the FMU is executed in batch mode.
If `visible == fmi3True`, the FMU is executed in interactive mode, and the FMU might require to explicitly acknowledge start of simulation / instantiation / initialization (acknowledgment is non-blocking).

* If `loggingOn == fmi3False`, then any logging is disabled and the <<logMessage>> callback function is not called by the FMU.
If `loggingOn == fmi3True`, the FMU enables a vendor defined set of `<LogCategories>`.
This set should typically contain categories for messages that explain execution errors, like <<fmi3Discard>>, <<fmi3Error>> and <<fmi3Fatal>>.
The function <<fmi3SetDebugLogging>> gives more detailed control about required `<LogCategories>` (see <<definition-of-log-categories>>).

* If `eventModeUsed == fmi3True` the simulation algorithm can handle events, otherwise `fmi3EnterEventMode` must not be called.
The flag may only be `fmi3True`, if `hasEventMode == true`, otherwise the FMU must raise an error.
For FMUs that have synchronous clocks, `eventModeUsed == fmi3True` is required.

* `instanceEnvironment` is a pointer that can be passed to the <<fmi3CallbackIntermediateUpdate>> function in order that the simulation environment can provide an efficient way to identify the FMU that called <<fmi3CallbackIntermediateUpdate>>.

[[requiredIntermediateVariables,`requiredIntermediateVariables`]]
* `requiredIntermediateVariables` is an array of the value references of all <<input>> variables that the simulation algorithm intends to set and all <<output>> variables it intends to get during intermediate updates.
This set may be empty (<<nRequiredIntermediateVariables>> == 0) when the simulation algorithm does not intend to use intermediate update.
All variables referenced in this set must be marked with the attribute <<intermediateUpdate,`intermediateUpdate = "true"`>> in the model description.
Only the variables in <<requiredIntermediateVariables>> may be accessed by the simulation algorithm using `fmi3Set{VariableType}` and `fmi3Get{VariableType}` during <<fmi3CallbackIntermediateUpdate>> callbacks.

[[nRequiredIntermediateVariables,`nRequiredIntermediateVariables`]]
* `nRequiredIntermediateVariables` gives the number of entries in <<requiredIntermediateVariables>>.
If <<nRequiredIntermediateVariables>> is zero <<requiredIntermediateVariables>> is not defined.

The arguments <<logMessage>>, <<intermediateUpdate>>, <<preemption-support,`lockPreemption`>>, and <<preemption-support,`unlockPreemption`>>, are function pointers provided by the simulation environment to be used by the FMU.
It is not allowed to change these functions between <<fmi3Instantiate>> and <<fmi3Terminate>> calls.
Additionally, a pointer to the environment is provided (`instanceEnvironment`) that needs to be passed to all of the callback functions, in order that those functions can utilize data from the environment, such as mapping a <<valueReference>> to a string, or assigning memory to a certain FMU instance.

In the default `fmi3FunctionTypes.h` file, typedefs for the function definitions are present to simplify the usage; this is non-normative.
These callback functions are defined below.

[[logMessage,`logMessage`]]
Callback function `logMessage`::
[source, C]
----
include::../headers/fmi3FunctionTypes.h[tags=CallbackLogMessage]
----

Pointer to a function that is called in the FMU _[usually if an `fmi3XXX` function does not behave as desired]_.

* `instanceName` is the instance name of the model that calls this function.
* `status` contains the severity of the message, see `fmi3Status`.
If <<logMessage>> is called with <<fmi3OK,`status == fmi3OK`>>, then the message is a pure information message.

* `category` is the category of the message.
The meaning of `category` is defined by the modeling environment that generated the FMU.
Depending on this modeling environment, none, some, or all, allowed values of `category` for this FMU are defined in the <<modelDescription.xml>> file via element `<fmiModelDescription><LogCategories>`, see <<definition-of-log-categories>>.
Only messages are provided by function <<logMessage>> that have a category according to a call to <<fmi3SetDebugLogging>>.

* `message` is a string that contains the message.
_[Typically, this function prints the message and stores it optionally in a log file.]_

All string-valued arguments passed by the FMU to the <<logMessage>> may be deallocated by the FMU directly after function <<logMessage>> returns.
The simulation environment must therefore create copies of these strings if it needs to access these strings later. +
The <<logMessage>> function will append a line break to each message when writing messages after each other to a terminal or a file (the messages may also be shown in other ways, for example, as separate text-boxes in a GUI).
The caller may include line-breaks (using "\n") within the message, but should avoid trailing line breaks. +
Variables can be referenced in a message with `pass:[#]<ValueReference>pass:[#]`.
If the character `pass:[#]` shall be included in the message, it has to be prefixed with `pass:[#]`, so `pass:[#]` is an escape character.

_[Example: The message `\#1365# must be larger than zero (used in IO channel ##4)` might be changed by the <<logMessage>> function to `body.m must be larger than zero (used in IO channel #4)` if `body.m` is the name of the variable with value reference 1365.]_

Callback function `intermediateUpdate`::

See <<fmi3CallbackIntermediateUpdate>> for details.

Callback function `lockPreemption` and `unlockPreemption`::

See <<preemption-support>> for details.

[[fmi3SetDebugLogging,`fmi3SetDebugLogging`]]
Function `fmi3SetDebugLogging`::
[source, C]
----
include::../headers/fmi3FunctionTypes.h[tags=SetDebugLogging]
----
The function controls debug logging that is output via the <<logMessage>> callback function.

* If `loggingOn == fmi3True`, debug logging is enabled, otherwise it is switched off.

* `nCategories` defines the length of the next argument `categories`
If `loggingOn == fmi3True` and `nCategories == 0`, then all debug messages shall be output.
If `loggingOn == fmi3True` and `nCategories > 0`, then only debug messages according to the `categories` argument shall be printed via the <<logMessage>> function.

* `categories` is a vector with `nCategories` elements.
The allowed values of `categories` are defined by the modeling environment that generated the FMU.
Depending on the generating modeling environment, none, some or all allowed values for `categories` for this FMU are defined in the <<modelDescription.xml>> file via element `<fmiModelDescription><LogCategories>`, see <<definition-of-log-categories>>.

[[fmi3Reset,`fmi3Reset`]]
Function `fmi3Reset`::
[source, C]
----
include::../headers/fmi3FunctionTypes.h[tags=Reset]
----

Is called by the environment to reset the FMU after a simulation run.
The FMU goes into the same state as if <<fmi3Instantiate>> would have been called.
All variables have their default values.
Before starting a new run <<fmi3EnterInitializationMode>> has to be called.

[[fmi3Terminate,`fmi3Terminate`]]
Function `fmi3Terminate`::
[source, C]
----
include::../headers/fmi3FunctionTypes.h[tags=Terminate]
----

Changes state to *Terminated*.
After calling this function, the final values of all variables can be inquired with the `fmi3Get{VariableType}` functions.
It is not allowed to call this function after one of the functions returned with a status flag of <<fmi3Error>> or <<fmi3Fatal>>.

[[fmi3FreeInstance,`fmi3FreeInstance`]]
Function `fmi3FreeInstance`::
[source, C]
----
include::../headers/fmi3FunctionTypes.h[tags=FreeInstance]
----

Disposes the given instance, unloads the loaded model, and frees all the allocated memory and other resources that have been allocated by the functions of the FMU interface.
If a null pointer is provided for argument `instance`, the function call is ignored (does not have an effect).

[[get-set-fmu-state]]
Getting and Setting the Complete FMU State::

// TODO: should this be a heading and all 6 following calls indented?

--
The FMU has an internal state consisting of all values that are needed to continue a simulation.
This internal state consists especially of the values of the continuous-time states, iteration variables, <<parameter>> values, <<input>> values, delay buffers, file identifiers, and FMU internal status information.
With the functions of this section, the internal FMU state can be copied and the pointer to this copy is returned to the environment.
The FMU state copy can be set as actual FMU state, in order to continue the simulation from it.

_[Examples for using this feature:_

_For variable step-size control of co-simulation algorithms (get the FMU state for every accepted communication step; if the follow-up step is not accepted, restart co-simulation from this FMU state)._

_For nonlinear Kalman filters (get the FMU state just before initialization; in every sample period, set new continuous states from the Kalman filter algorithm based on measured values; integrate to the next sample instant and inquire the predicted continuous states that are used in the Kalman filter algorithm as basis to set new continuous states)._

_For nonlinear model predictive control (get the FMU state just before initialization; in every sample period, set new continuous states from an observer, initialize and get the FMU state after initialization._
_From this state, perform many simulations that are restarted after the initialization with new input signals proposed by the optimizer).]_

Furthermore, the FMU state can be serialized and copied in a byte vector.
_[This can be, for example, used to perform an expensive steady-state initialization, copy the received FMU state in a byte vector and store this vector on file._
_Whenever needed, the byte vector can be loaded from file and deserialized, and the simulation can be restarted from this FMU state, in other words, from the steady-state initialization.]_

[[fmi3GetFMUState, `fmi3GetFMUState`]]
Functions <<fmi3GetFMUState>>::

[source, C]
----
include::../headers/fmi3FunctionTypes.h[tags=GetFMUState]
----

This function makes a copy of the internal FMU state and returns a pointer to this copy (`FMUState`).
If on entry `*FMUState == NULL`, a new allocation is required.
If `*FMUState != NULL`, then `*FMUState` points to a previously returned `FMUState` that has not been modified since.
In particular, <<fmi3FreeFMUState>> had not been called with this `FMUState` as an argument.
_[Function <<fmi3GetFMUState>> typically reuses the memory of this `FMUState` in this case and returns the same pointer to it, but with the actual `FMUState`.]_

[[fmi3SetFMUState, `fmi3SetFMUState`]]
Function <<fmi3SetFMUState>>::

[source, C]
----
include::../headers/fmi3FunctionTypes.h[tags=SetFMUState]
----

This function copies the content of the previously copied `FMUState` back and uses it as actual new FMU state.
The `FMUState` copy still exists.
_[The simulation is restarted at this state, when calling <<fmi3SetFMUState>> with `FMUState`.]_

[[fmi3FreeFMUState, `fmi3FreeFMUState`]]
<<fmi3FreeFMUState>>::

[source, C]
----
include::../headers/fmi3FunctionTypes.h[tags=FreeFMUState]
----

This function frees all memory and other resources allocated with the <<fmi3GetFMUState>> call for this `FMUState`.
The argument to this function is the `FMUState` to be freed.
If a null pointer is provided, the call is ignored.
The function returns a null pointer in argument `FMUState`.

These functions can be called, if the optional capability flag <<canGetAndSetFMUState>> is set to `true`.

[[fmi3SerializedFMUStateSize,`fmi3SerializedFMUStateSize`]]
Function `fmi3SerializedFMUStateSize`::

[source, C]
----
include::../headers/fmi3FunctionTypes.h[tags=SerializedFMUStateSize]
----

This function returns the `size` of the byte vector, in order that `FMUState` can be stored in it.
With this information, the environment has to allocate an `fmi3Byte` vector of the required length `size`.

[[fmi3SerializeFMUState,`fmi3SerializeFMUState`]]
Function <<fmi3SerializeFMUState>>::

[source, C]
----
include::../headers/fmi3FunctionTypes.h[tags=SerializeFMUState]
----

This function serializes the data which is referenced by pointer `FMUState` and copies this data in to the byte vector `serializedState` of length `size`, that must be provided by the environment.

[[fmi3DeSerializeFMUState,`fmi3DeSerializeFMUState`]]
Function <<fmi3DeSerializeFMUState>>::

[source, C]
----
include::../headers/fmi3FunctionTypes.h[tags=DeSerializeFMUState]
----

This function deserializes the byte vector `serializedState` of length `size`, constructs a copy of the FMU state and returns `FMUState`, the pointer to this copy.

These functions are only supported by the FMU, if the optional capability flags `canGetAndSetFMUState` and `canSerializeFMUState` in `<fmiModelDescription><ModelExchange|CoSimulation|ScheduledExecution>` in the XML file are explicitly set to `true` (see <<fmi-for-model-exchange>>, <<fmi-for-co-simulation>>, <<fmi-for-scheduled-execution>>).
--

Functions <<get-and-set-variable-values,`fmi3Get{VariableType}`>>::
See <<get-and-set-variable-values>> for the general mechanism to get variable values.
Getting variable might trigger computations.
_[If *Terminated* is entered because of an `fmi3Error` return value, retrieved values should only be used for debugging purposes.]_

===== State: Instantiated [[Instantiated]]

In this state the FMU can do one-time initializations and allocate memory.
This state is entered after <<fmi3Instantiate>> returned successfully.

Allowed Function Calls::

[[fmi3EnterConfigurationMode,`fmi3EnterConfigurationMode`]]
Function `fmi3EnterConfigurationMode`::
[source, C]
----
include::../headers/fmi3FunctionTypes.h[tags=EnterConfigurationMode]
----

Changes state to *Configuration Mode*.

[[fmi3EnterInitializationMode,`fmi3EnterInitializationMode`]]
Function `fmi3EnterInitializationMode`::
[source, C]
----
include::../headers/fmi3FunctionTypes.h[tags=EnterInitializationMode]
----

Changes state to *Initialization Mode*.

* `toleranceDefined` and `tolerance` depend on the interface type:

Model Exchange::
If `toleranceDefined == fmi3True`, then the model is called with a numerical integration scheme where the step size is controlled by using `tolerance` for error estimation (usually as relative tolerance).
In such a case all numerical algorithms used inside the model (for example, to solve non-linear algebraic equations) should also operate with an error estimation of an appropriate smaller relative tolerance.

Co-Simulation::
If `toleranceDefined == fmi3True`, then the communication step size of the FMU is controlled by error estimation.
In case the FMU utilizes a numerical integrator with variable step size and error estimation, it is suggested to use `tolerance` for the error estimation of the integrator (usually as relative tolerance). +
An FMU for Co-Simulation might ignore this argument.

* `startTime` and `stopTime` can be used to check whether the model is valid within the given boundaries, or to allocate the necessary memory for storing results.
`startTime` is the <<fixed>> <<initial>> value of the <<independent>> variable and inherits its unit.
+
_[It is defined with <<causality>> = <<independent>> in the <<modelDescription.xml>>._
_If the <<independent>> variable is `time`, `startTime` is the starting time of initialization.]_

* If `stopTimeDefined == fmi3True`, then `stopTime` is the final value of the <<independent>> variable and inherits its unit.
If the environment tries to compute past `stopTime`, the FMU has to return <<fmi3Error,`fmi3Status == fmi3Error`>>.
If `stopTimeDefined == fmi3False`, then no final value of the <<independent>> variable is defined and argument `stopTime` is meaningless.

Function `fmi3Set{VariableType}`::

This function can be called for variables with <<variability>> latexmath:[\neq] <<constant>> and with <<initial>> = <<exact>> or <<approx>>.
The intention is to set <<start>> and guess values for these variables.

===== State: Initialization Mode [[InitializationMode]]

This mode is used by the simulation algorithm to compute consistent initial conditions for overall system.
Equations are active to determine the initial FMU state, as well as all <<output,`outputs`>> (and optionally other variables exposed by the exporting tool).
Artificial or real algebraic loops over connected FMUs in *Initialization Mode* may be handled by using appropriate numerical algorithms.

Allowed Function Calls::

[[fmi3ExitInitializationMode,`fmi3ExitInitializationMode`]]
Function `fmi3ExitInitializationMode`::
[source, C]
----
include::../headers/fmi3FunctionTypes.h[tags=ExitInitializationMode]
----

Changes the state to *Event Mode* (ME), *Step Mode* (CS) or *Clock Activation Mode* (SE).
_[This function switches off all initialization equations.]_

Function <<fmi3GetDirectionalDerivative>>::
See <<fmi3GetDirectionalDerivative>>.

Function `fmi3Set{VariableType}`::
For variables with:
* <<variability>> latexmath:[\neq] <<constant>> that have <<initial>> = <<exact>>, or
* <<causality>> = <<input>>, or
* <<causality>> = <<parameter>> and <<variability>> = <<tunable>>.

Function `fmi3Get{VariableType}`::
The variables that can be retrieved by `fmi3Get{VariableType}` calls are defined in the XML file as elements `<ModelStructure><InitialUnknown>`.
For variables with <<causality>> = <<output>> or continuous-time <<state,`states`>> or state derivatives.

===== State: Configuration Mode [[ConfigurationMode]]

In this state <<structuralParameter,`structural parameters`>> with <<variability>> = <<fixed>> or <<variability>> = <<tunable>> can be changed.
No other variables can be changed during *Configuration Mode*.
This state is entered from state *Instantiated* by calling <<fmi3EnterConfigurationMode>> and left back to *Instantiated* by calling <<fmi3ExitConfigurationMode>>.
<<fmi3EnterConfigurationMode>> can only be called if the FMU contains at least one <<structuralParameter,`structural parameter`>>

Allowed Function Calls::

[[fmi3ExitConfigurationMode,`fmi3ExitConfigurationMode`]]
Function `fmi3ExitConfigurationMode`::
[source, C]
----
include::../headers/fmi3FunctionTypes.h[tags=ExitConfigurationMode]
----

Exits the *Configuration Mode* and returns to state *Instantiated*.

Function `fmi3Set{VariableType}`::
Only for variables with <<causality>> = <<structuralParameter>> and <<variability>> = <<fixed>> or <<variability>> = <<tunable>>.

===== State: Terminated [[Terminated]]
In this state, the solution at the final time of a simulation can be retrieved.

Allowed Function Calls::

Function <<fmi3GetDirectionalDerivative>>::
No restrictions.

Function <<fmi3GetOutputDerivatives>>::
No restrictions.

==== Super State: Initialized [[Initialized]]

This super state is entered by the FMU when <<fmi3ExitInitializationMode>> is called.
If the function <<fmi3Terminate>> is called, the FMU enters state *Terminated* from all states of this super state.
If any function returns <<fmi3Error>> in *Initialized*, the FMU switches to state *Terminated*.

The states of this super state differ between the FMI types and will be described in detail in their respective chapters.

===== State: Event Mode [[EventMode]]

_[TODO: add *Event Mode* description after clocks/event clarification...]

The next event instant latexmath:[t_{i+1}] is defined by the earliest occurrence of one of the following conditions:

. The environment of the FMU triggers an event at the current time instant because at least one discrete-time <<input>> changes its value, a continuous-time <<input>> has a discontinuous change, or a <<tunable>> <<parameter>> changes its value.
_[Note that if an FMU A is connected to an FMU B, and an event is triggered for A, then potentially all <<output,`outputs`>> of A will be discontinuous at this time instant._
_It is therefore advisable to move B into *Event Mode* at this time instant too if an <<output>> of A is connected to B._
_This means to call <<fmi3EnterEventMode>> on B.]_ +
+
All the following events are internal events:

. At a predefined time instant latexmath:[t_i=T_{\mathit{next}}(t_{i-1}, 0)] that was defined at the previous event instant latexmath:[t_{i-1}] by the FMU.
Such an event is called <<time event>>.

. At a time instant, where an event indicator latexmath:[z_j(t)] changes its domain from latexmath:[z_j > 0] to latexmath:[z_j \leq 0] or from latexmath:[z_j \leq 0] to latexmath:[z_j > 0] (see <<figure-events>>).
More precisely: An event latexmath:[t = t_i] occurs at the smallest time instant latexmath:[t] with latexmath:[t>t_{i-1}] where latexmath:[(z_j(t)>0) \neq (z_j(t_{i-1}) >0)].
Such an event is called <<state event>>.
_[This definition is slightly different from the standard definition of <<state event,`state events`>>: _ latexmath:[z_j(t) \cdot z_j(t_{i-1}) \leq 0] _._
_This often used definition has the severe drawback that_ latexmath:[z_j(t_{i-1}) \neq 0] _is required in order to be well-defined and this condition cannot be guaranteed.]._
All event indicators are piecewise continuous and are collected together in one vector of floating point numbers latexmath:[\mathbf{z(t)}]. +

.An event occurs when the event indicator changes its domain from latexmath:[z>0] to latexmath:[z\leq 0] or vice versa.
[#figure-events]
image::images/Event.svg[width=60%, align="center"]

[start=4]
. At every completed step of an integrator, <<fmi3CompletedIntegratorStep>> must be called (provided the capability flag `completedIntegratorStepNotNeeded` of `<fmiModelDescription>` is `false`).
An event occurs at this time instant, if indicated by the return argument `enterEventMode == fmi3True`.
Such an event is called <<step event>>.
_[<<step event,`Step events`>> are, for example, used to dynamically change the (continuous) <<state,`states`>> of a model internally in the FMU, because the previous states are no longer suited numerically.]_

In this mode all continuous-time and discrete-time equations are active and the unknowns at an event can be computed and retrieved.
The event time of a <<state event>> may be determined if a domain change of at least one event indicator is detected at the end of a completed integrator step.

*Event Mode* is entered by calling <<fmi3EnterEventMode>>, if an event is triggered in *Continuous-Time Mode*.

Allowed Function Calls::

Function <<fmi3ExitInitializationMode>>::
When the *Initialization Mode* is terminated with <<fmi3ExitInitializationMode>>, then *Event Mode* is directly entered, and the continuous-time and discrete-time variables at the initial time are computed based on the initial continuous-time states determined in the *Initialization Mode*.

The co-simulation algorithm and the FMU enter this state when the co-simulation algorithm calls <<fmi3EnterEventMode>> in state *Step Mode*, in order to handle discrete events and <<clock>> ticks.
If the co-simulation algorithm signals `eventModeUsed == fmi3False` during instantiation, the co-simulation algorithm is not allowed to call <<fmi3EnterEventMode>>.

Function <<fmi3UpdateDiscreteStates>>::
In order to handle discrete events <<fmi3UpdateDiscreteStates>> is called.
When the output argument `discreteStatesNeedUpdate == fmi3True`, the FMU should stay in *Event Mode* and another call to <<fmi3UpdateDiscreteStates>> is required.

Function <<fmi3EnterContinuousTimeMode>>::
[[fmi3EnterContinuousTimeMode,`fmi3EnterContinuousTimeMode`]]
[source, C]
----
include::../headers/fmi3FunctionTypes.h[tags=EnterContinuousTimeMode]
----

TODO only in ME

The model enters *Continuous-Time Mode* and all discrete-time equations become inactive and all relations are "frozen". +
This function has to be called when changing from *Event Mode* (after the global event iteration in *Event Mode* over all involved FMUs and other models has converged) into *Continuous-Time Mode*. +

_[This function might be used additionally for the following purposes:_
* _If the FMU stores results internally on file, then the results after the initialization and/or the event has been processed can be stored._
* _If the FMU contains dynamically changing states, then a new state selection might be performed with this function.]_

Function <<fmi3EnterStepMode>>::

TODO only in CS

Once all events are handled and `discreteStatesNeedUpdate == fmi3False`, the FMU should be pushed to *Step Mode* by calling <<fmi3EnterStepMode>>, unless it requests to terminate the Co-Simulation by setting  <<terminateSimulation,`terminateSimulation`> to `fmi3True`.
In this case, a new step can be started from the current communication point time.

<<fmi3GetClock>>::
The status of <<outputClock,`output clocks`>> and <<localClock,`local clocks`>> can be inquired by this function during *Event Mode* and *Intermediate Update Mode*.

<<fmi3SetClock>>::
For <<inputClock,`input clocks`>>, <<fmi3SetClock>> is called after entering *Event Mode* to set the activation status of <<clock,`clocks`>>.
This function can be called several times, only if re-computations of clock state are needed during *Event Mode*.

<<fmi3GetIntervalDecimal>> & <<fmi3GetIntervalFraction>>::
For <<outputClock,`output clocks`>> and <<localClock,`local clocks`>> it is allowed to call these functions during *Event Mode* and *Intermediate Update Mode*.
These functions can be called only at the first activation of <<periodic>> <<outputClock,`output clocks`>>.
For <<periodic,`aperiodic`>> <<outputClock,`output clocks`>>, these functions must be called at every activation _[to inquire when triggered <<inputClock,`input clocks`>> must tick]_.

<<fmi3SetIntervalDecimal>> & <<fmi3SetIntervalFraction>>::
These functions can be called only at the first activation of <<periodic>> <<inputClock,`input clocks`>>.
These functions can be called for every activation of <<periodic,`aperiodic`>> <<inputClock,`input clocks`>>.

Function <<fmi3GetDirectionalDerivative>>::
See <<fmi3GetDirectionalDerivative>>.

===== State: Reconfiguration Mode [[ReconfigurationMode]]

This state is entered from state *Event Mode* (ME), *Step Mode* (CS) or *Clock Activation Mode* (SE) by calling <<fmi3EnterConfigurationMode>>.
<<fmi3EnterConfigurationMode>> can only be called if the FMU contains at least one <<structuralParameter,`structural parameter`>>.

Allowed Function Calls::

Function <<fmi3ExitConfigurationMode>>::
Returns back to *Event Mode* (ME), *Step Mode* (CS) or *Clock Activation Mode* (SE).

Function `fmi3Set{VariableType}`::
Only for variables with <<causality>> = <<structuralParameter>> and <<variability>> = <<tunable>>.
No other variables can be changed during *Reconfiguration Mode*.

==== State: Intermediate Update Mode [[IntermediateUpdateMode]]

This state is only available in Co-Simulation and Scheduled Execution.
The following use cases are enabled:

* improve the input accuracy in CS between communication points, when the importer sets intermediate input values extracted with the same mechanism from another FMU as output values (see below for details and <<Communication-during-update>>),
* allow FMUs to inform the importer of an event, which occurs during an <<fmi3DoStep>> in case of CS or <<fmi3ActivateModelPartition>> in case of SE (see <<co-simulation-api>>, <<Communication-during-update>> and <<IntermediateUpdateModeSE>>),
* allow the importer in CS to request an early return from FMUs calling <<fmi3CallbackIntermediateUpdate>> with <<canReturnEarly, `canReturnEarly == fmi3True`>>, because of any event between communication points (see <<early-return>> and <<Computation-in-Co-Simulation>>).
This also enables cooperative multitasking of FMUs in CS.

Note that the call to <<fmi3CallbackIntermediateUpdate>> and thus entering the *Intermediate Update Mode* can only be triggered by the FMU itself.
The importer cannot actively trigger this and hence for some use cases (e.g. cooperative multitasking and setting of intermediate input values) relies on the callbacks from the FMUs to be able to realize these use cases properly.

A Co-Simulation FMU can provide values for its <<output>> variables at intermediate points between two consecutive communication points, and is able to accept new values for <<input>> variables at these intermediate points.
This is typically required when the FMU uses a numerical solver to integrate the FMU's internal state between communication points in <<fmi3DoStep>>.
This numerical solver assumes that the inputs are continuous in the integration interval, dictated by <<fmi3DoStep>>.
In FMI 2.0 Co-simulation, the intermediate inputs are provided by the use of extrapolations.
The intermediate update functions allow FMUs to receive inputs, and provide outputs, directly to the co-simulation algorithm, in those intermediate time points.

Due to the way numerical solvers estimate and correct the approximation error, these intermediate <<output>> values may be tentative or may be final.
It is possible for the FMU to inform the co-simulation algorithm whether the internal solver is in a tentative state, meaning that the output values computed from that state are also tentative, or if the internal solver has successfully completed the integration step, meaning that the FMU's internal state is final, and will never be change by the normal in the current execution of <<fmi3DoStep>>.
If the internal integration step has successfully completed, the co-simulation algorithm can forward intermediate outputs to other FMUs, where they can be used, for e.g., for extrapolation, interpolation, filtering or asynchronous co-simulation.
_[For tentative output values, the co-simulation algorithm must keep in mind that these values may change for the same time point.]_

The FMU requests updated intermediate <<input>> values for continuous variables every time they are required by the internal solver.
This can be either at tentative solver states or after successful integration steps.

Access to intermediate variables enables advanced Co-Simulation with interpolation/extrapolation techniques (such as polynomial extrapolation, TLM co-simulation, anti-alias filtering, smoothing of input) +
Moreover, this enables the same input approximation that was possible in FMI 2.0 with `fmi2SetInputDerivatives`, now evaluating the approximation polynomial and not within the FMU as in FMI 2.0.

<<figure-IntermediateUpdateMode>> summarizes the above description.
It illustrates that multiple intermediate internal solver steps, distinguishing between the final ones (with black-filled circles) and tentative ones (with white-filled circles).
It distinguishes the level of trust that can be placed in the tentative outputs (with dashed arrows) and in final outputs (with solid arrows).

.Overview of solver states and intermediate update during a communication step
[#figure-IntermediateUpdateMode]
image::images/intermediateupdate.svg[width=65%, align="center"]

The FMU signals the support of *Intermediate Update Mode* by the capability flag `providesIntermediateUpdate`.
The co-simulation algorithm signals the support for *Intermediate Update Mode* by providing a non-NULL callback-function pointer for <<fmi3CallbackIntermediateUpdate, `intermediateUpdate`>>.

The FMU enters *Intermediate Update Mode* by calling <<fmi3CallbackIntermediateUpdate>> within *Step Mode* (CS) or *Clock Activation Mode* (SE) and leaves the state towards state *Step Mode* (CS) or *Clock Activation Mode* (SE) if the function returns <<fmi3OK>> or <<fmi3Warning>>.
If the function returns <<fmi3Error>> the FMU enters state *Terminated*.
If the function returns <<fmi3Fatal>> the FMU enters the terminal state.

[[fmi3CallbackIntermediateUpdate,`fmi3CallbackIntermediateUpdate`]]
[source, C]
----
include::../headers/fmi3FunctionTypes.h[tag=CallbackIntermediateUpdate]
----

[[intermediateUpdateTime,`intermediateUpdateTime`]]
* <<intermediateUpdateTime>> is the internal value of the <<independent>> variable _[typically simulation time]_ of the FMU at which the callback has been called.
If an event happens or an <<outputClock>> ticks, <<intermediateUpdateTime>> is the time of event or <<outputClock>> tick.
If the FMU returns with <<earlyReturn,`earlyReturn == fmi3True`>> from <<fmi3DoStep>> then <<intermediateUpdateTime>> is the internal simulation time of the FMU of the last <<fmi3CallbackIntermediateUpdate>> call that signaled <<canReturnEarly,`canReturnEarly == fmi3True`>>.
<<intermediateUpdateTime>> is also the value of the <<independent>> variable of intermediate steps of the internal FMU solver.
The FMU must not call the callback function <<fmi3CallbackIntermediateUpdate>> with an <<intermediateUpdateTime>> that is smaller than the <<intermediateUpdateTime>> given in a previous call of <<fmi3CallbackIntermediateUpdate>> with `intermediateStepFinished == fmi3True`.

[[clocksTickedIA,`clocksTicked`]]
* The <<clocksTickedIA>> parameter is only used in Scheduled Execution and is ignored in Co-Simulation.
When <<clocksTickedIA,`clocksTicked == fmi3True`>>, it means that <<fmi3GetClock>> function must be called for gathering all <<clock>> related information about ticking <<outputClock,`output clocks`>> at <<intermediateUpdateTime>> and then activate the given model partitions accordingly.

[[intermediateVariableSetRequested,`intermediateVariableSetRequested`]]
* If <<intermediateVariableSetRequested,`intermediateVariableSetRequested == fmi3True`>>, the co-simulation algorithm should provide intermediate <<input>> variables by calling `fmi3Set{VariableType}` for continuous variables with <<intermediateUpdate,`intermediateUpdate = true`>>.
The set of variables for which the co-simulation algorithm can provide intermediate values is supplied through the <<requiredIntermediateVariables>> argument to <<fmi3Instantiate>>.
Note that if a co-simulation algorithm does not provide a new value for any of the variables contained in the set it registered, the last set value will be deemed to be the new value.

[[intermediateVariableGetAllowed,`intermediateVariableGetAllowed`]]
* If <<intermediateVariableGetAllowed,`intermediateVariableGetAllowed == fmi3True`>>, the co-simulation algorithm may collect intermediate output variables by calling `fmi3Get{VariableType}` for variables with <<intermediateUpdate,`intermediateUpdate = true`>>.
The set of variables for which the co-simulation algorithm can get values is supplied through the <<requiredIntermediateVariables>> argument to <<fmi3Instantiate>>.

[[intermediateStepFinished,`intermediateStepFinished`]]
* If <<intermediateStepFinished, `intermediateStepFinished == fmi3False`>>, the intermediate outputs of the FMU that the co-simulation algorithm inquires with `fmi3Get{VariableTypes}` resulting from tentative interval solver states and may still change for the same <<intermediateUpdateTime>> (e.g., if the solver deems the tentative state to cause a too high approximation error, it may go back in time and try to re-estimate the state using smaller internal time steps).
_[These outputs shall for example not be communicated to other connected FMUs._
_The use case for this is to let the co-simulation algorithm do some calculations for the FMU even for unfinished solver steps._
_This is beneficial for example for Transmission Line (TLM) co-simulation, where this helps to keep the interface cleaner._
_Instead of FMUs exchanging hard-to-understand variables such as "wave variable" and "characteristic impedance", they can exchange intuitive variables like "force" and "speed".]_

* If <<intermediateStepFinished, `intermediateStepFinished == fmi3True`>>, intermediate outputs inquired by the co-simulation algorithm with `fmi3Get{VariableTypes}` correspond to accepted internal solver steps and will not change (if the co-simulation algorithm does not rollback the FMU).  +
_[So the co-simulation algorithm could for example_

- _use the values obtained with `fmi3Get{VariableTypes}` with <<intermediateStepFinished, `intermediateStepFinished == fmi3True`>> to create an interpolation for the intermediate inputs of other FMUs._
- _use this information for plotting.]_

[[canReturnEarly,`canReturnEarly`]]
* When <<canReturnEarly,`canReturnEarly == fmi3True`>> the co-simulation algorithm can request the FMU to return early at the current <<intermediateUpdateTime>> time instant by returning with <<earlyReturnRequested,`earlyReturnRequested == fmi3True`>> from the callback function <<fmi3CallbackIntermediateUpdate>>.
If <<canReturnEarly,`canReturnEarly == fmi3False`>> the FMU will not do the early return, regardless of the co-simulation algorithm request.

[[earlyReturnRequested,`earlyReturnRequested`]]
* `earlyReturnRequested == fmi3True` requests the FMU to end the <<fmi3DoStep>> at a Newtonian time instant and return early.
This is only allowed if <<canReturnEarly,`canReturnEarly == fmi3True`>>.

[[earlyReturnTime,`earlyReturnTime`]]
* `earlyReturnTime` is used to tell the FMU at what time to return early from the current <<fmi3DoStep>> (at the earliest), if the return value of <<earlyReturnRequested>> of <<fmi3CallbackIntermediateUpdate>> is `fmi3True`.
If the <<earlyReturnTime>> is greater than the last signaled <<intermediateUpdateTime>>, the FMU may integrate up to the time instant <<earlyReturnTime>>.

When providing intermediate inputs to the FMU, it is important that the co-simulation algorithm provides the same input value for the same variable, at the same <<intermediateUpdateTime>>.
In other words, it is required that the calculation of inputs to the FMU be deterministic.
This is assumed by the internal solver.
If an input value changes for the same <<intermediateUpdateTime>>, the internal numerical solver may deem that re-estimate a state multiple times, without ever being able to decrease the approximation error.

Because the FMU intermediate outputs may be trusted when <<intermediateStepFinished,`intermediateStepFinished == fmi3True`>>, the FMU is not allowed to call <<intermediateUpdate>> for a simulation time point prior to or equal to a previous call whose argument <<intermediateStepFinished,`intermediateStepFinished == fmi3True`>>.

If the early return is conducted successfully by the FMU it must return with <<earlyReturn,`earlyReturn == fmi3True`>> from <<fmi3DoStep>>, indicating the current FMU time with <<lastSuccessfulTime>>.

The co-simulation algorithm can decide if a rollback of the FMU to reach the <<earlyReturnTime>> time is required or it may continue the simulation from <<lastSuccessfulTime>> for that FMU.
Note that *Event Mode* is not supported in Scheduled Execution.

Allowed Function Calls::

Function `fmi3Get{VariableType}`::
If <<intermediateVariableGetAllowed,`intermediateVariableGetAllowed == fmi3True`>>, the value of intermediate variables can be retrieved.
Intermediate variables are variables that are marked with attribute <<intermediateUpdate,`intermediateUpdate = true`>> in the <<modelDescription.xml>> and have been included in the <<requiredIntermediateVariables>> argument to <<fmi3Instantiate>>.

Function `fmi3Set{VariableType}`::
If <<intermediateVariableSetRequested,`intermediateVariableSetRequested == fmi3True`>>, the value of intermediate, continuous variables should be set.
Intermediate variables are variables that are marked with attribute <<intermediateUpdate,`intermediateUpdate = true`>> in the <<modelDescription.xml>> and have been included in the <<requiredIntermediateVariables>> argument to <<fmi3Instantiate>>.

There is a defined order of calling these functions: first all `fmi3Get{VariableType}` calls must be performed, then `fmi3Set{VariableType}` may be called. +
_[This is analogous to the calling sequence of of_ `fmi3Get{VariableType}` _and_ `fmi3Set{VariableType}` _calls at communication points.]_

Please refer to <<IntermediateUpdateModeSE>> for additional allowed functions in *Intermediate Update Mode* for SE.

The following code example shows an implementation of <<fmi3CallbackIntermediateUpdate>> that uses intermediate update to record a set of variables at every internal solver step:

[source, c]
----
include::Reference-FMUs/examples/bcs_intermediate_update.c[tag=IntermediateUpdateCallback]
----
