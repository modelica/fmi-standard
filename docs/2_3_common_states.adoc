=== State Machine and Semantics [[common-state-machine]]

All FMI interface types share a number of states in their respective state machines.
This chapter describes these common modes.
FMI specific state-machine modes will be described in their respective chapters.

.Common calling sequence for C functions of common states for all three FMI types.
[#figure-common-state-machine]
image::images/state-machines-common-states.svg[width=80%, align="center"]

==== Super State: FMU State Setable [[FMUStateSetable]]

The state *FMU State Setable* is entered when any of the following functions is called: <<fmi3InstantiateModelExchange>>, <<fmi3InstantiateCoSimulation>> and <<fmi3InstantiateScheduledExecution>>.
The state is left by either calling <<fmi3FreeInstance>> or when any of the functions called during *FMU State Setable* returns <<fmi3Fatal>>.
If any function called in super state *FMU State Setable* returns <<fmi3Error>>, the FMU enters state *Terminated*.

Allowed Function Calls::

[[fmi3InstantiateModelExchange,`fmi3InstantiateModelExchange`]]
Function `fmi3InstantiateModelExchange`::
FMU with initialization and events; between events, the simulation of continuous systems is performed with external integrators from the environment (see <<fmi-for-model-exchange>>).
The <<modelDescription.xml>> has to include a `<ModelExchange>` element to allow calling `fmi3InstantiateModelExchange`.

[[fmi3InstantiateCoSimulation,`fmi3InstantiateCoSimulation`]]
Function `fmi3InstantiateCoSimulation`::
Black box interface for Co-Simulation (see <<fmi-for-co-simulation>>).
The <<modelDescription.xml>> has to include a `<CoSimulation>` element to allow calling `fmi3InstantiateCoSimulation`.

[[fmi3InstantiateScheduledExecution,`fmi3InstantiateScheduledExecution`]]
Function `fmi3InstantiateScheduledExecution`::
Black box interface for Scheduled Execution (see <<fmi-for-scheduled-execution>>).
The <<modelDescription.xml>> has to include a `<ScheduledExecution>` element to allow calling `fmi3InstantiateScheduledExecution`.

[[fmi3Instantiate,`fmi3InstantiateXXX`]]
[source, C]
----
include::../headers/fmi3FunctionTypes.h[tags=Instantiate]
----

These functions return a new instance of an FMU with the respective interface type.
If a null pointer is returned, then instantiation failed.
In that case, <<logMessage>> is called with detailed information about the reason.
An FMU can be instantiated many times (provided capability flag `canBeInstantiatedOnlyOncePerProcess = false`).

The arguments of the instantiation functions are detailed as follows:

* `instanceName` is a unique identifier for the FMU instance.
It is used to name the instance, for example, in error or information messages generated by one of the `fmi3XXX` functions.
The argument `instanceName` must be a non empty string (in other words, must have at least one character that is not a white space).
_[If only one FMU is simulated, as `instanceName` attribute `modelName` or `<ModelExchange|CoSimulation|ScheduledExecution modelIdentifier="..">` from the XML schema `fmi3ModelDescription` might be used.]_

* `instantiationToken` can be used by the FMU to check that the <<modelDescription.xml>> file (see <<fmu-distribution>>) is compatible with the implementation of the FMU.
It is an opaque string generated by the FMU exporter that is stored in the xml file as mandatory attribute `instantiationToken` (see <<fmiModelDescription>>).
It must be passed unchanged to the FMU.
This argument must not be a null pointer.

[[resourceLocation,`resourceLocation`]]
* `resourceLocation` is a URI according to the http://datatracker.ietf.org/doc/rfc3986/[IETF RFC3986] syntax to indicate the location to the `resources` directory of the unzipped FMU archive.
The following schemes must be understood by the FMU:

** Mandatory -- `file` with absolute path (either including or omitting the authority component); +
** Optional -- `http`, `https`, `ftp`.

+
_[Example: An FMU is unzipped in directory `C:\temp\MyFMU`, then <<resourceLocation>> = `file:///C:/temp/MyFMU/resources` or `file:/C:/temp/MyFMU/resources`._ +
_The <<fmi3Instantiate>> functions are then able to read all needed resources from this directory, for example maps or tables used by the FMU.]_ +
A NULL pointer is supplied for <<resourceLocation>>, if no resource location can be provided to the FMU, which may occur

** if the FMU does not contain a resources folder, or
** if the environment is not able to provide an URI to the resources folder _[e.g., if the environment does not have a file system._
_If the FMU in such a case cannot be simulated, as it depends on the resources folder, it shall terminate with an error.]_


* `visible == fmi3False` defines that the interaction with the user should be reduced to a minimum (no application window, no plotting, no animation, etc.).
In other words, the FMU is executed in batch mode.
If `visible == fmi3True`, the FMU is executed in interactive mode, and the FMU might require to explicitly acknowledge start of simulation / instantiation / initialization (acknowledgment is non-blocking).

* If `loggingOn == fmi3False`, then any logging is disabled and the <<logMessage>> callback function is not called by the FMU.
If `loggingOn == fmi3True`, the FMU enables a vendor defined set of `<LogCategories>`.
This set should typically contain categories for messages that explain execution errors, like <<fmi3Discard>>, <<fmi3Error>> and <<fmi3Fatal>>.
The function <<fmi3SetDebugLogging>> gives more detailed control about required `<LogCategories>` (see <<definition-of-log-categories>>).

* If `eventModeUsed == fmi3True` the simulation algorithm can handle events, otherwise `fmi3EnterEventMode` must not be called.
The flag may only be `fmi3True`, if `hasEventMode == true`, otherwise the FMU must raise an error.
For FMUs that have clocks, `eventModeUsed == fmi3True` is required.

* `instanceEnvironment` is a pointer that can be passed to the <<fmi3CallbackIntermediateUpdate>> function in order that the simulation environment can provide an efficient way to identify the FMU that called <<fmi3CallbackIntermediateUpdate>>.

[[requiredIntermediateVariables,`requiredIntermediateVariables`]]
* `requiredIntermediateVariables` is an array of the value references of all <<input>> variables that the simulation algorithm intends to set and all <<output>> variables it intends to get during intermediate updates.
This set may be empty (<<nRequiredIntermediateVariables>> == 0) when the simulation algorithm does not intend to use intermediate update.
Only the variables in <<requiredIntermediateVariables>> may be accessed by the simulation algorithm using `fmi3Set{VariableType}` and `fmi3Get{VariableType}` during <<fmi3CallbackIntermediateUpdate>> callbacks.
All variables referenced in this set must be marked with the attribute <<intermediateUpdate,`intermediateUpdate = "true"`>> in the model description.
For Co-Simulation, these intermediate variables must be continuous-time variables.

[[nRequiredIntermediateVariables,`nRequiredIntermediateVariables`]]
* `nRequiredIntermediateVariables` gives the number of entries in <<requiredIntermediateVariables>>.
If <<nRequiredIntermediateVariables>> is zero <<requiredIntermediateVariables>> is not defined.

The arguments <<logMessage>>, <<intermediateUpdate>>, <<preemption-support,`lockPreemption`>>, and <<preemption-support,`unlockPreemption`>>, are function pointers provided by the simulation environment to be used by the FMU.
It is not allowed to change these functions between <<fmi3Instantiate>> and <<fmi3Terminate>> calls.
Additionally, a pointer to the environment is provided (`instanceEnvironment`) that needs to be passed to all of the callback functions, in order that those functions can utilize data from the environment, such as mapping a <<valueReference>> to a string, or assigning memory to a certain FMU instance.

In the default `fmi3FunctionTypes.h` file, typedefs for the function definitions are present to simplify the usage; this is non-normative.
These callback functions are defined below.

[[logMessage,`logMessage`]]
Callback function `logMessage`::
[source, C]
----
include::../headers/fmi3FunctionTypes.h[tags=CallbackLogMessage]
----

Pointer to a function that is called in the FMU _[usually if an `fmi3XXX` function does not behave as desired]_.

* `instanceName` is the instance name of the model that calls this function.
* `status` contains the severity of the message, see `fmi3Status`.
If <<logMessage>> is called with <<fmi3OK,`status == fmi3OK`>>, then the message is a pure information message.

* `category` is the category of the message.
The meaning of `category` is defined by the modeling environment that generated the FMU.
Depending on this modeling environment, none, some, or all, allowed values of `category` for this FMU are defined in the <<modelDescription.xml>> file via element `<fmiModelDescription><LogCategories>`, see <<definition-of-log-categories>>.
Only messages are provided by function <<logMessage>> that have a category according to a call to <<fmi3SetDebugLogging>>.

* `message` is a string that contains the message.
_[Typically, this function prints the message and stores it optionally in a log file.]_

All string-valued arguments passed by the FMU to the <<logMessage>> may be deallocated by the FMU directly after function <<logMessage>> returns.
The simulation environment must therefore create copies of these strings if it needs to access these strings later. +
The <<logMessage>> function will append a line break to each message when writing messages after each other to a terminal or a file (the messages may also be shown in other ways, for example, as separate text-boxes in a GUI).
The caller may include line-breaks (using "\n") within the message, but should avoid trailing line breaks. +
Variables can be referenced in a message with `pass:[#]<ValueReference>pass:[#]`.
If the character `pass:[#]` shall be included in the message, it has to be prefixed with `pass:[#]`, so `pass:[#]` is an escape character.

_[Example: The message `\#1365# must be larger than zero (used in IO channel ##4)` might be changed by the <<logMessage>> function to `body.m must be larger than zero (used in IO channel #4)` if `body.m` is the name of the variable with value reference 1365.]_

Callback function `intermediateUpdate`::

See <<fmi3CallbackIntermediateUpdate>> for details.

Callback function `lockPreemption` and `unlockPreemption`::

See <<preemption-support>> for details.

[[fmi3SetDebugLogging,`fmi3SetDebugLogging`]]
Function `fmi3SetDebugLogging`::
[source, C]
----
include::../headers/fmi3FunctionTypes.h[tags=SetDebugLogging]
----
The function controls debug logging that is output via the <<logMessage>> callback function.

* If `loggingOn == fmi3True`, debug logging is enabled, otherwise it is switched off.

* `nCategories` defines the length of the next argument `categories`
If `loggingOn == fmi3True` and `nCategories == 0`, then all debug messages shall be output.
If `loggingOn == fmi3True` and `nCategories > 0`, then only debug messages according to the `categories` argument shall be printed via the <<logMessage>> function.

* `categories` is a vector with `nCategories` elements.
The allowed values of `categories` are defined by the modeling environment that generated the FMU.
Depending on the generating modeling environment, none, some or all allowed values for `categories` for this FMU are defined in the <<modelDescription.xml>> file via element `<fmiModelDescription><LogCategories>`, see <<definition-of-log-categories>>.

[[fmi3Reset,`fmi3Reset`]]
Function `fmi3Reset`::
[source, C]
----
include::../headers/fmi3FunctionTypes.h[tags=Reset]
----

Is called by the environment to reset the FMU after a simulation run.
The FMU goes into the same state as if <<fmi3Instantiate>> would have been called.
All variables have their default values.
Before starting a new run <<fmi3EnterInitializationMode>> has to be called.

[[fmi3FreeInstance,`fmi3FreeInstance`]]
Function `fmi3FreeInstance`::
[source, C]
----
include::../headers/fmi3FunctionTypes.h[tags=FreeInstance]
----

Disposes the given instance, unloads the loaded model, and frees all the allocated memory and other resources that have been allocated by the functions of the FMU interface.
If a null pointer is provided for argument `instance`, the function call is ignored (does not have an effect).

Functions <<get-and-set-variable-values,`fmi3Get{VariableType}`>>::
See <<get-and-set-variable-values>> for the general mechanism to get variable values.
Getting variable might trigger computations.
_[If *Terminated* is entered because of an `fmi3Error` return value, retrieved values should only be used for debugging purposes.]_


Function <<fmi3GetFMUState>>::
Function <<fmi3SetFMUState>>::
Function <<fmi3FreeFMUState>>::
Function <<fmi3SerializedFMUStateSize>>::
Function <<fmi3SerializeFMUState>>::
Function <<fmi3DeSerializeFMUState>>::
All these allowed functions are described in <<get-set-fmu-state>>.

===== State: Instantiated [[Instantiated]]

In the state *Instantiated* the FMU can do one-time initializations and allocate memory.

[#table-math-instantiated]
[cols="2,1",options="header",]
|====
|Equations
|Functions

|Set variables latexmath:[(\mathbf{v}_{\mathit{initial=exact}}] or latexmath:[\mathbf{v}_{\mathit{initial=approx}})] and latexmath:[\mathbf{v}_{\mathit{variability \neq constant}}]
|`fmi3Set{VariableType}`

|Get variable <<start>> values as defined in <<modelDescription.xml>>.
|`fmi3Get{VariableType}`

|latexmath:[\mathbf{t}_{\mathit{start}} = startTime] +
Activate initialization equations latexmath:[\mathbf{f}_{\mathit{init}}].
|<<fmi3EnterInitializationMode>>
|====

Allowed Function Calls::

[[fmi3EnterConfigurationMode,`fmi3EnterConfigurationMode`]]
Function `fmi3EnterConfigurationMode`::
[source, C]
----
include::../headers/fmi3FunctionTypes.h[tags=EnterConfigurationMode]
----

Changes state to *Configuration Mode*.

[[fmi3EnterInitializationMode,`fmi3EnterInitializationMode`]]
Function `fmi3EnterInitializationMode`::
[source, C]
----
include::../headers/fmi3FunctionTypes.h[tags=EnterInitializationMode]
----

Changes state to *Initialization Mode*.

* `toleranceDefined` and `tolerance` depend on the interface type:

Model Exchange::
If `toleranceDefined == fmi3True`, then the model is called with a numerical integration scheme where the step size is controlled by using `tolerance` for error estimation (usually as relative tolerance).
In such a case all numerical algorithms used inside the model (for example, to solve non-linear algebraic equations) should also operate with an error estimation of an appropriate smaller relative tolerance.

Co-Simulation::
If `toleranceDefined == fmi3True`, then the communication step size of the FMU is controlled by error estimation.
In case the FMU utilizes a numerical integrator with variable step size and error estimation, it is suggested to use `tolerance` for the error estimation of the integrator (usually as relative tolerance). +
An FMU for Co-Simulation might ignore this argument.

[[startTime,`startTime`]]
* `startTime` and `stopTime` can be used to check whether the model is valid within the given boundaries, or to allocate the necessary memory for storing results.
`startTime` is the <<fixed>> <<initial>> value of the <<independent>> variable and inherits its unit.
+
_[It is defined with <<causality>> = <<independent>> in the <<modelDescription.xml>>._
_If the <<independent>> variable is `time`, `startTime` is the starting time of initialization.]_

* If `stopTimeDefined == fmi3True`, then `stopTime` is the final value of the <<independent>> variable and inherits its unit.
If the environment tries to compute past `stopTime`, the FMU has to return <<fmi3Error,`fmi3Status == fmi3Error`>>.
If `stopTimeDefined == fmi3False`, then no final value of the <<independent>> variable is defined and argument `stopTime` is meaningless.

// TODO: Verweis zu get-set-state and list all functions here again

Function `fmi3Set{VariableType}`::

This function can be called for variables with <<variability>> latexmath:[\neq] <<constant>> and with <<initial>> = <<exact>> or <<approx>>.
The intention is to set <<start>> and guess values for these variables.

===== State: Initialization Mode [[InitializationMode]]

The *Initialization Mode* is used by the simulation algorithm to compute consistent initial conditions for the overall system.
Equations are active to determine the initial FMU state, as well as all <<output,`outputs`>> (and optionally other variables exposed by the exporting tool).
Artificial or real algebraic loops over connected FMUs in *Initialization Mode* may be handled by using appropriate numerical algorithms.

In *Initialization Mode*, the FMU computes at the start time latexmath:[\mathbf{t}_0] initial values for continuous-time <<state,`states`>> latexmath:[\mathbf{x}_c(\mathbf{t}_0)], and for the previous (internal) discrete-time states latexmath:[\mathbf{x}_d(\mathbf{t}_0)], by utilizing extra equations not present in the other modes (for example, equations to define the <<start>> value for a <<state>> or for the derivative of a <<state>>).

[#table-math-initializationMode]
[cols="2,1",options="header",]
|====
|Equations
|Functions

|Set variables latexmath:[\mathbf{v}_{\mathit{initial=exact}}] +
_[<<parameter,`parameters`>> latexmath:[\mathbf{p}] and
continuous-time <<state,`states`>> latexmath:[\mathbf{x}_{c,\mathit{initial=exact}}] are included here]_
|`fmi3Set{VariableType}`

|Set continuous-time and discrete-time <<input,`inputs`>>  latexmath:[\mathbf{u}_{c+d}(\mathbf{t}_{start})]
|`fmi3Set{VariableType}`

|latexmath:[(\mathbf{v}_{\mathit{causality \neq parameter}}, \mathbf{T}_{\mathit{shift}}, \mathbf{T}_{\mathit{interval}}) := \mathbf{f}_{\mathit{init}}(\mathbf{u}_{c+d}, \mathbf{t}_{start}, \mathbf{v}_{\mathit{initial=exact}})]
|`fmi3Get{VariableType}`, <<fmi3GetContinuousStates>>, <<fmi3GetDirectionalDerivative>>, <<fmi3GetShift>>, <<fmi3GetInterval>>

a|
* evaluate latexmath:[\mathbf{f}_{\mathit{init}}], if no `fmi3GetXXX` function was called
* deactivate initialization equations latexmath:[\mathbf{f}_{\mathit{init}}].
* Model Exchange:
  - activate event equations latexmath:[\mathbf{f}_{\mathit{event}}]
  - latexmath:[\mathbf{t}:=(\mathbf{t}_{\mathit{start}}, 0)]

|<<fmi3ExitInitializationMode>>
|====

Allowed Function Calls::

[[fmi3ExitInitializationMode,`fmi3ExitInitializationMode`]]
Function `fmi3ExitInitializationMode`::
[source, C]
----
include::../headers/fmi3FunctionTypes.h[tags=ExitInitializationMode]
----

Changes the state to *Event Mode* (ME), *Step Mode* (CS) or *Clock Activation Mode* (SE).
_[This function switches off all initialization equations.]_

Function <<fmi3GetShiftDecimal>>::
Function <<fmi3GetShiftFraction>>::
See <<fmi3GetShift>>.

Function <<fmi3GetIntervalDecimal>>::
Function <<fmi3GetIntervalFraction>>::
See <<fmi3GetInterval>>.

Function <<fmi3GetContinuousStates>>::
See <<fmi3GetContinuousStates>> for Model-Exchange only.

Function <<fmi3GetDirectionalDerivative>>::
See <<fmi3GetDirectionalDerivative>>.

Function `fmi3Set{VariableType}`::
This function can be called for variables with <<variability>> latexmath:[\neq] <<constant>> and with <<initial>> = <<exact>>.

Function `fmi3Get{VariableType}`::
The variables that can be retrieved by `fmi3Get{VariableType}` calls are defined in the XML file as elements `<ModelStructure><InitialUnknown>`.
For variables with <<causality>> = <<output>> or continuous-time <<state,`states`>> or state derivatives.

===== State: Configuration Mode [[ConfigurationMode]]

// TODO: move outside super state? See https://github.com/modelica/fmi-standard/issues/1276

The *Configuration Mode* allows setting <<structuralParameter, `structural parameters`>> for example to resize array variables.
<<fmi3EnterConfigurationMode>> must not be called if the FMU contains no <<structuralParameter,`structural parameter`>>.

[#table-math-configurationMode]
[cols="2,1",options="header",]
|====
|Equations
|Functions

|Set latexmath:[\mathbf{v}_{\mathit{causality=structuralParameter}}] +
_[<<structuralParameter,`structuralParameters`>> with_ latexmath:[\mathbf{p}_{\mathit{variability=fixed}}] _or_ latexmath:[\mathbf{p}_{\mathit{variability=tunable}}] _are included here]_
|`fmi3Set{VariableType}`

|Exit *Configuration Mode* +
Resize arrays with dimensions that just changed.
|<<fmi3ExitConfigurationMode>>
|====

Allowed Function Calls::

[[fmi3ExitConfigurationMode,`fmi3ExitConfigurationMode`]]
Function `fmi3ExitConfigurationMode`::
[source, C]
----
include::../headers/fmi3FunctionTypes.h[tags=ExitConfigurationMode]
----

Exits the *Configuration Mode* and returns to state *Instantiated*.

Function `fmi3Set{VariableType}`::
Only for variables with <<causality>> = <<structuralParameter>> and <<variability>> = <<fixed>> or <<variability>> = <<tunable>>.

===== State: Terminated [[Terminated]]
In this state, the final values of all variables at the final time of a simulation can be retrieved.

[#table-math-terminated]
[cols="2,1",options="header",]
|====
|Equations
|Functions

|latexmath:[\mathbf{v}_{\mathit{causality \neq parameter}}:=\mathbf{f}_{\mathit{term}}(\mathbf{t}, \mathbf{^{\bullet}v(t)})]
|`fmi3Get{VariableType}`, <<fmi3GetContinuousStates>>, <<fmi3GetDirectionalDerivative>>, <<fmi3GetOutputDerivatives>>
|====

Allowed Function Calls::

Function <<fmi3GetDirectionalDerivative>>::
Function <<fmi3GetOutputDerivatives>>::
Function <<fmi3GetContinuousStates>>::
No restrictions.

==== Super State: Initialized [[Initialized]]

This super state is entered by the FMU when <<fmi3ExitInitializationMode>> is called.

[#table-math-initialized]
[cols="2,1",options="header",]
|====
|Equations
|Functions

|Activate termination equations latexmath:[\mathbf{f}_{\mathit{term}}].
|<<fmi3Terminate>>
|====

Allowed Function Calls::

[[fmi3Terminate,`fmi3Terminate`]]
Function `fmi3Terminate`::
[source, C]
----
include::../headers/fmi3FunctionTypes.h[tags=Terminate]
----

Changes state to *Terminated*.

===== State: Event Mode [[EventMode]]

*Event Mode* is only available in Model Exchange and Co-Simulation.
In *Event Mode* all continuous-time, discrete-time equations and active model partitions are evaluated.

There are multiple kinds of events that require a transition to *Event Mode*:

* <<time-event,Time events>>: The time instant of such an event is signaled to the importer by
  - the argument <<nextEventTime>> of <<fmi3UpdateDiscreteStates>>, or
  - the arguments of <<fmi3GetShift>> and <<fmi3GetInterval>>.
* <<state-event,State events>>
* <<input-event,Input events>>
* <<step-event,Step events>>

[#table-math-event-mode]
[cols="5,3",options="header",]
|====
|Equations
|Functions

|Set <<tunable>> <<parameter,`parameters`>> latexmath:[\mathbf{p}_{\mathit{tune}}]
|`fmi3Set{VariableType}`

|Set continuous-time and discrete-time <<input,`inputs`>> latexmath:[\mathbf{u}_{c+d}(\mathbf{t})]
|`fmi3Set{VariableType}`

a|
* Activate clocks and respective model partitions in latexmath:[\mathbf{f}_{\mathit{event}}]
* Deactivate clocks and
  - reset respective clocked variables to their previous values: latexmath:[\mathbf{v}_{\mathit{d}} = {}^\bullet\mathbf{v}_{\mathit{d}}]
  - deactivate respective model partitions in latexmath:[\mathbf{f}_{\mathit{event}}]
|<<fmi3SetClock>>

a|
* Activate output clocks and respective model partitions in latexmath:[\mathbf{f}_{\mathit{event}}] +
* latexmath:[(\mathbf{y}_{c+d}, \mathbf{\dot{x}}_c, \mathbf{x}_{c+d}, \mathbf{z}, \mathbf{w}_{c+d}, \mathbf{T}_{\mathit{next}}, \mathbf{T}_\mathit{interval}) = \mathbf{f}_{\mathit{event}}({}^\bullet\mathbf{x}_{c+d}, \mathbf{u}_{c+d}, \mathbf{p}, \mathbf{t})]
|<<fmi3GetClock>>,
<<fmi3GetInterval>>, +
`fmi3Get{VariableType}`,
<<fmi3GetDerivatives>>,
<<fmi3GetContinuousStates>>,
<<fmi3GetEventIndicators>>

a|
* evaluate latexmath:[\mathbf{f}_{\mathit{event}}], if no `fmi3GetXXX` function was called in this instant of super-dense time
* update previous values of discrete states: latexmath:[{}^\bullet\mathbf{x}_d:=\mathbf{x}_d]
* deactivate active clocks and respective model partitions in latexmath:[\mathbf{f}_{\mathit{event}}]
* increment super-dense time: latexmath:[\mathit{\mathbf{t}:=(\mathbf{t}_R, \mathbf{t}_I + 1)}]
|<<fmi3UpdateDiscreteStates>>

|====


Allowed Function Calls::

Function <<fmi3UpdateDiscreteStates>>::
When the importer converges on a solution for event handling at the current super-dense time step it calls
 <<fmi3UpdateDiscreteStates>> to determine if a another event iteration is required (introducing a new instance of super-dense time) or *Event Mode* can be exited.

[[fmi3UpdateDiscreteStates,`fmi3UpdateDiscreteStates`]]
[source, C]
----
include::../headers/fmi3FunctionTypes.h[tag=UpdateDiscreteStates]
----

[[discreteStatesNeedUpdate,`discreteStatesNeedUpdate`]]
* When `discreteStatesNeedUpdate == fmi3True`, the importer must stay in *Event Mode* for another event iteration.

[[terminateSimulation,`terminateSimulation`]]
* When <<terminateSimulation,`terminateSimulation == fmi3True`>>, the model requested to stop integration and the importer must call <<fmi3Terminate>>.

[[nominalsOfContinuousStatesChanged,`nominalsOfContinuousStatesChanged`]]
* If argument `nominalsOfContinuousStatesChanged == fmi3True`, then at least one nominal value of the <<state,`states`>> has changed and can be inquired with <<fmi3GetNominalsOfContinuousStates>>. +
This argument is only valid in Model Exchange.

[[valuesOfContinuousStatesChanged,`valuesOfContinuousStatesChanged`]]
* If argument `valuesOfContinuousStatesChanged == fmi3True`, then at least one continuous state has changed its value. +
[[state,`state`]]
The new values of the <<state,`states`>> can be inquired with <<fmi3GetContinuousStates>> or individually for each state for which <<reinit, `reinit = true`>> by calling `fmi3GetFloat64`. +
This argument is only valid in Model Exchange.

[[nextEventTimeDefined,`nextEventTimeDefined`]]
* When <<nextEventTimeDefined,`nextEventTimeDefined == fmi3True`>>, the next time event is known and <<nextEventTime>> has a valid value.

[[nextEventTime,`nextEventTime`]]
* The return argument <<nextEventTime>> contains the absolute time of the next time event if <<nextEventTimeDefined,`nextEventTimeDefined == fmi3True`>>.
The importer must compute up to <<nextEventTime>> (or if needed slightly further) and then enter *Event Mode* using <<fmi3EnterEventMode>> with argument <<timeEvent,`timeEvent == fmi3True`>>.
The FMU must handle this time event at the first call to <<fmi3EnterEventMode>> with <<timeEvent,`timeEvent == fmi3True`>> at or after <<nextEventTime>>. +
_[This might be needed if, for example, the time resolution of the importer does not allow hitting the precise <<nextEventTime>>._
_If the time offset proves to be too large, the FMU could issue a log message and return fmi3Error._
_The user can improve time settings of the importer to alleviate the issues.]_ +
If another (e.g. <<state event>>) event happens before that <<nextEventTime>>, the previous definition of <<nextEventTime>> becomes obsolete.


[[fmi3EnterContinuousTimeMode,`fmi3EnterContinuousTimeMode`]]
Function <<fmi3EnterContinuousTimeMode>>::
[source, C]
----
include::../headers/fmi3FunctionTypes.h[tags=EnterContinuousTimeMode]
----

// TODO only in ME

The model enters *Continuous-Time Mode* and all discrete-time equations become inactive and all relations are "frozen". +
This function has to be called when changing from *Event Mode* (after the global event iteration in *Event Mode* over all involved FMUs and other models has converged) into *Continuous-Time Mode*. +

_[This function might be used additionally for the following purposes:_
* _If the FMU stores results internally on file, then the results after the initialization and/or the event has been processed can be stored._
* _If the FMU contains dynamically changing states, then a new state selection might be performed with this function.]_

Function <<fmi3EnterStepMode>>::
[[fmi3EnterStepMode,`fmi3EnterStepMode`]]
[source, C]
----
include::../headers/fmi3FunctionTypes.h[tag=EnterStepMode]
----

// TODO: only in CS

Once all events are handled and `discreteStatesNeedUpdate == fmi3False`, the FMU should be pushed to *Step Mode* by calling <<fmi3EnterStepMode>>, unless it requests to terminate the Co-Simulation by setting  <<terminateSimulation,`terminateSimulation`> to `fmi3True`.
In this case, a new step can be started from the current communication point time.

<<fmi3GetClock>>::
[[fmi3GetClock,`fmi3GetClock`]]
is used to inquire the status of <<triggered>> <<outputClock,`output clocks`>> this function during *Event Mode* and *Intermediate Update Mode*.

<<fmi3SetClock>>::
[[fmi3SetClock,`fmi3SetClock`]]
For <<inputClock,`input clocks`>>, <<fmi3SetClock>> is called after entering *Event Mode* to set the activation status of <<clock,`clocks`>>.
This function can be called several times for the same <<clock>>, only if re-computations of clock state are needed during *Event Mode*.

<<fmi3GetIntervalDecimal>> & <<fmi3GetIntervalFraction>>::
For <<clock,`input clocks`>> it is allowed to call these functions to query the next activation interval.
For <<aperiodic>> <<clock,`clocks`>>, these functions must be called in every *Event Mode* where this clock was activated.
For <<countdown>> <<clock,`clocks`>>, these functions must be called in every *Event Mode*.

<<fmi3SetIntervalDecimal>> & <<fmi3SetIntervalFraction>>::
These functions can be called only at the first activation of <<fixedClock>> <<clocks>>.

Function <<fmi3GetDirectionalDerivative>>::
See <<fmi3GetDirectionalDerivative>>.


==== Event Handling

This concerns the following API calls: <<fmi3SetClock>>, <<fmi3GetClock>>, <<fmi3SetIntervalDecimal>>, <<fmi3SetIntervalFraction>>, <<fmi3GetIntervalDecimal>>, <<fmi3GetIntervalFraction>>

A <<clock>> event is handled by the environment in the following way:

_[TODO: Move this section into Common and there the Event Mode description.]_

Enter event mode::
The *Event Mode* is entered after initialization (call to function <<fmi3ExitInitializationMode>>) or during simulation with a call to the function <<fmi3EnterEventMode>>.
The FMU activates <<outputClock,`output clocks`>>.

Synchronize clock activation and intervals with the environment::

_[TODO: remove usage of clock tick and use clock activation instead (Note to self: search also for "`clock` tick").]_

The <<clock>> activation status can be inquired with the function <<fmi3GetClock>>.
The environment calls the function <<fmi3SetClock>> for periodic <<clock,`clocks`>> and <<inputClock,`input clocks`>>.
Moreover the current <<clock>> intervals may be inquired with the function <<fmi3GetIntervalDecimal>> or <<fmi3GetIntervalFraction>> and set with the function <<fmi3SetIntervalDecimal>> <<fmi3SetIntervalFraction>>.
_[In the Modelica language this is the value returned by the interval() operator._
_The initialization of intervals is needed for <<output>> and <<input>> sample times if a <<clock>> ticks the first time._
_The FMU determines the interval itself at subsequent <<clock>> ticks.]_

_[TODO: This should not be in Event Handling, merge into the other section for clock intervals with the table.]_

_[TODO: Write here a few sentences about how clocks interact with the event iteration.]_

Leave event mode::
The function <<fmi3UpdateDiscreteStates>> evaluates the discrete-time equations, provided the corresponding <<clock>> is active and the discrete-time equations have not already been evaluated with calls to `fmi3Get{VariableType}` functions.
Clocks are automatically deactivated by <<fmi3UpdateDiscreteStates>> and by <<fmi3Reset>>.
_[This handling of discrete-time states and <<time event,`time events>> is forward compatible with FMI 2.0 for any model that could be treated with FMI 2.0 and is exported again using the new features._
_The environment may ignore the new functions <<fmi3SetClock>>, <<fmi3GetClock>>, <<fmi3SetIntervalDecimal>>, <<fmi3SetIntervalFraction>>, <<fmi3GetIntervalDecimal>> and <<fmi3GetIntervalFraction>>._
_The new functions are needed for FMUs with input sample times and to set discrete-time states in model-based control applications or if algebraic loops are present among discrete-time equations of multiple connected FMUs.]_





===== State: Reconfiguration Mode [[ReconfigurationMode]]

The *Reconfiguration Mode* allows setting <<structuralParameter, `structural parameters`>> for example to resize array variables.
This state must not be entered, if the FMU contains no <<structuralParameter,`structural parameters`>>.

[#table-math-reconfigurationMode]
[cols="2,1",options="header",]
|====
|Equations
|Functions

|Set latexmath:[\mathbf{v}_{\mathit{causality=structuralParameter}}] +
_[<<structuralParameter,`structuralParameters`>> with_ latexmath:[\mathbf{p}_{\mathit{variability=tunable}}] _are included here]_
|`fmi3Set{VariableType}`

|Exit *Reconfiguration Mode* +
Resize arrays with dimensions that just changed.
|<<fmi3ExitConfigurationMode>>
|====

Allowed Function Calls::

Function <<fmi3ExitConfigurationMode>>::
<<fmi3ExitConfigurationMode>> returns back to *Event Mode* (ME), *Step Mode* (CS) or *Clock Activation Mode* (SE).

Function `fmi3Set{VariableType}`::
Only for variables with <<causality>> = <<structuralParameter>> and <<variability>> = <<tunable>>.

==== State: Intermediate Update Mode [[IntermediateUpdateMode]]

This state is only available in Co-Simulation and Scheduled Execution.

_[The following use cases are enabled:_

* _Access to intermediate variables enables advanced Co-Simulation with interpolation/extrapolation techniques (such as polynomial extrapolation, Transmission Line Modeling (TLM) co-simulation, anti-alias filtering, smoothing of input among others)._
* _Intermediate Update Mode enables the same input approximation that was possible in FMI 2.0 with `fmi2SetInputDerivatives`, by evaluating the approximation polynomial and not within the FMU as in FMI 2.0._
* _FMUs can inform the importer about an event, which occurs during an <<fmi3DoStep>> in case of CS (see <<co-simulation-api>>)._
* _The Co-Simulation algorithm can request an <<early-return,early return>> from <<fmi3DoStep>>, because of an event between communication points (see <<early-return>> and <<Computation-in-Co-Simulation>>)._
* _A model partition of an Scheduled Execution FMU calls <<fmi3CallbackIntermediateUpdate>> to signal clock activations with `clocksTicked == fmi3True`._

_Note that the call to <<fmi3CallbackIntermediateUpdate>> and thus entering the *Intermediate Update Mode* can only be triggered by the FMU itself._
_The importer cannot actively trigger this and hence for some use cases (e.g. cooperative multitasking and setting of intermediate input values) it relies on the callbacks from the FMUs to be able to realize these use cases properly.]_

A Co-Simulation FMU can provide values for its <<output>> variables at intermediate points between two consecutive communication points, and is able to accept new values for <<input>> variables at these intermediate points.
This is typically required when the FMU uses a numerical solver to integrate the FMU's internal state between communication points in <<fmi3DoStep>>.
This numerical solver assumes that the inputs are continuous in the integration interval, dictated by <<fmi3DoStep>>.
In FMI 2.0 Co-simulation, the intermediate inputs are provided by the use of extrapolations.
The intermediate update functions allow FMUs to receive inputs, and provide outputs, directly to the co-simulation algorithm, in those intermediate time points.

// TODO for Irina/Matthias: what is Intermediate Update Mode used for in Scheduled Execution: Please provide small paragraph like previous paragraph

Due to the way numerical solvers estimate and correct the approximation error, these intermediate <<output>> values may be tentative or may be final.
It is possible for the FMU to inform the co-simulation algorithm whether the internal solver is in a tentative state, meaning that the output values computed from that state are also tentative, or if the internal solver has successfully completed the integration step, meaning that the FMU's internal state is final, and will never be changed in the current execution of <<fmi3DoStep>>.
If the internal integration step has been successfully completed, the co-simulation algorithm can forward intermediate outputs to other FMUs, where they can be used, for e.g., for extrapolation, interpolation, filtering or asynchronous co-simulation.

<<figure-IntermediateUpdateMode>> summarizes the above description.
It illustrates multiple intermediate internal solver steps, distinguishing between the final ones (with black-filled circles) and tentative ones (with white-filled circles).
It distinguishes the level of trust that can be placed in the tentative outputs (with dashed arrows) and in final outputs (with solid arrows).

.Overview of solver states and intermediate update during a communication step
[#figure-IntermediateUpdateMode]
image::images/intermediateupdate.svg[width=65%, align="center"]

The FMU signals the support of *Intermediate Update Mode* via the capability flag `providesIntermediateUpdate`.
The co-simulation algorithm signals the support for *Intermediate Update Mode* by providing a non-NULL callback-function pointer for <<fmi3CallbackIntermediateUpdate, `intermediateUpdate`>>.

The FMU enters *Intermediate Update Mode* by calling <<fmi3CallbackIntermediateUpdate>> within *Step Mode* (CS) or *Clock Activation Mode* (SE) and leaves the state towards *Step Mode* (CS) or *Clock Activation Mode* (SE) when the function returns.

[[fmi3CallbackIntermediateUpdate,`fmi3CallbackIntermediateUpdate`]]
[source, C]
----
include::../headers/fmi3FunctionTypes.h[tag=CallbackIntermediateUpdate]
----

[[intermediateUpdateTime,`intermediateUpdateTime`]]
* <<intermediateUpdateTime>> is the internal value of the <<independent>> variable _[typically simulation time]_ of the FMU at which the callback has been called for intermediate and final steps.
If an event happens or an <<outputClock>> ticks, <<intermediateUpdateTime>> is the time of event or <<outputClock>> tick.
In Co-Simulation, <<intermediateUpdateTime>> is restricted by the arguments to <<fmi3DoStep>> as follows: +
<<currentCommunicationPoint>> latexmath:[\leq] <<intermediateUpdateTime>> latexmath:[\leq] (<<currentCommunicationPoint>> + <<communicationStepSize>>). +
The FMU must not call the callback function <<fmi3CallbackIntermediateUpdate>> with an <<intermediateUpdateTime>> that is smaller than the <<intermediateUpdateTime>> given in a previous call of <<fmi3CallbackIntermediateUpdate>> with `intermediateStepFinished == fmi3True`.

[[clocksTicked,`clocksTicked`]]
* The <<clocksTicked>> parameter is only used in Scheduled Execution and is ignored in Co-Simulation.
When <<clocksTicked,`clocksTicked == fmi3True`>>, it means that <<fmi3GetClock>> function must be called for gathering all <<clock>> related information about ticking <<outputClock,`output clocks`>> at <<intermediateUpdateTime>> and then activate the given model partitions accordingly. +
_[In Co-Simulation, the FMU must return from <<fmi3DoStep>> with <<clocksAboutToTick, `clocksAboutToTick == fmi3True`>> in this case.]_

[[intermediateVariableSetRequested,`intermediateVariableSetRequested`]]
* If <<intermediateVariableSetRequested,`intermediateVariableSetRequested == fmi3True`>>, the co-simulation algorithm may provide intermediate values for continuous <<input>> variables with <<intermediateUpdate,`intermediateUpdate = true`>> by calling `fmi3Set{VariableType}`.
The set of variables for which the co-simulation algorithm will provide intermediate values is declared through the <<requiredIntermediateVariables>> argument to <<fmi3Instantiate>>.
If a co-simulation algorithm does not provide a new value for any of the variables contained in the set it registered, the last value set remains.

[[intermediateVariableGetAllowed,`intermediateVariableGetAllowed`]]
* If <<intermediateVariableGetAllowed,`intermediateVariableGetAllowed == fmi3True`>>, the co-simulation algorithm may collect intermediate output variables by calling `fmi3Get{VariableType}` for variables with <<intermediateUpdate,`intermediateUpdate = true`>>.
The set of variables for which the co-simulation algorithm can get values is supplied through the <<requiredIntermediateVariables>> argument to <<fmi3Instantiate>>.

[[intermediateStepFinished,`intermediateStepFinished`]]
* If <<intermediateStepFinished, `intermediateStepFinished == fmi3False`>>, the intermediate outputs of the FMU that the co-simulation algorithm inquires with `fmi3Get{VariableTypes}` resulting from tentative internal solver states and may still change for the same <<intermediateUpdateTime>> _[e.g., if the solver deems the tentative state to cause a too high approximation error, it may go back in time and try to re-estimate the state using smaller internal time steps]_. +
If <<intermediateStepFinished, `intermediateStepFinished == fmi3True`>>, intermediate outputs inquired by the co-simulation algorithm with `fmi3Get{VariableTypes}` correspond to accepted internal solver step.

[[canReturnEarly,`canReturnEarly`]]
* When <<canReturnEarly,`canReturnEarly == fmi3True`>> the FMU signals to the co-simulation algorithm its ability to return early from the current <<fmi3DoStep>>. +
This argument is ignored in Scheduled Execution.

[[earlyReturnRequested,`earlyReturnRequested`]]
* `earlyReturnRequested`: If and only if <<canReturnEarly,`canReturnEarly == fmi3True`>>, the co-simulation algorithm may request the FMU to return early from <<fmi3DoStep>> by setting `earlyReturnRequested == fmi3True`. +
This argument is ignored in Scheduled Execution.

[[earlyReturnTime,`earlyReturnTime`]]
* `earlyReturnTime` is used to signal the FMU at which time to return early from the current <<fmi3DoStep>>, if the return value of <<earlyReturnRequested, `earlyReturnRequested == fmi3True`>>.
If the <<earlyReturnTime>> is greater than the last signaled <<intermediateUpdateTime>>, the FMU may integrate up to the time instant <<earlyReturnTime>>. +
This argument is ignored in Scheduled Execution.

.Mathematical description of *Intermediate Update Mode*.
[#table-math-intermediateUpdateMode]
[cols="2,1",options="header",]
|====
|Equations in *Intermediate Update Mode*
|Functions

|Get intermediate variable values latexmath:[\mathbf{v}_u(t_u)]
|`fmi3Get{VariableType}`

|Set intermediate input variables latexmath:[\mathbf{u}_u(t_u)]
|`fmi3Set{VariableType}`

// TODO Irina & Matthias: do we need to add lines for <<fmi3GetIntervalDecimal>> & <<fmi3GetIntervalFraction>>

|====


Allowed Function Calls::

Function `fmi3Get{VariableType}`::
This function can be called for intermediate variables, if <<intermediateVariableGetAllowed,`intermediateVariableGetAllowed == fmi3True`>>.
Intermediate variables are variables that are marked with attribute <<intermediateUpdate,`intermediateUpdate = true`>> in the <<modelDescription.xml>> and have been included in the <<requiredIntermediateVariables>> argument to <<fmi3Instantiate>>.

Function `fmi3Set{VariableType}`::
This function can be called for intermediate input variables, if <<intermediateVariableSetRequested,`intermediateVariableSetRequested == fmi3True`>>.
Intermediate input variables are input variables that are marked with attribute <<intermediateUpdate,`intermediateUpdate = true`>> in the <<modelDescription.xml>> and have been included in the <<requiredIntermediateVariables>> argument of <<fmi3Instantiate>>.

There is a defined order of calling these functions: first all `fmi3Get{VariableType}` calls must be performed, then `fmi3Set{VariableType}` may be called. +
_[This is analogous to the calling sequence of_ `fmi3Get{VariableType}` _and_ `fmi3Set{VariableType}` _calls at communication points.]_

Additionally to the functions listed above, Scheduled Execution allows calling the following functions:

Function <<fmi3GetClock>>::
The scheduling algorithm uses <<fmi3GetClock>> to determine which clock is active. +
_[For efficiency, <<fmi3GetClock>> should only be called if <<clocksTicked, `clocksTicked == fmi3True`>>.]_ +
Depending on the clock activation state, the scheduling algorithm can call `fmi3Set{VariableType}` and `fmi3Get{VariableType}` for variables associated with the corresponding <<clock>>.
If an <<outputClock>> with an attribute <<triggeredBy>> is active, the scheduling algorithm schedules the model partition associated with the corresponding <<inputClock>>. +
For an <<outputClock>> only the first call of `fmi3GetClock` for a specific activation of this <<clock>> signals `fmi3ClockActive`.
The FMU sets the reported activation state immediately back to `fmi3ClockInactive` for following `fmi3GetClock` calls for that <<clock>> until this <<outputClock>> is activated again.

// TODO: Irina & Matthias: do we need to allow activateModelPartition here in *Intermediate Update Mode*?

Functions <<fmi3GetIntervalDecimal>> & <<fmi3GetIntervalFraction>>::
These function calls are allowed for time-based <<clocks>>.

// TODO: Irina & Matthias: Do you need a delay for triggered output clocks to activate a model partition?

_[In Scheduled Execution it cannot be determined which model partition has called <<fmi3CallbackIntermediateUpdate>>, because multiple model partitions can be active at the same time._
_Since all information about which model partition to activate is coded into its corresponding clock, there is no need to know which potentially other model partition activated this clock.]_

// TODO: consider moving this to the implementers guide (or entirely delete here)
//The following code example shows an implementation of <<fmi3CallbackIntermediateUpdate>> that uses intermediate update ///to record a set of variables at every internal solver step:
//[source, c]
//----
//include::Reference-FMUs/examples/bcs_intermediate_update.c[tag=IntermediateUpdateCallback]
//----
