=== State Machine and Semantics [[common-state-machine]]

To define allowed calling sequences of FMI functions, state machines are used.
Each state of the state machine corresponds to a certain phase of a simulation.
All interface types share a number of states in their respective state machines.
This chapter describes these common states used in at least two of the interface types.
State-machine states specific to a single interface type will be described in their respective chapters.

[[each-state-description]]
Each state description lists the governing equations and actions and the corresponding API functions influencing these equations in a table (not defining the calling order), and also lists the allowed function calls and usage restrictions.

.Common calling sequence for C functions of common states for at least two of the interface types.
[#figure-common-state-machine]
image::images/state-machines-common-states.svg[width=80%, align="center"]

The state machine is given here as UML 2.0 state machine.
If a transition is labeled with one or more function names (for example, <<fmi3EnterInitializationMode>>, <<fmi3EnterEventMode>>), the transition is taken if the function call returns successfully (not `NULL` for <<fmi3Instantiate>> or <<fmi3OK>> and <<fmi3Warning>> for all other functions).
This way, importer and FMU can determine in which state the FMU is.

==== Super State: FMU State Setable [[FMUStateSetable,*FMU State Setable*]]

The state <<FMUStateSetable>> is entered when any of the following functions is called: <<fmi3InstantiateModelExchange>>, <<fmi3InstantiateCoSimulation>> and <<fmi3InstantiateScheduledExecution>>.
The state is left by either calling <<fmi3FreeInstance>> or when any of the functions called during <<FMUStateSetable>> returns <<fmi3Fatal>>.
If any function called in super state <<FMUStateSetable>> returns <<fmi3Error>>, the FMU enters state <<Terminated>>.

Allowed Function Calls to enter this Super State::

[[fmi3InstantiateModelExchange,`fmi3InstantiateModelExchange`]]
Function `fmi3InstantiateModelExchange`::
This function instantiates a Model Exchange FMU (see <<fmi-for-model-exchange>>).
It is allowed to call this function only if <<modelDescription.xml>> includes a `<ModelExchange>` element.

[[fmi3InstantiateCoSimulation,`fmi3InstantiateCoSimulation`]]
Function `fmi3InstantiateCoSimulation`::
This function instantiates a Co-Simulation FMU (see <<fmi-for-co-simulation>>).
It is allowed to call this function only if <<modelDescription.xml>> includes a `<CoSimulation>` element.

[[fmi3InstantiateScheduledExecution,`fmi3InstantiateScheduledExecution`]]
Function `fmi3InstantiateScheduledExecution`::
This function instantiates a Scheduled Execution FMU (see <<fmi-for-scheduled-execution>>).
It is allowed to call this function only if <<modelDescription.xml>> includes a `<ScheduledExecution>` element.
+
[[fmi3Instantiate,`fmi3InstantiateXXX`]]
[source, C]
----
include::../headers/fmi3FunctionTypes.h[tags=Instantiate]
----

+
These functions return a new instance of an FMU with the respective interface type.
If a NULL pointer is returned, then instantiation failed.
In that case, <<logMessage>> is called with detailed information about the reason.
An FMU can be instantiated many times (provided capability flag `canBeInstantiatedOnlyOncePerProcess = false`).

+
The arguments of the instantiation functions are detailed as follows:

* `instanceName` is a unique identifier for the FMU instance.
It is used to name the instance, for example, in error or information messages generated by one of the `fmi3XXX` functions.
The argument `instanceName` must be a non empty string (in other words, must have at least one character that is not a white space).
_[If only one FMU is simulated, either the attribute `modelName` of <<fmiModelDescription>> or the attribute <<modelIdentifierME>> of `<ModelExchange|CoSimulation|ScheduledExecution>` can be used as `instanceName`.]_

* <<instantiationToken>> can be used by the FMU to check that the <<modelDescription.xml>> file (see <<fmu-distribution>>) is compatible with the implementation of the FMU.
It is an opaque string generated by the FMU exporter that is stored in the xml file as mandatory attribute <<instantiationToken>> (see <<fmiModelDescription>>).
It must be passed unchanged to the FMU.
This argument must not be a NULL pointer.

* [[resourcePath,`resourcePath`]] `resourcePath` is the absolute file path (with a trailing file separator) of the `resources` directory of the extracted FMU archive. +
_[Example: An FMU is extracted to the directory `C:\temp\MyFMU`, then <<resourcePath>> = `C:\temp\MyFMU\resources\`.]_ +
<<resourcePath>> must be `NULL`, if no resource path can be provided to the FMU, which may occur if

** the FMU does not contain a `resources` folder, or
** the environment is not able to provide the file path to the resources folder _[e.g., if the environment does not have a file system._
_If the FMU in such a case cannot be simulated, as it depends on the resources folder, it shall terminate with an error.]_

* `visible == fmi3False` defines that the interaction with the user should be reduced to a minimum (no application window, no plotting, no animation, etc.).
In other words, the FMU is executed in batch mode.
If `visible == fmi3True`, the FMU is executed in interactive mode, and the FMU might require to explicitly acknowledge start of simulation / instantiation / initialization (acknowledgment is non-blocking).

* [[loggingOn,`loggingOn`]] If `loggingOn == fmi3False`, then any logging is disabled and the <<logMessage>> callback function is not called by the FMU.
If `loggingOn == fmi3True`, the FMU enables a vendor defined set of `<LogCategories>`.
This set should typically contain categories for messages that explain execution errors, like <<fmi3Discard>>, <<fmi3Error>> and <<fmi3Fatal>>.
The function <<fmi3SetDebugLogging>> gives more detailed control about required `<LogCategories>` (see <<definition-of-log-categories>>).


+
* [[eventModeUsed,`eventModeUsed`]]If `eventModeUsed == fmi3True` the importer can handle events.
The flag may only be `fmi3True`, if <<hasEventMode,`hasEventMode == true`>>, otherwise the FMU must raise an error.
For FMUs that have clocks, `eventModeUsed == fmi3True` is required.

* [[earlyReturnAllowed,`earlyReturnAllowed`]]If `earlyReturnAllowed == fmi3True` the importer can handle <<early-return,early return>>.
Only in this case, <<fmi3DoStep>> may return with <<earlyReturn,`earlyReturn == fmi3True`>>.

* `instanceEnvironment` is a pointer that must be passed to <<fmi3IntermediateUpdateCallback>> and <<fmi3ClockUpdateCallback>> to allow the simulation environment an efficient way to identify the calling FMU.

* [[requiredIntermediateVariables,`requiredIntermediateVariables`]] `requiredIntermediateVariables` is an array of the value references of all <<input>> variables that the simulation algorithm intends to set and all <<output>> variables it intends to get during intermediate updates.
This set may be empty (<<nRequiredIntermediateVariables>> == 0) when the simulation algorithm does not intend to use intermediate update.
Only the variables in <<requiredIntermediateVariables>> may be accessed by the simulation algorithm using <<get-and-set-variable-values,`fmi3Set{VariableType}`>> and <<get-and-set-variable-values,`fmi3Get{VariableType}`>> during <<IntermediateUpdateMode>>.
All variables referenced in this set must be marked with the attribute <<intermediateUpdate,`intermediateUpdate = "true"`>> in <<modelDescription.xml>>.
For Co-Simulation, these intermediate variables must be continuous-time variables.

* [[nRequiredIntermediateVariables,`nRequiredIntermediateVariables`]] `nRequiredIntermediateVariables` gives the number of entries in <<requiredIntermediateVariables>>.
If <<nRequiredIntermediateVariables>> is zero <<requiredIntermediateVariables>> is not defined.

* [[logMessage,`logMessage`]]Callback function `logMessage`
+
[source, C]
----
include::../headers/fmi3FunctionTypes.h[tags=CallbackLogMessage]
----
+
Pointer to a function that is called by the FMU _[usually if an `fmi3XXX` function does not behave as desired]_.

** `status` contains the severity of the message, see `fmi3Status`.
If <<fmi3OK,`status == fmi3OK`>>, the message is a pure information message.
If a function does not return <<fmi3OK>>, it must provide the reason by calling <<logMessage>> at least once with this `status`.
** `category` is the category of the message.
The allowed values for `category` are defined in the <<modelDescription.xml>> file via the element <<definition-of-log-categories,`<LogCategories>`>>.
<<logMessage>> should only be called for log categories that were enabled by a call to <<fmi3SetDebugLogging>> or via <<loggingOn,`loggingOn == fmi3True`>> in <<fmi3Instantiate>>.
If the FMU does not define any log categories, `category` must be `NULL`.
** `message` is a string that contains the message to log. It may contain line-breaks (`\n`), but should not have a trailing line break.

+
All string-valued arguments passed by the FMU to the <<logMessage>> may be deallocated by the FMU directly after function <<logMessage>> returns.
_[The simulation environment must therefore create copies of these strings if it needs to access these strings later.]_ +
Variables can be referenced in a message with `pass:[#]<ValueReference>pass:[#]`.
If the character `pass:[#]` shall be included in the message, it has to be prefixed with `pass:[#]`, so `pass:[#]` is an escape character. +
_[Example: The message `\#1365# must be larger than zero (used in IO channel ##4)` might be changed by the <<logMessage>> function to `body.m must be larger than zero (used in IO channel #4)` if `body.m` is the name of the variable with value reference 1365.]_

* Callback function `intermediateUpdate` +
See <<fmi3IntermediateUpdateCallback>> for details.

* Callback function `clockUpdate` +
See <<fmi3ClockUpdateCallback>> for details.

* Callback function <<preemption-support,`lockPreemption`>> and <<preemption-support,`unlockPreemption`>> +
See <<preemption-support>> for details.

+
The arguments <<logMessage>>, <<fmi3IntermediateUpdateCallback,`intermediateUpdate`>>, <<fmi3ClockUpdateCallback,`clockUpdate`>>, <<preemption-support,`lockPreemption`>>, and <<preemption-support,`unlockPreemption`>>, are function pointers provided by the simulation environment to be used by the FMU.
Each of these pointers can be NULL to indicate missing support for the respective functionality.
If such functionality is used anyway, undefined behavior results.
_[For example, if <<logMessage,`logMessage == NULL`>>, calls to <<fmi3SetDebugLogging>> result in undefined behavior of the FMU._
_If <<intermediateUpdate,`intermediateUpdate == NULL`>> and arguments <<requiredIntermediateVariables,`requiredIntermediateVariables != NULL`>> and/or <<nRequiredIntermediateVariables,`nRequiredIntermediateVariables != 0`>> the behavior of the FMU is undefined.]_
Additionally, a pointer to the environment is provided (`instanceEnvironment`) that needs to be passed to all of the callback functions, in order that those functions can utilize data from the environment, such as mapping a <<valueReference>> to a string, or assigning memory to a certain FMU instance.

Allowed Function Calls::

[[fmi3SetDebugLogging,`fmi3SetDebugLogging`]]
Function `fmi3SetDebugLogging`::
+
[source, C]
----
include::../headers/fmi3FunctionTypes.h[tags=SetDebugLogging]
----
The function controls the debug logging that is output via the <<logMessage>> callback function by the FMU.

** If <<loggingOn,`loggingOn == fmi3True`>>, debug logging is enabled for the log categories specified in `categories`, otherwise it is disabled.
** `nCategories` defines the length of the argument `categories`.
** If `nCategories == 0`, <<loggingOn>> applies to all log categories and the value of `categories` is undefined.
** `categories` is an array of `nCategories` elements.
The allowed values of `categories` are defined in the <<modelDescription.xml>> via element <<definition-of-log-categories,`<LogCategories>`>>.

[[fmi3Reset,`fmi3Reset`]]
Function `fmi3Reset`::
+
[source, C]
----
include::../headers/fmi3FunctionTypes.h[tags=Reset]
----
+
Is called by the environment to reset the FMU after a simulation run.
The FMU goes into the same state as if <<fmi3Instantiate>> would have been called.
All variables have their default values.
Before starting a new run <<fmi3EnterInitializationMode>> has to be called.

[[fmi3FreeInstance,`fmi3FreeInstance`]]
Function `fmi3FreeInstance`::
+
[source, C]
----
include::../headers/fmi3FunctionTypes.h[tags=FreeInstance]
----
+
Disposes the given instance, unloads the loaded model, and frees all the allocated memory and other resources that have been allocated by the functions of the FMU interface.
If a NULL pointer is provided for argument `instance`, the function call is ignored (does not have an effect).

Function <<fmi3GetFMUState>>::
Function <<fmi3SetFMUState>>::
Function <<fmi3FreeFMUState>>::
Function <<fmi3SerializedFMUStateSize>>::
Function <<fmi3SerializeFMUState>>::
Function <<fmi3DeSerializeFMUState>>::
All these allowed functions are described in <<get-set-fmu-state>>.

==== State: Instantiated [[Instantiated,*Instantiated*]]

In the state <<Instantiated>> the FMU can do one-time initializations and allocate memory.

[#table-math-instantiated]
[cols="2,1",options="header",]
|====
|<<each-state-description,Equations and Actions>>
|Functions Influencing Equations

|Set variables latexmath:[(\mathbf{v}_{\mathit{initial=exact}}] or latexmath:[\mathbf{v}_{\mathit{initial=approx}})] and latexmath:[\mathbf{v}_{\mathit{variability \neq constant}}]
|<<get-and-set-variable-values,`fmi3Set{VariableType}`>>

|Get variable <<start>> values as defined in <<modelDescription.xml>>.
|<<get-and-set-variable-values,`fmi3Get{VariableType}`>>

a|
* latexmath:[\mathbf{t}_{\mathit{start}} := (]<<startTime>>latexmath:[,0)]
* Activate initialization equations latexmath:[\mathbf{f}_{\mathit{init}}].
|<<fmi3EnterInitializationMode>>
|====

Allowed Function Calls::

Function <<get-and-set-variable-values,`fmi3Set{VariableType}`>>::

This function can be called for variables with <<variability>> latexmath:[\neq] <<constant>> and with <<initial>> = <<exact>> or <<approx>>.
The intention is to set <<start>> and guess values for these variables.

[[fmi3EnterConfigurationMode,`fmi3EnterConfigurationMode`]]
Function `fmi3EnterConfigurationMode`::
+
[source, C]
----
include::../headers/fmi3FunctionTypes.h[tags=EnterConfigurationMode]
----
+
If the importer needs to change <<structuralParameter,`structural parameters`>>, it must move the FMU into <<ConfigurationMode>> using <<fmi3EnterConfigurationMode>>.

[[fmi3GetNumberOfContinuousStates,`fmi3GetNumberOfContinuousStates`]]
Function `fmi3GetNumberOfContinuousStates`::
+
[source, C]
----
include::../headers/fmi3FunctionTypes.h[tags=GetNumberOfContinuousStates]
----
+
This function returns the number of <<state,continuous states>>. +
This function can only be called in Model Exchange.

* Argument `nContinuousStates` points to the `size_t` variable that will receive the number of <<state,states>>.

+
The number of <<state,continuous states>> might change if a variable representing a state has a `<Dimension>` element that references a <<structuralParameter,`structural parameter`>> (see <<ConfigurationMode>> and <<ReconfigurationMode>>).
<<fmi3GetNumberOfContinuousStates>> must be called after such <<structuralParameter,`structural parameters`>> changed.
As long as no <<structuralParameter,`structural parameters`>> changed, the number of states is given in the <<modelDescription.xml>>, alleviating the need to call this function.

[[fmi3GetNumberOfEventIndicators,`fmi3GetNumberOfEventIndicators`]]
Function `fmi3GetNumberOfEventIndicators`::
+
[source, C]
----
include::../headers/fmi3FunctionTypes.h[tags=GetNumberOfEventIndicators]
----
+
This function returns the number of <<state-event,event indicators>>. +
This function can only be called in Model Exchange.

* Argument `nEventIndicators` points to the `size_t` variable that will receive the number of event indicators.

+
The initial value of `nEventIndicators` is the sum of the sizes of the variables referenced by the <<EventIndicator>> elements.
The number of <<state-event,event indicators>> might change if a variable related to <<state-event,event indicators>> has a `<Dimension>` that references a <<structuralParameter,`structural parameter`>>  (see <<ConfigurationMode>> and <<ReconfigurationMode>>).
<<fmi3GetNumberOfEventIndicators>> must be called after such <<structuralParameter,`structural parameters`>> changed.
As long as no <<structuralParameter,`structural parameters`>> changed, the number of event indicators is given in the <<modelDescription.xml>>, alleviating the need to call this function.

[[fmi3EnterInitializationMode,`fmi3EnterInitializationMode`]]
Function `fmi3EnterInitializationMode`::
+
[source, C]
----
include::../headers/fmi3FunctionTypes.h[tags=EnterInitializationMode]
----
+
Changes state to <<InitializationMode>>.

* [[toleranceDefined,`toleranceDefined`]]`toleranceDefined` and
* [[tolerance,`tolerance`]]`tolerance` depend on the interface type:

** Model Exchange: If <<toleranceDefined,`toleranceDefined == fmi3True`>>, then the model is called with a numerical integration scheme where the step size is controlled by using <<tolerance>> for error estimation (usually as relative tolerance).
In such a case all numerical algorithms used inside the model (for example, to solve non-linear algebraic equations) should also operate with an error estimation of an appropriate smaller relative tolerance.

** Co-Simulation: If <<toleranceDefined,`toleranceDefined == fmi3True`>>, then the communication step size of the FMU is controlled by error estimation.
In case the FMU utilizes a numerical integrator with variable step size and error estimation, it is suggested to use <<tolerance>> for the error estimation of the integrator (usually as relative tolerance). +
An FMU for Co-Simulation might ignore this argument.


* [[startTime,`startTime`]]`startTime` and
* [[stopTime,`stopTime`]]`stopTime` can be used to check whether the model is valid within the given boundaries, or to allocate the necessary memory for storing results.
<<startTime>> is the <<fixed>> <<initial>> value of the <<independent>> variable and inherits its unit.
+
_[It is defined with <<causality>> = <<independent>> in the <<modelDescription.xml>>._
_If the <<independent>> variable is `time`, <<startTime>> is the starting time of initialization.]_

* [[stopTimeDefined,`stopTimeDefined`]] If `stopTimeDefined == fmi3True`, then <<stopTime>> is the final value of the <<independent>> variable and inherits its unit.
If the environment tries to compute past <<stopTime>>, the FMU has to return <<fmi3Error,`fmi3Status == fmi3Error`>>.
If <<stopTimeDefined,`stopTimeDefined == fmi3False`>>, then no final value of the <<independent>> variable is defined and argument <<stopTime>> is meaningless.

==== State: Initialization Mode [[InitializationMode,*Initialization Mode*]]

The <<InitializationMode>> is used by the simulation algorithm to compute consistent initial conditions for the overall system.
Equations are active to determine the initial FMU state, as well as all <<output,`outputs`>> (and optionally other variables exposed by the exporting tool).
Artificial or real algebraic loops over connected FMUs in <<InitializationMode>> may be handled by using appropriate numerical algorithms.

In <<InitializationMode>>, the FMU computes initial values at the start time latexmath:[\mathbf{t}_\mathit{start}] using function latexmath:[\mathbf{f}_\mathit{init}], not present in the other modes, for example, equations to define the <<start>> value for a <<state>> or for the derivative of a <<state>>.

[#table-math-initializationMode]
[cols="2,1",options="header",]
|====
|<<each-state-description,Equations and Actions>>
|Functions Influencing Equations

|Set variables latexmath:[\mathbf{v}_{\mathit{initial=exact}}] +
_[<<parameter,`parameters`>> latexmath:[\mathbf{p}] and
continuous-time <<state,`states`>> latexmath:[\mathbf{x}_{c,\mathit{initial=exact}}] are included here]_
|<<get-and-set-variable-values,`fmi3Set{VariableType}`>>

|Set continuous-time and discrete-time <<input,`inputs`>>  latexmath:[\mathbf{u}_{c+d}(\mathbf{t}_{start})]
|<<get-and-set-variable-values,`fmi3Set{VariableType}`>>

|latexmath:[(\mathbf{y}_{c+d}, \mathbf{\dot{x}}_c, \mathbf{x}_{c+d}, ^{\bullet}\mathbf{x}_d, \mathbf{z}, \mathbf{r}, \mathbf{w}_{c+d}, \mathbf{b}, \mathbf{T}_{\mathit{shift}}, \mathbf{T}_\mathit{interval}) := \mathbf{f}_{\mathit{init}}(\mathbf{u}_{c+d}, \mathbf{t}_{start}, \mathbf{v}_{\mathit{initial=exact}})]
|<<get-and-set-variable-values,`fmi3Get{VariableType}`>>, <<fmi3GetContinuousStateDerivatives>>, <<fmi3GetContinuousStates>>, <<fmi3GetEventIndicators>>, <<fmi3GetShift>>, <<fmi3GetInterval>>

a|
* Evaluate latexmath:[\mathbf{f}_{\mathit{init}}], if no `fmi3GetXXX` function was called
* Deactivate initialization equations latexmath:[\mathbf{f}_{\mathit{init}}]
* Update previous values of <<buffers>>: latexmath:[{}^\bullet\mathbf{b}:=\mathbf{b}]
* latexmath:[\mathbf{t}:=(\mathbf{t}_{\mathit{start}}, 0)]
* Model Exchange:
  - activate event equations latexmath:[\mathbf{f}_{\mathit{event}}]
* Co-Simulation:
  - If <<eventModeUsed>> of <<fmi3InstantiateCoSimulation>> is `fmi3True` +
    activate event equations latexmath:[\mathbf{f}_{\mathit{event}}]
  - else +
    activate doStep equations latexmath:[\mathbf{f}_{\mathit{doStep}}]

|<<fmi3ExitInitializationMode>>
|====

Allowed Function Calls::

Function <<get-and-set-variable-values,`fmi3Set{VariableType}`>>::
This function can be called for variables with <<variability>> latexmath:[\neq] <<constant>> and with <<initial>> = <<exact>>.

Functions <<get-and-set-variable-values,`fmi3Get{VariableType}`>>::
Getting variables might trigger <<selectiv-computation,computations>>. +
_[For variables not computed by_ latexmath:[\mathbf{f}_{\mathit{init}}] _their <<start>> values will be returned.]_

Function <<fmi3GetContinuousStateDerivatives>>::
See <<fmi3GetContinuousStateDerivatives>> for Model Exchange only.

[[fmi3GetContinuousStates,`fmi3GetContinuousStates`]]
Function `fmi3GetContinuousStates`::
In Model Exchange only:
+
[source, C]
----
include::../headers/fmi3FunctionTypes.h[tags=GetContinuousStates]
----
+
Return the current continuous state vector.
+
* Return argument `continuousStates` contains the values for each <<state,continuous state>> with the same convention for the order as defined for <<fmi3SetContinuousStates>>.

* Argument `nContinuousStates` is the size of the `continuousStates` vector.

[[fmi3GetNominalsOfContinuousStates,`fmi3GetNominalsOfContinuousStates`]]
Function `fmi3GetNominalsOfContinuousStates`::
+
[source, C]
----
include::../headers/fmi3FunctionTypes.h[tags=GetNominalsOfContinuousStates]
----
+
Return the nominal values of the continuous <<state,`states`>>.
This function can only be called in Model Exchange.

* Return argument `nominals` contains the nominal values for each <<state,continuous state>> with the same convention for the order as defined for <<fmi3SetContinuousStates>>.
If the FMU does not have information about the nominal value of a continuous <<state>> `i`, a nominal value `nominals[i] == 1.0` should be returned.
It is required that `nominals[i] > 0.0`.

* Argument `nContinuousStates` is the size of the `nominals` vector.

+
This function should always be called after calling function <<fmi3UpdateDiscreteStates>>, if `nominalsOfContinuousStatesChanged == fmi3True`, since then the nominal values of the continuous <<state,`states`>> have changed _[for example, because the mapping of the continuous <<state,`states`>> to variables has changed because of internal <<dynamic-state-selection>>]_.

Function <<fmi3GetDirectionalDerivative>>::
See <<fmi3GetDirectionalDerivative>>.

Function <<fmi3GetAdjointDerivative>>::
See <<fmi3GetAdjointDerivative>>.

Function <<fmi3GetEventIndicators>>::
See <<fmi3GetEventIndicators>>.

Functions <<fmi3GetShiftDecimal>> & <<fmi3GetShiftFraction>>::
See <<fmi3GetShift>>.

Functions <<fmi3GetIntervalDecimal>> & <<fmi3GetIntervalFraction>>::
See <<fmi3GetInterval>>.

Functions <<fmi3SetIntervalDecimal>> & <<fmi3SetIntervalFraction>>::
One of these functions must be called for all <<fixed-periodic-clock,Fixed periodic Clocks>>.

[[fmi3ExitInitializationMode,`fmi3ExitInitializationMode`]]
Function `fmi3ExitInitializationMode`::
+
[source, C]
----
include::../headers/fmi3FunctionTypes.h[tags=ExitInitializationMode]
----

+
Changes the state to

 * Model Exchange: <<EventMode>>
 * Co-Simulation:
  ** <<eventModeUsed,`eventModeUsed == fmi3True`>>: <<EventMode>>
  ** <<eventModeUsed,`eventModeUsed == fmi3False`>>: <<StepMode>>
 * Scheduled Execution: <<ClockActivationMode>>.

==== Super State: Initialized [[Initialized,*Initialized*]]

This super state is entered by the FMU when <<fmi3ExitInitializationMode>> is called.

[#table-math-initialized]
[cols="2,1",options="header",]
|====
|<<each-state-description,Equations and Actions>>
|Functions Influencing Equations

|Activate termination equations latexmath:[\mathbf{f}_{\mathit{term}}].
|<<fmi3Terminate>>
|====

Allowed Function Calls::

Function <<fmi3GetNominalsOfContinuousStates>>::
See <<fmi3GetNominalsOfContinuousStates>>.

[[fmi3Terminate,`fmi3Terminate`]]
Function `fmi3Terminate`::
+
[source, C]
----
include::../headers/fmi3FunctionTypes.h[tags=Terminate]
----

+
Changes state to <<Terminated>>.

==== State: Event Mode [[EventMode,*Event Mode*]]

In <<EventMode>> all continuous-time, discrete-time equations and active model partitions are evaluated.
<<algebraic-loops,Algebraic loops>> active during <<EventMode>> are solved by <<eventIteration>>.

<<EventMode>> is not available in Scheduled Execution.
While the reasons for entering <<EventMode>> are different for Model Exchange and Co-Simulation (see arguments to <<fmi3EnterEventMode>>), the event handling itself works the same.

There are multiple kinds of events that require a transition to <<EventMode>>:

* <<input-event,Input events>> indicate a non-continuous change of at least one input, in both Model Exchange and Co-Simulation.
  Additionally, in Co-Simulation, the exact event time can be communicated to the FMU by the return argument <<earlyReturnTime>> of <<fmi3IntermediateUpdateCallback>>.
* <<time-event,Time events>> are announced to the importer in advance by the FMU through
  - the argument <<nextEventTime>> of <<fmi3UpdateDiscreteStates>>, or
  - the arguments of <<fmi3GetShift>> and <<fmi3GetInterval>>.
* <<state-event,State events>> are signaled to the importer by <<eventIndicators>> in Model Exchange (see <<localizationStateEvents>>).
  In Co-Simulation, the FMU returns from <<fmi3DoStep>> with <<eventHandlingNeeded,`eventHandlingNeeded == fmi3True`>>.
  The exact event localization is hidden from the importer.
* <<step-event,Step events>> are initiated by the FMU at the end of an integrator step (see argument <<enterEventMode>> of <<fmi3CompletedIntegratorStep>>) in Model Exchange.


[#table-math-event-mode]
[cols="5,2",options="header",]
|====
|<<each-state-description,Equations and Actions>>
|Functions Influencing Equations

|Set <<tunable>> <<parameter,`parameters`>> latexmath:[\mathbf{p}_{\mathit{variability == tunable}}]
|<<get-and-set-variable-values,`fmi3Set{VariableType}`>>

|Set continuous-time and discrete-time <<input,`inputs`>> latexmath:[\mathbf{u}_{c+d}]
|<<get-and-set-variable-values,`fmi3Set{VariableType}`>>

a|
* Activate clocks and output equations of the respective model partitions.
* Deactivate clocks and
  - Reset respective clocked variables to their previous values: latexmath:[\mathbf{v}_{\mathit{k}} := {}^\bullet\mathbf{v}_{\mathit{k}}], and
  - Deactivate respective model partitions in latexmath:[\mathbf{f}_{\mathit{event}}].
|<<fmi3SetClockEM>>

a|
* If <<providesEvaluateDiscreteStates>> is `true`, then execute state transition function of the model partitions +
latexmath:[(\mathbf{x}_{d}) := \mathbf{f}_{\mathit{disc}}({}^\bullet\mathbf{x}_{c+d}, \mathbf{u}_{c+d}, \mathbf{p}, {}^\bullet\mathbf{b}, \mathbf{t})]
* else function is ignored.
* For all active Clocks latexmath:[\mathbf{k}], the <<clocked-variable,clocked variables>> latexmath:[\mathbf{v}_k] are part of the set of discrete variables latexmath:[\mathbf{v}_d] computed by latexmath:[\mathbf{f}_{\mathit{disc}}].
|<<fmi3EvaluateDiscreteStates>>

a|
* Computes latexmath:[\mathbf{f}_{\mathit{event}}] depending on
  - if <<providesEvaluateDiscreteStates>> is `true`, then +
latexmath:[(\mathbf{y}_{c+d}, \mathbf{\dot{x}}_c, \mathbf{x}_{c}, \mathbf{z}, \mathbf{r}, \mathbf{w}_{c+d}, \mathbf{b}, \mathbf{T}_{\mathit{next}}) := \mathbf{f}_{\mathit{event}}({}^\bullet\mathbf{x}_{c+d}, \mathbf{x}_{d}, \mathbf{u}_{c+d}, \mathbf{p}, {}^\bullet\mathbf{b}, \mathbf{t})]
  - else +
latexmath:[(\mathbf{y}_{c+d}, \mathbf{\dot{x}}_c, \mathbf{x}_{c+d}, \mathbf{z}, \mathbf{r}, \mathbf{w}_{c+d}, \mathbf{b}, \mathbf{T}_{\mathit{next}}) := \mathbf{f}_{\mathit{event}}({}^\bullet\mathbf{x}_{c+d}, \mathbf{u}_{c+d}, \mathbf{p}, {}^\bullet\mathbf{b}, \mathbf{t})] +
  which includes latexmath:[\mathbf{f}_{\mathit{disc}}].
* For all active Clocks latexmath:[\mathbf{k}], the <<clocked-variable,clocked variables>> latexmath:[\mathbf{v}_k] are part of the set of discrete variables latexmath:[\mathbf{v}_d] computed by latexmath:[\mathbf{f}_{\mathit{event}}].
|<<get-and-set-variable-values,`fmi3Get{VariableType}`>>, +
<<fmi3GetContinuousStateDerivatives>>, +
<<fmi3GetContinuousStates>>, +
<<fmi3GetEventIndicators>> +

a|
* Signals end of super-dense time instant.
* Compute
  - latexmath:[\mathbf{f}_{\mathit{disc}}] if <<providesEvaluateDiscreteStates>> is `true` and latexmath:[\mathbf{f}_{\mathit{disc}}] (<<fmi3EvaluateDiscreteStates>>) was not called within this super-dense time, or
  - latexmath:[\mathbf{f}_{\mathit{event}}] if <<providesEvaluateDiscreteStates>> is `false` and latexmath:[\mathbf{f}_{\mathit{event}}] was not called within this super-dense time.
* latexmath:[(\mathbf{T}_\mathit{interval}) := \mathbf{f}_{\mathit{update}}({}^\bullet\mathbf{x}_{c+d}, \mathbf{u}_{c+d}, \mathbf{p}, {}^\bullet\mathbf{b}, \mathbf{t})]
* Update previous values of discrete states: latexmath:[{}^\bullet\mathbf{x}_d:=\mathbf{x}_d].
* Update previous values of <<buffers>>: latexmath:[{}^\bullet\mathbf{b}:=\mathbf{b}].
* Deactivate active clocks and respective model partitions.
* Increment super-dense time: latexmath:[\mathbf{t}:=(\mathbf{t}_\mathit{R}, \mathbf{t}_\mathit{I} + 1)].
|<<fmi3UpdateDiscreteStates>>

a|
* [[updateRelations]]Update previous values of <<relations>>: latexmath:[{}^\bullet\mathbf{r}:=\mathbf{r}].
* Deactivate event equations latexmath:[\mathbf{f}_\mathit{event}].
* Model Exchange: Activate continuous-time equations latexmath:[\mathbf{f}_\mathit{cont}].

|<<fmi3EnterContinuousTimeMode>>,
<<fmi3EnterStepMode>>

|====

Allowed Function Calls::

Function <<get-and-set-variable-values,`fmi3Set{VariableType}`>>::
This function can be called for variables with <<causality,`causality == input`>> and for variables with <<causality,`causality == parameter`>> and <<variability, `variability == tunable`>>.

Functions <<get-and-set-variable-values,`fmi3Get{VariableType}`>>::
Getting variables might trigger <<selectiv-computation,computations>>.

[[fmi3SetClockEM,`fmi3SetClock`]]
Function <<fmi3SetClock>>::
For <<inputClock,`input Clocks`>>, <<fmi3SetClock>> is called to set the activation status of <<Clock,`Clocks`>> to `fmi3ClockActive` or `fmi3ClockInactive`.
During the solution of algebraic loops, the activation condition of triggered input clocks may change and therefore <<fmi3SetClock>> can be called multiple times per super-dense time instant.
When a Clock latexmath:[\mathbf{k}] is deactivated, the FMU must

* reset all clocked states of this Clock to the values computed during the last <<fmi3UpdateDiscreteStates>> when this Clock was active (latexmath:[{}^\bullet\mathbf{v}_{\mathit{k}}]); and, as a result:
* deactivate all Clocks that were activated as a result of latexmath:[\mathbf{k}]'s activation during the current super-dense time instant.


_[Rationale: a triggered <<outputClock,output Clock>> latexmath:[c] may depend on some variable latexmath:[v] that is involved in an algebraic loop._
_As part of the iterations to solve the algebraic loop, latexmath:[v] acquires a value that activates the Clock._
_If the final (or some intermediate) value of latexmath:[v] no longer activates the Clock, then this Clock must be deactivated by the Importer during the same super-dense time instant.]_ +
The importer can set a Clock to `fmi3ClockInactive` only if the Clock has the attribute <<canBeDeactivated,`canBeDeactivated == true`>>.
Any Clock active during <<fmi3UpdateDiscreteStates>> must be deactivated by the FMU itself. +
Only <<time-based-clock,time-based Clocks>> must not be active for more than one call of <<fmi3UpdateDiscreteStates>> per <<EventMode>>. +
_[The event iteration for handling discontinuities of the continuous part of the FMU should precede handling of time-based Clocks._
_No further constraints on activations of <<time-based-clock,time-based Clocks>> are defined, e.g. activating at the first instant of super-dense time._
_If the semantics of some Clocks require any specific treatment, e.g. activation at the same super-dense time instant, only the importer will know and must therefore enforce proper activation of the respective Clocks.]_

Function <<fmi3GetClock>>::
is used to inquire the status of <<Clock,Clocks>>.

Functions <<fmi3GetIntervalDecimal>> & <<fmi3GetIntervalFraction>>::
For <<inputClock,`input Clocks`>> it is allowed to call these functions to query the next activation interval. +
For <<changing-aperiodic-clock>>, these functions must be called in every <<EventMode>> where this clock was activated. +
For <<countdown-aperiodic-clock>>, these functions must be called in every <<EventMode>>. +
Clock intervals are computed in <<fmi3UpdateDiscreteStates>> (at the latest), therefore, these functions should be called after <<fmi3UpdateDiscreteStates>>.

Function <<fmi3GetDirectionalDerivative>>::
See <<fmi3GetDirectionalDerivative>>.

Function <<fmi3GetAdjointDerivative>>::
See <<fmi3GetAdjointDerivative>>.

Function <<fmi3GetContinuousStates>>::
This function must be called if <<fmi3UpdateDiscreteStates>> returned with <<valuesOfContinuousStatesChanged, `valuesOfContinuousStatesChanged == fmi3True`>>.
Not allowed in Co-Simulation and Scheduled Execution.

Function <<fmi3GetContinuousStateDerivatives>>::
Not allowed in Co-Simulation and Scheduled Execution.

Function <<fmi3GetEventIndicators>>::
Not allowed in Co-Simulation and Scheduled Execution.

Function <<fmi3GetNumberOfContinuousStates>>::
Not allowed in Co-Simulation and Scheduled Execution.

Function <<fmi3GetNumberOfEventIndicators>>::
Not allowed in Co-Simulation and Scheduled Execution.

Function <<fmi3EvaluateDiscreteStates>>::
This function is called to trigger the evaluation of latexmath:[\mathbf{f}_{\mathit{disc}}] to compute the current values of discrete states from previous values.
The FMU signals the support of <<fmi3EvaluateDiscreteStates>> via the capability flag <<providesEvaluateDiscreteStates>>.
+
[[fmi3EvaluateDiscreteStates,`fmi3EvaluateDiscreteStates`]]
[source, C]
----
include::../headers/fmi3FunctionTypes.h[tag=EvaluateDiscreteStates]
----

Function <<fmi3UpdateDiscreteStates>>::
This function is called to signal a converged solution at the current super-dense time instant.
<<fmi3UpdateDiscreteStates>> must be called at least once per super-dense time instant.
+
[[fmi3UpdateDiscreteStates,`fmi3UpdateDiscreteStates`]]
[source, C]
----
include::../headers/fmi3FunctionTypes.h[tag=UpdateDiscreteStates]
----

[[discreteStatesNeedUpdate,`discreteStatesNeedUpdate`]]
* When `discreteStatesNeedUpdate == fmi3True`, the importer must stay in <<EventMode>> for another event iteration, starting a new super-dense time instant.

[[terminateSimulationUDS,`terminateSimulation`]]
* When <<terminateSimulationUDS,`terminateSimulation == fmi3True`>>, the FMU requests to stop the simulation and the importer must call <<fmi3Terminate>>.

[[nominalsOfContinuousStatesChanged,`nominalsOfContinuousStatesChanged`]]
* If argument `nominalsOfContinuousStatesChanged == fmi3True`, then at least one nominal value of the <<state,`states`>> has changed and can be inquired with <<fmi3GetNominalsOfContinuousStates>>. +
This argument is only valid in Model Exchange.

[[valuesOfContinuousStatesChanged,`valuesOfContinuousStatesChanged`]]
* If argument `valuesOfContinuousStatesChanged == fmi3True`, then at least one continuous state has changed its value because it was re-initialized (see <<reinit>>). +

+
The new values of the <<state,`states`>> can be inquired with <<fmi3GetContinuousStates>> or individually for each state for which <<reinit, `reinit = true`>> by calling `fmi3GetFloat64`. +
This argument is only valid in Model Exchange.

[[nextEventTimeDefined,`nextEventTimeDefined`]]
* When <<nextEventTimeDefined,`nextEventTimeDefined == fmi3True`>>, the next time event is known and <<nextEventTime>> has a valid value.

[[nextEventTime,`nextEventTime`]]
* The return argument <<nextEventTime>> contains the absolute time of the next time event latexmath:[\mathbf{T}_\mathit{next}] if <<nextEventTimeDefined,`nextEventTimeDefined == fmi3True`>>.
The importer must compute up to <<nextEventTime>> (or if needed slightly further) and then enter <<EventMode>> using <<fmi3EnterEventMode>> with argument <<timeEvent,`timeEvent == fmi3True`>>.
The FMU must handle this time event at the first call to <<fmi3EnterEventMode>> with <<timeEvent,`timeEvent == fmi3True`>> at or after <<nextEventTime>>. +
_[This might be needed if, for example, the time resolution of the importer does not allow hitting the precise <<nextEventTime>>._
_If the time offset proves to be too large, the FMU could issue a log message and return fmi3Error._
_The user can improve time settings of the importer to alleviate the issues.]_ +
If another (e.g. <<state event>>) event happens before that <<nextEventTime>>, the previous definition of <<nextEventTime>> becomes obsolete.

[[dummy1]]
Function <<fmi3EnterConfigurationMode>>::
<<fmi3EnterConfigurationMode>> changes state to <<ReconfigurationMode>> in Model Exchange.
<<fmi3EnterConfigurationMode>> must not be called if the FMU contains no <<tunable>> <<structuralParameter,`structural parameters`>> (i.e. with <<causality>>= <<structuralParameter>> and <<variability>> = <<tunable>>).

[[fmi3EnterContinuousTimeMode,`fmi3EnterContinuousTimeMode`]]
Function `fmi3EnterContinuousTimeMode`::
+
[source, C]
----
include::../headers/fmi3FunctionTypes.h[tags=EnterContinuousTimeMode]
----
+
This function must be called to change from <<EventMode>> into <<ContinuousTimeMode>> in Model Exchange.

[[fmi3EnterStepMode,`fmi3EnterStepMode`]]
Function `fmi3EnterStepMode`::
+
[source, C]
----
include::../headers/fmi3FunctionTypes.h[tag=EnterStepMode]
----
+
This function must be called to change from <<EventMode>> into <<StepMode>> in Co-Simulation.

==== State: Configuration Mode [[ConfigurationMode,*Configuration Mode*]]

The <<ConfigurationMode>> allows setting <<structuralParameter, `structural parameters`>> for example to resize array variables.
<<fmi3EnterConfigurationMode>> must not be called if the FMU contains no <<structuralParameter,`structural parameter`>>.

[#table-math-configurationMode]
[cols="2,1",options="header",]
|====
|<<each-state-description,Equations and Actions>>
|Functions Influencing Equations

|Set latexmath:[\mathbf{v}_{\mathit{causality=structuralParameter}}] +
_[<<structuralParameter,`structuralParameters`>> with_ latexmath:[\mathbf{p}_{\mathit{variability=fixed}}] _or_ latexmath:[\mathbf{p}_{\mathit{variability=tunable}}] _are included here]_
|<<get-and-set-variable-values,`fmi3Set{VariableType}`>>

|Resize arrays with dimensions that just changed.
|<<fmi3ExitConfigurationMode>>
|====

Allowed Function Calls::

Function <<get-and-set-variable-values,`fmi3Set{VariableType}`>>::
Only for variables with <<causality>> = <<structuralParameter>> and <<variability>> = <<fixed>> or <<variability>> = <<tunable>>.

[[fmi3ExitConfigurationMode,`fmi3ExitConfigurationMode`]]
Function `fmi3ExitConfigurationMode`::
+
[source, C]
----
include::../headers/fmi3FunctionTypes.h[tags=ExitConfigurationMode]
----
+
Exits the <<ConfigurationMode>> and returns to state <<Instantiated>>.


==== State: Reconfiguration Mode [[ReconfigurationMode,*Reconfiguration Mode*]]

The <<ReconfigurationMode>> allows setting <<tunable>> <<structuralParameter, `structural parameters`>> for example to resize array variables during the simulation.
This state must not be entered, if the FMU contains no <<tunable>> <<structuralParameter,`structural parameters`>>.

[#table-math-reconfigurationMode]
[cols="2,1",options="header",]
|====
|<<each-state-description,Equations and Actions>>
|Functions Influencing Equations

|Set latexmath:[\mathbf{v}_{\mathit{causality=structuralParameter}}] +
_[<<structuralParameter,`structuralParameters`>> with_ latexmath:[\mathbf{p}_{\mathit{variability=tunable}}] _are included here]_
|<<get-and-set-variable-values,`fmi3Set{VariableType}`>>

|Resize arrays with dimensions that just changed.
|<<fmi3ExitConfigurationMode>>
|====

Allowed Function Calls::

Function <<fmi3ExitConfigurationMode>>::
<<fmi3ExitConfigurationMode>> returns back to <<EventMode>> (ME), <<StepMode>> (CS) or <<ClockActivationMode>> (SE).

Function <<get-and-set-variable-values,`fmi3Set{VariableType}`>>::
Only for variables with <<causality>> = <<structuralParameter>> and <<variability>> = <<tunable>>.

==== State: Terminated [[Terminated,*Terminated*]]
In this state, the final values of all variables at the final time of a simulation can be retrieved.

[#table-math-terminated]
[cols="2,1",options="header",]
|====
|<<each-state-description,Equations and Actions>>
|Functions Influencing Equations

|latexmath:[(\mathbf{y}_{c+d}, \mathbf{\dot{x}}_c, \mathbf{x}_{c+d}, \mathbf{z}, \mathbf{w}_{c+d}) := \mathbf{f}_{\mathit{term}}({}^\bullet\mathbf{x}_{c+d}, \mathbf{u}_{c+d}, \mathbf{p}, \mathbf{t})]
|<<get-and-set-variable-values,`fmi3Get{VariableType}`>>, <<fmi3GetContinuousStateDerivatives>>, <<fmi3GetContinuousStates>>, <<fmi3GetEventIndicators>>, <<fmi3GetOutputDerivatives>>
|====

Allowed Function Calls::

Functions <<get-and-set-variable-values,`fmi3Get{VariableType}`>>::
Getting variables might trigger <<selectiv-computation,computations>>.
_[If <<Terminated>> is entered because of an `fmi3Error` return value, retrieved values should only be used for debugging purposes.]_

Function <<fmi3GetContinuousStateDerivatives>>::
Not allowed in Co-Simulation and Scheduled Execution.

Function <<fmi3GetContinuousStates>>::
Not allowed in Co-Simulation and Scheduled Execution.

Function <<fmi3GetNominalsOfContinuousStates>>::
Not allowed in Co-Simulation and Scheduled Execution.

Function <<fmi3GetEventIndicators>>::
Not allowed in Co-Simulation and Scheduled Execution.

Function <<fmi3GetDirectionalDerivative>>::
See <<fmi3GetDirectionalDerivative>>.

Function <<fmi3GetAdjointDerivative>>::
See <<fmi3GetAdjointDerivative>>.

Function <<fmi3GetOutputDerivatives>>::
Not allowed in Model Exchange and Scheduled Execution.
