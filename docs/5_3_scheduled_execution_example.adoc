=== Code Example [[example-scheduled-execution]]

The FMU ThreeInputClocks sketches the usage of the Scheduled Execution.
The example is given in a mix of pseudo-code and C, in order to keep it small and understandable.
The example consists of one FMU with three model partitions.
Two model partitions are associated with two <<periodic-clock,periodic Clocks>> `10msClock` and `50msClock` (periods 10 ms and 50 ms) and one is associated with an aperiodic <<countdown, `countdown clock`>> `AperiodicClock`.

During the execution of the model partition of <<Clock>> `10msClock`, the FMU changes the <<interval>> for <<countdown, `countdown clock`>> `AperiodicClock` and calls <<fmi3CallbackIntermediateUpdate>> to inform the importer that the interval has changed. The importer retrieves this interval and activates the corresponding model partition.

The <<fmi3ActivateModelPartition>> function calls are executed in the context #TASK: what is meant by context?# of preemptable tasks whose priorities are derived from the respective <<Clock>> configurations of the FMU.
In this example the execution of the task of <<countdown, `countdown clock`>> `AperiodicClock` is waiting for the task of <<Clock>> `10msClock` to finish.
Likewise the task of `AperiodicClock` is suspended when the task of higher priority is scheduled again.

The example also depicts how a task associated with an even lower priority <<Clock>> (`50msClock`) is delayed several times by tasks of higher priority.
Note that the point in time when the task was scheduled is the `activationTime` of <<fmi3ActivateModelPartition>> (...Activate...(`clock`, `activationTime`)).
#TODO: incomplete#

.Scheduled Execution Example ThreeInputClocks
[[figure-scs_example]]
image::images/se_example.png[width=90%, align="center"]

==== Simulation Algorithm Implementation

To enable the computation of a Scheduled Execution FMU, a simulation algorithm has to implement a task scheduler.
Depending on the particular configuration the simulation algorithm sets up tasks for every <<inputClock>>.
When executed, each task calls <<fmi3ActivateModelPartition>> for its respective <<Clock>>.
The `activationTime` is provided by the simulation algorithm.
Periodic tasks can be scheduled on initialization of the simulation application.
Aperiodic tasks are scheduled explicitly during the execution.
#TODO: isn't this paragraph completely redundant?#


[source, C]
----
include::examples/snippets.c[tags=SE_sa_task10ms]
----

The FMU requests to schedule the model partition of `AperiodicClock`.
It calls <<fmi3CallbackIntermediateUpdate>> to enable the importer to check whether the FMU has defined a new interval for `AperiodicClock`.
By evaluating the return values #TODO: not the return values# <<qualifier>> and <<interval>> of <<fmi3GetInterval>> the simulation algorithms determines if the respective task has to be scheduled and which delay has to be applied.

[source, C]
----
include::examples/snippets.c[tags=SE_sa_intermediateUpdate]
----

==== FMU Implementation

The FMU implements <<fmi3ActivateModelPartition>> dispatching #TODO: what is dispatching? first time used here# for every <<inputClock>> so the code might look like this:

[source, C]
----
include::examples/snippets.c[tags=SE_fmu_activateMP]
----

In the context #TODO: why context?# of the task being executed every 10 ms, the FMU initiates the scheduling of a task by setting a new interval to <<countdown, `countdown Clock`>> `AperiodicClock` and evoking <<fmi3CallbackIntermediateUpdate>>.

[source, C]
----
include::examples/snippets.c[tags=SE_fmu_activateMP10ms]
----

In <<fmi3GetIntervalDecimal>> the Clock's interval qualifier is reset to <<fmi3GetIntervalDecimal, `fmi3IntervalUnchanged`>>.
To ensure consistency the FMU may need to prevent preemption.
In this example it is actually not needed since CallbackIntermediateUpdate is only called from one model partition.

[source, C]
----
include::examples/snippets.c[tags=SE_fmu_getIntervalDecimal]
----

If <<fmi3GetClock>> is called for a certain <<outputClock>> the <<outputClock>> is reset.
As for <<fmi3GetIntervalDecimal>> it may be necessary for the FMU to ensure that the code is not preempted.
Here it is just as well not needed for the same reason.

[source, C]
----
include::examples/snippets.c[tags=SE_fmu_getClock]
----
