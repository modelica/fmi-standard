=== Concepts [[concepts-co-simulation]]

==== Smoothness, Continuity and Discontinuity [[smoothness]]

Since inputs will be set at specific communication points by the importing tool, the FMU must make assumptions about the values between these communication points, including points of intermediate updates.

Between communication points, even when intermediate updates are called, all changes must be assumed to be continuous.
Changes to <<continuous>> variables are only considered discrete in *Event Mode*.

If a <<continuous>> input changes `discontinuously` (e.g. the actual input value deviates too much from the extrapolation polynomial), the co-simulation algorithm must raise an event (if supported) to indicate to the FMU a discontinuous change at an input.
In the case of Co-Simulation without *Event Mode* (see <<eventModeUsed>> and <<hasEventMode>>), detecting discrete changes to continuous input variables (for instance to reset the integration algorithm within the FMU) requires heuristics.

<<discrete, `Discrete`>> inputs keep their values between communication points.
Furthermore, changing <<discrete>> variables at communication points will likely require special handling within the FMU.
Since the FMU itself can detect such changes, the co-simulation algorithm does not need to enter *Event Mode* in such a case, but must do so, in case event iteration is required.

==== Early Return [[early-return]]

A Co-Simulation FMU is allowed to stop the execution of <<fmi3DoStep>> and return without reaching the predefined communication time, i.e. <<currentCommunicationPoint>> `+` <<communicationStepSize>>.
This mechanism is called <<early-return,"early return">>.

The Boolean capability flag <<canReturnEarlyAfterIntermediateUpdate>> in the <<modelDescription.xml>> file indicates whether the FMU supports the early-return feature.

Each time an internal discontinuity or an event happens inside an FMU with capability flag <<canReturnEarlyAfterIntermediateUpdate,`canReturnEarlyAfterIntermediateUpdate = true`>>, the callback function <<fmi3CallbackIntermediateUpdate>> is called by the FMU.
The importer can only use this <<early-return,early return>> functionality, if it provides the <<fmi3CallbackIntermediateUpdate>> callback function pointer in the instantiate function.

With the <<early-return,early return>> feature, an FMU can signal <<outputClock>> events or internal state changes, i.e., discontinuity events to the importer at any time (not only at the end of <<fmi3DoStep>> function calls).
When an internal event occurs inside the FMU at a time instant, it informs the importer that a new communication point for the Co-Simulation can be created.
Note that an event signal is not seen in the narrow sense of solver induced discontinuity events but in the general sense of a simulation event that has to be handled by the importer (e.g. state changes that require extended handling).

A second use of the early-return mechanism is the following:
In particular in multi-node architectures, significant co-simulation speed-up may be obtained if the importer can avoid waiting until the end of the slowest <<fmi3DoStep>>, when many FMUs are integrating in parallel and an event occurs.
To exploit such efficiency gains, the importer can command the FMUs to return early from the current communication step, if it gets triggered in the callback function by the FMUs.
_[In this use case, <<early-return,early return>> is a simple form of cooperative multitasking.]_

<<early-return,Early return>> is even helpful if the FMU or the co-simulation algorithm do not support the advanced handling of events based on the <<fmi-for-co-simulation,Co-Simulation>> functionalities.
Multiple event types and also <<triggered>> <<clock>> activations can be supported based on the early-return functionality and additional functionalities provided by <<fmi-for-co-simulation,Co-Simulation>>.

==== Handling Early Return and Events

If the FMU is successful in conducting an <<early-return,early return>>, <<fmi3DoStep>> returns with <<earlyReturn,`earlyReturn == fmi3True`>>.
If the FMU returns from <<fmi3DoStep>> with <<earlyReturn,`earlyReturn == fmi3True`>>, the importer has to call <<fmi3EnterEventMode>> for that FMU.

[source, C]
----
include::../headers/fmi3FunctionTypes.h[tag=EnterEventMode]
----

The importer can also call <<fmi3EnterEventMode>> at communication instants to handle input events, as will be discussed in following sections.

If an FMU provides the early-return capability that includes the handling of events in *Event Mode*,
the FMU signals this via <<canReturnEarlyAfterIntermediateUpdate>> in the <<modelDescription.xml>>.

The FMU stops computation at the first encountered internal event (if any) and the event time is provided through the output argument <<lastSuccessfulTime>>, along with the reason <<eventEncountered, `eventEncountered == fmi3True`>>.
The importer will start event handling by calling <<fmi3EnterEventMode>> for that FMU to push the FMU into *Event Mode*.
In this mode the importer is supposed to catch all events through the <<fmi3UpdateDiscreteStates>> function.

If an early-return request of the importer is ignored by the FMU, then <<fmi3DoStep>> returns with <<earlyReturn,`earlyReturn == fmi3False`>>.
The importer can start a resynchronization of FMUs at an event time, if the <<currentCommunicationPoint>> has passed the event time, the importer can roll-back the FMU and repeat the step with a suitable <<communicationStepSize>> (if the FMU supports the roll-back).

//The following pseudo-code example shows an implementation of <<fmi3CallbackIntermediateUpdate>> that uses <<earlyReturn>>, <<earlyReturnRequested>> and //<<earlyReturnTime>> to handle events inside the FMU:

//[source, c]
//----
//include::Reference-FMUs/examples/cs_early_return.c[tag=EventEarlyReturn]
//----

==== Clock Support [[api-clocked-co-simulation]]

If an FMU provides <<clock,`clocks`>> and the importer instantiates the interface type Co-Simulation, the importer must handle these <<clock,`clocks`>> and <<early-return,early return>> requests by the FMU.

===== Transfer of Input and Output Values and Parameters [[transfer-of-input-output-and-parameters-clocked-co-simulation]]

If the importer supports <<clock,`clocks`>>, all <<inputClock,`input clocks`>> of the model should be handled and <<inputClock>> events should be scheduled by the importer.
If an <<outputClock>> will tick, the FMU returns from <<fmi3DoStep>> with <<clocksAboutToTick,`clocksAboutToTick == fmi3True`>>.
After calling <<fmi3UpdateDiscreteStates>>, the activation status of <<outputClock,`output clocks`>> can be retrieved with <<fmi3GetClock>>.
Then <<fmi3SetClock>> (and <<fmi3SetIntervalDecimal>> or <<fmi3SetIntervalFraction>> if necessary) should be invoked to enable the ticked <<inputClock,`input clocks`>>.
Each <<clock>>, that ticks outside of the FMU (i.e. <<inputClock>>), is activated for an FMU based on its <<clockReference>> and an associated <<fmi3SetClock>> in *Event Mode*.
<<fmi3SetClock>> can activate multiple <<clock,`clocks`>> with each call.
An event iteration is possible.
Once all <<clock>> events are handled for this time instant, the FMU should be pushed into *Step Mode* by calling <<fmi3EnterStepMode>>.
In *Step Mode*, the importer can call <<fmi3DoStep>> for the time interval from the current event time instant until the next input event instant.
Note that <<fmi3DoStep>> may not reach the next input event instant because an <<early-return,early return>> may occur.

The importer sets and gets <<clock>> variable values similar to the FMI for Model Exchange, as defined in <<clocks>>.

===== Computation in Co-Simulation [[computation-clocked-co-simulation]]

Similar to FMI for Model Exchange, in order to activate <<inputClock,`input clocks`>> of an FMU, it is required to push the FMU into *Event Mode* by calling <<fmi3EnterEventMode>>.
If <<fmi3DoStep>> returns with <<eventEncountered,`eventEncountered == fmi3True`>> or <<clocksAboutToTick,`clocksAboutToTick == fmi3True`>>, the FMU must be pushed into *Event Mode* and <<fmi3UpdateDiscreteStates>> must be called.

In order to retrieve the status of <<outputClock,`output clocks`>>, <<fmi3GetClock>> and <<fmi3GetIntervalDecimal>> or <<fmi3GetIntervalFraction>> need to be called in the *Event Mode*.
If the <<fmi3DoStep>> return value is <<fmi3OK>>, the calling of <<fmi3GetClock>>, <<fmi3GetIntervalDecimal>>, <<fmi3GetIntervalFraction>>, <<fmi3UpdateDiscreteStates>> is only meaningful after <<fmi3SetClock>> in the case of super-dense time iterations are desired.

Similar to the Model Exchange case, the allowed call order is <<fmi3GetClock>>, <<fmi3GetIntervalDecimal>>, <<fmi3GetIntervalFraction>>, `fmi3Get{VariableType}`, `fmi3Set{VariableType}`.
Function calls of this call order can be omitted.

Once handling of the <<clock>> events finished, the importer calls <<fmi3EnterStepMode>> for that FMU to push it into *Step Mode*.

_[Usually the importer should be able to derive the correct communication point times for <<inputClock,`input clocks`>> in advance and thus it should be able to set the proper <<communicationStepSize>> for <<fmi3DoStep>>._
_Such predictions are not possible if an <<inputClock>> of an FMU depends on the ticking of a triggered <<outputClock>> of another FMU.]_
