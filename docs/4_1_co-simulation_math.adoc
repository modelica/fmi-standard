=== Concepts [[concepts-co-simulation]]


This section contains a formal mathematical model of Co-Simulation FMUs.

_[The following fundamental assumptions are made:_
_The FMUs are seen by the co-simulation algorithm as purely sampled-data systems, with the exception, that the simulation algorithm can provide input data of a defined level of smoothness (with the flag <<recommendedIntermediateInputSmoothness>>) within a communication interval via the intermediate update mechanism (see <<IntermediateUpdateMode>>)._

_Such a sampled-data system consists typically of a hybrid ODE that is integrated between communication points (known as "sampled access to time continuous systems") where internal events may occur and be handled, but events are not visible from the outside of the FMU._

_Co-Simulation FMUs can also be used for real sampled-data systems (so a sampled discrete controller; the <<input,`inputs`>> and <<output,`outputs`>> could be of type `<Float{32|64}>`, `<[U]Int{8|16|32|64}>`, `<Boolean>`, `<String>`, `<Clock>` or `<Enumeration>` with <<variability>> = <<discrete>>.)_
_However, in FMI 3.0, Co-Simulation (CS) and Scheduled Execution (SE) may likely be more suitable for this use-case._ +
_And - at least without using intermediate update (see <<IntermediateUpdateMode>>), which is untypical for sampled data systems - with Co-Simulation there will always be a communication step delay for information going "through the FMU", so there cannot be an immediate reaction as in Co-Simulation (see <<fmi-for-co-simulation>>)._
_]_

The communication between the importer and an FMU takes place at

- a discrete set of time instants, called communication points, where input variables may change in non-smooth or even non-continuous way.

- intermediate time instances, where the simulation algorithm may get and set variables using <<IntermediateUpdateMode>>.

When the transient simulation of the coupled system through Co-Simulation is completed, the sequence of evaluations is the following (here latexmath:[\mathbf{x} = {\lbrack \mathbf{x}_c; \mathbf{x}_d \rbrack}^T] is the combined vector of continuous-time and discrete-time states, and latexmath:[\mathbf{y} = {\lbrack \mathbf{y}_c; \mathbf{y}_d \rbrack}^T]) is the combined vector of continuous-time and discrete-time <<output,`outputs`>>):

.Sequence of Co-Simulation evaluations
[[equation-co-simulation-evaluations,Sequence of Co-Simulation evaluations]]
[latexmath]
++++
\mathrm{\text{for}}\ i = 0, \cdots, n-1

\begin{Bmatrix}

\mathbf{x}_{i+1} = \Phi_i \left( \mathbf{x}_i,  \mathbf{u}(t_i), \mathbf{u}_u, \mathbf{p}_{\mathit{tune},i}, h_i  \right)

\\

\left( \left\{ \mathbf{y}^{(j)}_{i+1} \right\}_{j=0,\cdots,m_{odo}}, \mathbf{w}_{i+1}\right) = \Gamma_i \left( \mathbf{x}_i,  \mathbf{u}(t_i), \mathbf{u}_u, \mathbf{p}_{\mathit{tune},i}, h_i  \right)

\end{Bmatrix}
++++

where latexmath:[\mathbf{\Phi}_i] and latexmath:[\mathbf{\Gamma}_i] define the system behavior for the time interval latexmath:[t_i < t \leq t_{i+1}],
with latexmath:[t_i = t_0 + \sum_{k=0}^{i-1}h_k].

_[For the part of the Co-Simulation FMU that is based on an ODE, a differential equation is solved between communication points:_

[latexmath]
++++
\dot{\mathbf{x}}_c = \mathbf{\varphi} \left( \mathbf{x}_c(t), \mathbf{u}_c(t),
\mathbf{p}_{\mathit{tune}} \right)
++++

_If the simulation algorithm implements an extrapolation method of order_ latexmath:[m_{extra}] _, it can provide intermediate inputs of the form:_


[latexmath]
++++
\mathbf{u}_u(t)
=
\sum^{m_{\mathit{extra}}}_{j=0} \mathbf{C_{i, j}} \frac{(t-t_i)^j}{j!}
++++
_where_ latexmath:[\mathbf{C}_{i, j}] _are coefficients that can be equal to output derivatives of a connected FMU to realize a Taylor polynomial._

_The function_ latexmath:[\mathbf{\varphi}]  _shall approximate the numerical integration of the underlying differential equation._

_For example, for a stiff differential equation one could use a linear implicit Euler method (neglecting intermediate variable information):_

[latexmath]
++++
\mathbf{\Phi}_i \left( \mathbf{x}_{c,i}, \left\{ \mathbf{u}_{c,i} \right\}_{j = 0,\cdots,m_{ido}},\ \mathbf{p}_{\mathit{tune},i}, t_i \right)
=
\mathbf{x}_{c,i} + \left( \mathbf{I} -
h_i \frac{\partial \mathbf{\varphi}}{\partial \mathbf{x}_c} \right)^{- 1}  h_i \mathbf{\phi} \left( \mathbf{x}_{c,i}, \mathbf{u}_{c,i}, \mathbf{p}_{\mathit{tune},i} \right).
++++

_]_

Definition <<equation-co-simulation-evaluations>> is consistent with the definition of co-simulation by <<KS00>>.

* At the communication points, the simulation algorithm provides generalized inputs to the FMU:

** The current <<input>> variables latexmath:[\mathbf{u}_i] of the FMU (in other words, the <<input>> variables of the model represented by the FMU, in the sense of system-level simulation).

** Varying <<parameter,`parameters`>> latexmath:[\mathbf{p}_{\mathit{tune},i}], also known as <<tunable>> <<parameter,`parameters`>>.

* The FMU provides generalized outputs to the simulation algorithm, which are:

** The current output variables latexmath:[\mathbf{y}_{i+1}^{(0)}] of the FMU (same remark as above), along with some of their successive <<derivative,`derivatives`>> latexmath:[\left\{ \mathbf{y}_{i+1}^{(j)} \right\}_{j=1,\cdots,m_{odo}}] (in case of continuous-time variables).

** Observation variables and <<calculated>> varying <<parameter,`parameters`>> latexmath:[\mathbf{w}_{i+1}], along with directional derivatives estimated at latexmath:[t = t_{i+1}] (in case of continuous-time variables).

* At intermediate times latexmath:[t\in (t_i, t_{i+1})] the simulation algorithm and the FMU exchange values for latexmath:[\mathbf{u}_u(t)] and latexmath:[\mathbf{y}_u(t)].

* Initialization: The FMU being a sampled-data system, its internal states (which can be either continuous-time or discrete-time) need to be initialized at latexmath:[t = t_0].
This is performed through an auxiliary function _[this relationship is defined in the XML file under elements `<ModelStructure><InitialUnknown>`]_:

Computing the solution of an FMI Co-Simulation model means to split the solution process in two phases and in every phase different equations and solution methods are utilized.
The phases can be categorized according to the following modes:

==== Initialization Mode
This mode is used to compute at the start time latexmath:[t_0] initial values for all variables of the Co-Simulation FMU, especially for continuous-time <<state,`states`>> latexmath:[\mathbf{x}_c(t_0)], discrete-time states latexmath:[\mathbf{x}_d(t_0)], and for the previous discrete-time states latexmath:[^{\bullet}\mathbf{x}_d(t_0)] by utilizing extra equations only present in *Initialization Mode* _[for example, equations to set all <<derivative,`derivatives`>> to zero, that is, to initialize in steady-state]_.

If the FMU is connected in loops with other models, iterations over the FMU equations are possible.
Algebraic equations are solved in this mode.

==== Step Mode
This mode is used to compute the values of all continuous-time and discrete-time variables at communication points by numerically solving ordinary differential, algebraic and discrete equations.
If the FMU is connected in loops with other models, no iterations over the FMU equations are possible for a given communication point.

_[Remark - Calling Sequences:_

_In <<table-math-co-simulation>>, for notational convenience in *Initialization Mode* one function call is defined to compute all output arguments from all inputs arguments._
_In reality, every variable output argument is computed by one_ `fmi3Get{VariableType}` _function call._

_In *Step Mode* the input arguments to_ latexmath:[\mathbf{f}_{\mathit{doStep}}] _are defined by calls to_ `fmi3Set{VariableType}` _functions._
_The variables computed by_ latexmath:[\mathbf{f}_{\mathit{doStep}}] _can be inquired by_  `fmi3Get{VariableType}` _function calls.]_

==== Smoothness, Continuity and Discontinuity [[smoothness]]

Since inputs will be set at specific communication points by the importing tool, the FMU must make assumptions about the values between these communication points, including points of intermediate updates.

Between communication points, even when intermediate updates are called, all changes must be assumed to be continuous.
Changes to <<continuous>> variables are only considered discrete in *Event Mode*.

<<continuous, Continuous>> inputs may change between communication points in case of <<intermediateVariableSetRequested, `intermediateVariableSetRequested == true`>>.
These intermediate values are provided by the co-simulation algorithm for example by an extrapolation polynomial build with the output derivatives of connected FMUs (see <<recommendedIntermediateInputSmoothness>>).
FMUs can signal with the optional flag <<recommendedIntermediateInputSmoothness>> of value latexmath:[k] to the co-simulation algorithm that best convergence rates can be achieved if the functions are of smoothness latexmath:[C^{k}([t_i, t_{i+1}\])], that is k-time continuously differentiable, with latexmath:[C^{0}] meaning continuous.
It is therefore recommended that the function defined by the continuation of latexmath:[\mathbf{u}_{i, u}] with latexmath:[\mathbf{u}_{i+1, u}] is of smoothness latexmath:[C^{k}([t_i, t_{i+2}\])] with the optional flag <<recommendedIntermediateInputSmoothness>> of value latexmath:[k]. +
_[This can increase simulation speed for higher order multi-step solvers that in this case do not have to reset at communication points.]_

For <<continuous>> input variables, the importer must ensure that the input approximation function latexmath:[\mathbf{u}_u] is consistent with the values of the input variable (latexmath:[\mathbf{u}_u(t_{i+1})= \mathbf{u}(t_{i+1})]). +
If a <<continuous>> input changes `discontinuously` (e.g. the actual input value deviates too much from the extrapolation polynomial), the co-simulation algorithm must raise an event (if supported) to indicate to the FMU a discontinuous change at an input.

_[In the case of Co-Simulation without events, detecting discrete changes to continuous input variables (for instance to reset the integration algorithm) requires heuristics.]_

<<discrete, `Discrete`>> inputs keep their values between communication points.
Furthermore, changing <<discrete>> variables at communication points will likely require special handling within the FMU.
Since the FMU itself can detect such changes, the co-simulation algorithm does not need to raise explicit events in such a case.

==== Communication of Event Time and Input and Output Values [[Communication-during-update]]

The <<fmi3CallbackIntermediateUpdate>> callback described in <<IntermediateUpdateMode>> is also used in order to communicate the <<input>> and <<output>> and, in particular, the event and <<clock>> time from the FMU to the importer.
The <<fmi3CallbackIntermediateUpdate>> callback allows internal events (e.g. associated to <<outputClock>> ticks) to be signaled from an FMU to the importer.
For the interface type Co-Simulation, the <<fmi3CallbackIntermediateUpdate>> callback must be defined in the instantiate function, i.e. NULL is not allowed.

The arguments of <<fmi3CallbackIntermediateUpdate>> are used to signal <<outputClock>> ticks and internal events to the importer.
See <<IntermediateUpdateMode>> for details of the function parameters.

[source, C]
----
include::../headers/fmi3FunctionTypes.h[tag=CallbackIntermediateUpdate]
----

Only the first discontinuity event at a Newtonian time instant shall be signaled using this function.
There may be an event iteration in *Event Mode* at a Newtonian time instant causing super-dense time instants.

Based on the information provided by <<fmi3CallbackIntermediateUpdate>>, additional information about the discontinuity at that time instant can be obtained by the importer from the FMU by calling <<fmi3UpdateDiscreteStates>> and <<fmi3GetClock>>.

==== Early Return [[early-return]]

:DOSTEP: fmi3DoStep()
:CBIU: fmi3CallbackIntermediateUpdate()

//=== Improving efficiency in multi-FMU environment when asynchronous mode is used

_[In the particular context of multi-FMU architectures, significant co-simulation speed-up may be obtained if the co-simulation algorithm can avoid waiting until the end of the slowest FMU step integration._
_If an FMU prematurely stops its current step integration computation due to an unpredictable internal event before the normal end of the step calculation, all other concurrently running FMUs may be stopped as soon as possible in order to minimize the time needed for the co-simulation algorithm to resynchronize all the FMUs at the same event time._

_In this context based on parallel multi-FMU calculations, <<figure-early-return>> illustrates different possibilities to synchronize FMUs at the same event time._

.Different possibilities to synchronize parallel FMUs at the same event time.
[[figure-early-return]]
image::images/earlyReturnFigure.svg[width=100%, align="center"]

_Each FMU starts integration from communication point_ latexmath:[t_{i}] _to reach the next communication point_ latexmath:[t_{i+1}] _._
_Assuming an unexpected internal event is detected at_ latexmath:[t^{'}_{i+1}< t_{i+1}] _inside FMU~1~ , the FMU immediately informs the co-simulation algorithm and asks for an <<early-return,early return>>._
_Since all FMUs should be resynchronized at the event time which will be the next new communication point, the co-simulation algorithm would like to avoid other FMUs exceed the event time._

* _In the case of FMU~1~, the FMU waits to get pushed into the event mode to handle the event at_ latexmath:[t^{'}_{i+1}] _._
* _FMU~2~ can not be interrupted before it reaches_ latexmath:[t_{i+1}] _, which requires a complete rollback and a new co-simulation from_ latexmath:[t_{i}] _to_ latexmath:[t^{'}_{i+1}] _._
* _FMU~3~ triggers the callback function to the co-simulation algorithm after passing_ latexmath:[t^{'}{i+1}] _, which leads to a request by the co-simulation algorithm to immediately do an <<early-return,early return>>.
The FMU interrupts its computation and a partial rollback and a new co-simulation from_ latexmath:[t_{i}] _to_ latexmath:[t^{'}_{i+1}] _is necessary._
* _In the case of FMU~4~, the FMU triggered the callback function before reaching_ latexmath:[t^{'}_{i+1}] _.
The co-simulation algorithm requests FMU~4~ to do an <<early-return,early return>> at_ latexmath:[t^{'}{i+1}] _and the FMU will interrupt its current integration step at_ latexmath:[t^{'}{i+1}] _.
No rollback is necessary for FMU~4~._

_Each ongoing FMU stops its integration either exactly at the interrupt time given by the co-simulation algorithm or immediately after its current intermediate step, if this time is already out-of-date._
_Afterwards, a new step integration done on the FMU returns and signals the premature stop (early-return) to the importer._

_Due to the early-return mechanism, the overall execution time of the simulation can be reduced.]_

A Co-Simulation FMU is allowed to stop the execution of <<fmi3DoStep>> and return without reaching the predefined communication time, i.e. <<currentCommunicationPoint>> `+` <<communicationStepSize>>.
This mechanism is called <<early-return,"early return">>.

[[canReturnEarlyAfterIntermediateUpdate,`canReturnEarlyAfterIntermediateUpdate`]]
The Boolean capability flag <<canReturnEarlyAfterIntermediateUpdate>> in the <<modelDescription.xml>> file indicates whether the FMU supports the early-return feature.
The default value of this capability flag is `false`.

Each time an internal discontinuity or an event happens inside an FMU with capability flag <<canReturnEarlyAfterIntermediateUpdate,`canReturnEarlyAfterIntermediateUpdate = true`>>, the callback function <<fmi3CallbackIntermediateUpdate>> is called by the FMU.
The importer can only use this <<early-return,early return>> functionality, if it provides the <<fmi3CallbackIntermediateUpdate>> callback function pointer in the instantiate function.

With the <<early-return,early return>> feature, an FMU can signal <<outputClock>> events or internal state changes, i.e., discontinuity events to the importer at any time (not only at the end of <<fmi3DoStep>> function calls).
When an internal event occurs inside the FMU at a time instant, it informs the importer that a new communication point for the Co-Simulation can be created.
Note that an event signal is not seen in the narrow sense of solver induced discontinuity events but in the general sense of a simulation event that has to be handled by the importer (e.g. state changes that require extended handling).

A second use of the early-return mechanism is the following:
In particular in multi-node architectures, significant co-simulation speed-up may be obtained if the importer can avoid waiting until the end of the slowest <<fmi3DoStep>>, when many FMUs are integrating in parallel and an event occurs.
To exploit such efficiency gains, the importer can command the FMUs to return early from the current communication step, if it gets triggered in the callback function by the FMUs.
_[In this use case, <<early-return,early return>> is a simple form of cooperative multitasking.]_

<<early-return,Early return>> is even helpful if the FMU or the co-simulation algorithm do not support the advanced handling of events based on the <<fmi-for-co-simulation,Co-Simulation>> functionalities.
Multiple event types and also <<triggered>> <<clock>> activations can be supported based on the early-return functionality and additional functionalities provided by <<fmi-for-co-simulation,Co-Simulation>>.

==== Handling Early Return and Events

If the FMU is successful in conducting an <<early-return,early return>>, <<fmi3DoStep>> returns with <<earlyReturn,`earlyReturn == fmi3True`>>.
If the FMU returns from <<fmi3DoStep>> with <<earlyReturn,`earlyReturn == fmi3True`>>, the importer has to call <<fmi3EnterEventMode>> for that FMU.

[source, C]
----
include::../headers/fmi3FunctionTypes.h[tag=EnterEventMode]
----

The importer can also call <<fmi3EnterEventMode>> at communication instants to handle input events, as will be discussed in following sections.

If an FMU provides the early-return capability that includes the handling of events in *Event Mode*,
the FMU signals this via <<canReturnEarlyAfterIntermediateUpdate>> in the <<modelDescription.xml>>.

The FMU stops computation at the first encountered internal event (if any) and the event time is provided through the output argument <<lastSuccessfulTime>>, along with the reason <<eventEncountered, `eventEncountered == fmi3True`>>.
The importer will start event handling by calling <<fmi3EnterEventMode>> for that FMU to push the FMU into *Event Mode*.
In this mode the importer is supposed to catch all events through the <<fmi3UpdateDiscreteStates>> function.

If an early-return request of the importer is ignored by the FMU, then <<fmi3DoStep>> returns with <<earlyReturn,`earlyReturn == fmi3False`>>.
The importer can start a resynchronization of FMUs at an event time, if the <<currentCommunicationPoint>> has passed the event time, the importer can roll-back the FMU and repeat the step with a suitable <<communicationStepSize>> (if the FMU supports the roll-back).

//The following pseudo-code example shows an implementation of <<fmi3CallbackIntermediateUpdate>> that uses <<earlyReturn>>, <<earlyReturnRequested>> and //<<earlyReturnTime>> to handle events inside the FMU:

//[source, c]
//----
//include::Reference-FMUs/examples/cs_early_return.c[tag=EventEarlyReturn]
//----

==== Clock Support [[api-clocked-co-simulation]]

If an FMU provides <<clock,`clocks`>> and the importer instantiates the interface type Co-Simulation, the importer must handle these <<clock,`clocks`>> and <<early-return,early return>> requests by the FMU.

===== Transfer of Input and Output Values and Parameters [[transfer-of-input-output-and-parameters-clocked-co-simulation]]

If the importer supports <<clock,`clocks`>>, all <<inputClock,`input clocks`>> of the model should be handled and <<inputClock>> events should be scheduled by the importer.
If an <<outputClock>> will tick, the FMU returns from <<fmi3DoStep>> with <<clocksAboutToTick,`clocksAboutToTick == fmi3True`>>.
After calling <<fmi3UpdateDiscreteStates>>, the activation status of <<outputClock,`output clocks`>> can be retrieved with <<fmi3GetClock>>.
Then <<fmi3SetClock>> (and <<fmi3SetIntervalDecimal>> or <<fmi3SetIntervalFraction>> if necessary) should be invoked to enable the ticked <<inputClock,`input clocks`>>.
Each <<clock>>, that ticks outside of the FMU (i.e. <<inputClock>>), is activated for an FMU based on its <<clockReference>> and an associated <<fmi3SetClock>> in *Event Mode*.
<<fmi3SetClock>> can activate multiple <<clock,`clocks`>> with each call.
An event iteration is possible.
Once all <<clock>> events are handled for this time instant, the FMU should be pushed into *Step Mode* by calling <<fmi3EnterStepMode>>.
In *Step Mode*, the importer can call <<fmi3DoStep>> for the time interval from the current event time instant until the next input event instant.
Note that <<fmi3DoStep>> may not reach the next input event instant because an <<early-return,early return>> may occur.

The importer sets and gets <<clock>> variable values similar to the FMI for Model Exchange, as defined in <<clocks>>.

===== Computation in Co-Simulation [[computation-clocked-co-simulation]]

Similar to FMI for Model Exchange, in order to activate <<inputClock,`input clocks`>> of an FMU, it is required to push the FMU into *Event Mode* by calling <<fmi3EnterEventMode>>.
If <<fmi3DoStep>> returns with <<eventEncountered,`eventEncountered == fmi3True`>> or <<clocksAboutToTick,`clocksAboutToTick == fmi3True`>>, the FMU must be pushed into *Event Mode* and <<fmi3UpdateDiscreteStates>> must be called.

In order to retrieve the status of <<outputClock,`output clocks`>>, <<fmi3GetClock>> and <<fmi3GetIntervalDecimal>> or <<fmi3GetIntervalFraction>> need to be called in the *Event Mode*.
If the <<fmi3DoStep>> return value is <<fmi3OK>>, the calling of <<fmi3GetClock>>, <<fmi3GetIntervalDecimal>>, <<fmi3GetIntervalFraction>>, <<fmi3UpdateDiscreteStates>> is only meaningful after <<fmi3SetClock>> in the case of super-dense time iterations are desired.

Similar to the Model Exchange case, the allowed call order is <<fmi3GetClock>>, <<fmi3GetIntervalDecimal>>, <<fmi3GetIntervalFraction>>, `fmi3Get{VariableType}`, `fmi3Set{VariableType}`.
Function calls of this call order can be omitted.

Once handling of the <<clock>> events finished, the importer calls <<fmi3EnterStepMode>> for that FMU to push it into *Step Mode*.

_[Usually the importer should be able to derive the correct communication point times for <<inputClock,`input clocks`>> in advance and thus it should be able to set the proper <<communicationStepSize>> for <<fmi3DoStep>>._
_Such predictions are not possible if an <<inputClock>> of an FMU depends on the ticking of a triggered <<outputClock>> of another FMU.]_
