=== FMI Description Schema [[fmi-description-schema]]

[[modelDescription.xml,`modelDescription.xml`]]
All static information related to the core functionality of an FMU is stored in the text file <<modelDescription.xml>> in XML format as specified by the XML schema file `fmi3ModelDescription.xsd`.
Especially, the FMU variables and their attributes such as `name`, `unit`, default <<initial>> value, etc. are stored in this file.

Additional optional information about the graphical representation and the grouping of FMU variables into terminals is stored in the optional text file `icons/terminalsAndIcons.xml` in XML format as specified by the XML schema file `fmi3TerminalsAndIcons.xsd`.

Build information for source code FMUs is provided together with a `buildDescription.xml` file in the `sources` directory that adheres to the `fmi3BuildDescription.xsd` schema file.

It is not allowed to change the <<modelDescription.xml>> file.
_[Reason: The <<modelDescription.xml>> file has to be consistent with the binary or source code implementations._
_Specifically, changes to the start values are not allowed.]_

The structure of the XML files is defined with the schema file `fmi3ModelDescription.xsd` and the optional `fmi3TerminalsAndIcons.xsd` and `fmi3BuildDescription.xsd` files.
These schema files utilize several helper schema files.

In this section these schema files are discussed.
The normative definition are the above mentioned schema files.
In the graphical representation of the schema, optional elements are marked with a dashed box (e.g., see <<figure-schema-Annotations>>).
The required data types (like: `xs:normalizedString`) are defined in https://www.w3.org/TR/xmlschema-2/[XML Schema Part 2: Datatypes Second Edition].
The types used in the FMI schema files are:

.Types used in the FMI 3.0 schema files.
[#table-types-in-schema]
[cols="1,3,1,1"]
|====
|XML
|Description (http://www.w3.org/TR/xmlschema-2/)
|Mapping to C
|Mapping to FMI 3.0

|`double`
|IEEE 754 double-precision 64-bit floating point type _[An IEEE 754 double-precision floating point value can have up to 17 significant digits in its decimal representation.
In order to not loose precision, either an appropriate minimal printer algorithm should be used, or alternatively a number of this type should be stored in XML files with at least 17 significant digits.]_
|`double`
|`fmi3Float64`

|`single`
|IEEE 754 single-precision 32-bit floating point type _[An IEEE 754 single-precision floating point value can have up to 9 significant digits in its decimal representation.
In order to not loose precision, either an appropriate minimal printer algorithm should be used, or alternatively a number of this type should be stored in XML files with at least 9 significant digits.]_
|`float`
|`fmi3Float32`

|`byte`
|Integer number with maximum value 127 and minimum value -128 (8 bit signed integer)
|`int8_t`
|`fmi3Int8`

|`unsignedByte`
|Integer number with maximum value 255 and minimum value 0 (8 bit unsigned integer)
|`uint8_t`
|`fmi3UInt8`

|`short`
|Integer number with maximum value 32767 and minimum value -32768 (16 bit signed integer)
|`int16_t`
|`fmi3Int16`

|`unsignedShort`
|Integer number with maximum value 65535 and minimum value 0 (16 bit unsigned integer)
|`uint16_t`
|`fmi3UInt16`

|`int`
|Integer number with maximum value 2147483647 and minimum value -2147483648 (32 bit signed integer)
|`int32_t`
|`fmi3Int32`

|`unsignedInt`
|Integer number with maximum value 4294967295 and minimum value 0 (32 bit unsigned integer)
|`uint32_t`
|`fmi3UInt32`

|`long`
|Integer number with maximum value 9223372036854775807 and minimum value -9223372036854775808 (64 bit signed integer)
|`int64_t`
|`fmi3Int64`

|`unsignedLong`
|Integer number with maximum value 18446744073709551615 and minimum value 0 (64 bit unsigned integer)
|`uint64_t`
|`fmi3UInt64`

|`boolean`
|Boolean number.
Legal literals: `false`, `true`, `0`, `1`
|`int`
|`fmi3Boolean`

|`string`
|Any number of characters
|`char*`
|`fmi3String`

|`normalizedString`
|String without carriage return, line feed, and tab characters
|`char*`
|`fmi3String`

|`hexBinary`
|Arbitrary hex-encoded binary data
|`char*`
|`fmi3Binary`

|`dateTime`
|Date, time and time zone (for details see https://www.w3.org/TR/xmlschema-2/[XML Schema Part 2: Datatypes Second Edition]).
Example: `2002-10-23T12:00:00Z` (noon on October 23, 2002, Greenwich Mean Time)
|tool specific
|not defined
|====

The first line of an XML file, such as <<modelDescription.xml>>, must contain the encoding scheme of the XML file.
It is required that the encoding scheme is always UTF-8:

[source, xml]
----
include::examples/co_simulation.xml[lines=1]
----

The FMI schema files (`fmi3*.xsd`) are also stored in UTF-8. +
_[Note that the definition of an encoding scheme is a prerequisite in order for the XML file to contain letters outside of the 7 bit ANSI ASCII character set, such as German umlauts, or Asian characters._
_Furthermore, note the FMI calling interface requires that strings are encoded in UTF-8._
_Since the XML files are also required to be encoded in UTF-8, string variables need not to be transformed when reading from the XML files in to C string variables.]._

_[Note that child information items, such as elements in a sequence are ordered lists according to document order, whereas attribute information items are unordered sets (see http://www.w3.org/TR/XML-infoset/#infoitem.element)._
_The FMI schema is based on ordered lists in a sequence and therefore parsing must preserve this order._
_For example, the information stored in <<ContinuousStateDerivative>> in `<ModelStructure>` is only correct if this property is fulfilled.]_

All XML-based file formats defined in this standard allow optional `Annotation` elements to be inserted in all XML elements that represent entities of the underlying data model.
This is achieved through the `Annotations` element:

.Annotations Element.
[#figure-schema-Annotations]
image::images/schema/Annotations.png[width=80%]

Each `Annotation` element contains a required `type` attribute, which contains the namespace for that annotation.
The content of the `Annotation` element can be arbitrary XML data, and can make use of XML namespaces and XML schemas for combined validation where appropriate.

The namespace mechanism for the `type` attribute is based on reverse domain notation:
The originator of a specification for additional data specifies a domain name under their control as the namespace for the additional data, in order to avoid conflicts due to name collisions.
The namespace is used in reverse domain notation.
All namespaces under both the `org.modelica` and `org.fmi-standard` domains are reserved for use in future layered standards.

_[For example, extensions defined by the Modelica Association might make use of the `org.modelica.fmi` namespace._
_This could lead to annotations with a `type` attribute of `org.modelica.fmi.something`, and/or extra files under the `extra/org.modelica.ssp.something` sub-directory.]_

Annotations are intended to allow structured extensions of the FMI XML files, without creating conflicting extensions, or leaving ambiguities in interpretation.
All annotations can safely be ignored by implementations that just implement the base FMI standard.

==== Definition of an FMU [[fmiModelDescription]]

This is the root-level schema file and is illustrated in <<system_overview>>.
The figure contains all elements in the schema file.
Data is defined by attributes to these elements.

.fmiModelDescription element.
[[system_overview]]
image::images/schema/fmiModelDescription.png[width=70%]

On the top level, the schema consists of the elements detailed in <<table-schema-fmiModelDescription>>.
_[If an optional element is present and defines a list (such as `<UnitDefinitions>`), the list must have at least one element (such as `<Unit>`).]_

.fmiModelDescription element details.
[[table-schema-fmiModelDescription]]
[cols="1,3",options="header"]
|====
|Element
|Description

|`<ModelExchange>`
|If present, the FMU is based on FMI for Model Exchange (<<fmi-for-model-exchange>>) _[(in other words, the FMU includes the model or the communication to a tool that provides the model, and the environment provides the simulation engine)]_.

|`<CoSimulation>`
|If present, the FMU is based on FMI for Co-Simulation (<<fmi-for-co-simulation>>).

|`<ScheduledExecution>`
|If present, the FMU is based on FMI for Scheduled Execution (<<fmi-for-scheduled-execution>>).

|`<UnitDefinitions>`
|A global list of unit and display unit definitions _[for example, used to convert display units into the units used in the model equations]_.
These definitions are used in the XML element `<ModelVariables>`.

|`<TypeDefinitions>`
|A global list of type definitions that are utilized in `<ModelVariables>`.

|`<LogCategories>`
|A global list of log categories that can be set to define the log information that is supported from the FMU.

|`<DefaultExperiment>`
|Providing default settings for the integrator, such as stop time and relative tolerance.

|`<ModelVariables>`
|The central FMU data structure defining all variables of the FMU that are visible/accessible via the FMU functions.

|`<ModelStructure>`
|Defines the structure of the model.
Especially, the ordered lists of <<output,`outputs`>>, continuous-time <<state,`states`>>, initial unknowns (the unknowns during <<InitializationMode>>) and the event indicators are defined here.
For more details on `<ModelStructure>`, see <<ModelStructure>>.
Furthermore, the dependency of the unknowns from the knowns can be optionally defined for <<output,`outputs`>>, continuous-time <<state,`states`>> and initial unknowns.
_[This information can be, for example, used to compute efficiently a sparse Jacobian for simulation, or to utilize the <<input>> / <<output>> dependency in order to detect that in some cases there are actually no algebraic loops when connecting FMUs together]_.
Dependencies for event indicators are not provided.
_[The calculation of derivatives of event indicators is not provided.]_.

|`<Annotations>`
|Optional annotations for the top-level element.

|====

At least one element of `<ModelExchange>`, `<CoSimulation>` or `<ScheduledExecution>` must be present to identify the type of the FMU.
If multiple elements are defined, different types of models are included in the FMU.
The details of these elements are defined in <<fmi-for-model-exchange>>, <<fmi-for-co-simulation>> or <<fmi-for-scheduled-execution>>.

The XML attributes of `<fmiModelDescription>` are:

.fmiModelDescription attribute details.
[[table-schema-fmiModelDescription-attributes]]
[cols="1,3",options="header"]
|====
|Attribute
|Description

|`fmiVersion`
|Version of FMI that was used to generate the XML file.
The value for this version is `3.0`.
Future minor revisions are denoted as `3.1`, `3.2` ...

_[During development prototype FMU implementations can indicate compliance with a certain development version based on the tags available at https://github.com/modelica/fmi-standard/tags._
_For example the value for the FMI 3.0 Alpha 2 release is `3.0-alpha.2`.]_

|`modelName`
|The name of the model as used in the modeling environment that generated the XML file, such as `Modelica.Mechanics.Rotational.Examples.CoupledClutches`.

|[[instantiationToken,`instantiationToken`]]`instantiationToken`
|The <<instantiationToken>> is a string that can be used by the FMU to check that the XML file is compatible with the implementation of the FMU.
For this purpose the importing tool must pass the <<instantiationToken>> from the <<modelDescription.xml>> to the <<fmi3Instantiate>> function call.

|`description`
|Optional string with a brief description of the model.

|`author`
|Optional string with the name and organization of the model author.

|`version`
|Optional version of the model _[for example `1.0`]_.

|`copyright`
|Optional information on the intellectual property copyright for this FMU _[for example `(C) My Company 2011`]_.

|`license`
|Optional information on the intellectual property licensing
for this FMU _[for example `BSD license <license text or link to license>`]_.

|`generationTool`
|Optional name of the tool that generated the XML file.

|`generationDateAndTime`
|Optional date and time when the XML file was generated.
The format is a subset of `dateTime` and should be: `YYYY-MM-DDThh:mm:ssZ` (with one `T` between date and time; `Z` characterizes the Zulu time zone, in other words, Greenwich meantime) _[for example `2009-12-08T14:33:22Z`]_.

|[[variableNamingConvention,`variableNamingConvention`]]<<variableNamingConvention>>
|Defines whether the variable names in `<ModelVariables>` and in `<TypeDefinitions>` follow a particular convention.
For the details, see <<namingSection>>.
Currently standardized are:

`= flat`: A list of strings (the default).

`= structured`: Hierarchical names with `.` as hierarchy separator, and with array elements and derivative characterization.

|====

==== Definition of Capability Flags [[common-capability-flags]]

The elements `<ModelExchange>`, `<CoSimulation>` and `<ScheduledExecution>` contain attributes representing capability flags describing which optional functionalities the FMU supports.

The following table contains capability flags common to all three interface types.

.Common capability flags.
[[table-common-capability-flags]]
[cols="1,1",options="header"]
|====
|Attribute
|Description

|`needsExecutionTool`
|If `true`, a tool is needed to execute the model and the FMU just contains the communication to this tool.
_[Typically, this information is only utilized for information purposes._
_For example, when loading an FMU with `needsExecutionTool = true`, the environment can inform the user that a tool has to be available on the computer where the model is instantiated._
_The name of the tool can be taken from attribute `generationTool` in `<fmiModelDescription>`.]_

|`canBeInstantiatedOnlyOncePerProcess`
|This flag indicates cases (especially for embedded code), where only one instance per FMU is possible (multiple instantiation is default = `false`; if multiple instances are needed and the flag `canBeInstantiatedOnlyOncePerProcess = true`, the FMUs must be instantiated in different processes).

|[[canGetAndSetFMUState,`canGetAndSetFMUState`]]`canGetAndSetFMUState`
|If `true`, the environment can inquire the internal FMU state and can restore it.
That is, functions <<fmi3GetFMUState>>, <<fmi3SetFMUState>>, and <<fmi3FreeFMUState>> are supported by the FMU.

|[[canSerializeFMUState,`canSerializeFMUState`]]`canSerializeFMUState`
|If `true`, the environment can serialize the internal FMU state, in other words, functions <<fmi3SerializedFMUStateSize>>, <<fmi3SerializeFMUState>>, <<fmi3DeSerializeFMUState>> are supported by the FMU.
If this is the case, then flag <<canGetAndSetFMUState>> must be `true` as well.

|[[providesDirectionalDerivatives,`providesDirectionalDerivatives`]]`providesDirectionalDerivatives`
|If `true`, the directional derivative of the equations can be computed with <<fmi3GetDirectionalDerivative>>.

|[[providesAdjointDerivatives,`providesAdjointDerivatives`]]`providesAdjointDerivatives`
|If `true`, the adjoint derivatives of the equations can be computed with <<fmi3GetAdjointDerivative>>.

|`providesPerElementDependencies`
|The FMU is able to provide detailed dependency information at run time using <<fmi3GetNumberOfVariableDependencies>> and <<fmi3GetVariableDependencies>>.

|[[maxOutputDerivativeOrder,`maxOutputDerivativeOrder`]] `maxOutputDerivativeOrder`
|The FMU is able to provide <<derivative,`derivatives`>> of <<output,`outputs`>> with maximum order.
Calling of `fmi3GetOutputDerivatives` is allowed up to the order defined by `maxOutputDerivativeOrder`.
This flag is ignored in `ModelExchange`.

|[[providesIntermediateUpdate,`providesIntermediateUpdate`]] `providesIntermediateUpdate`
|The FMU supports <<IntermediateUpdateMode>> and will call <<fmi3CallbackIntermediateUpdate>>, if provided.
This flag is ignored in `ModelExchange`.

|[[recommendedIntermediateInputSmoothness,`recommendedIntermediateInputSmoothness`]] `recommendedIntermediateInputSmoothness`
|A value of latexmath:[k] with latexmath:[k>0] signals to the co-simulation algorithm, that it is beneficial for the solver to receive intermediate inputs that are k-time continuously differentiable (latexmath:[C^k]) on the current communication interval.
latexmath:[k=0] means continuous (see <<smoothness>>). +
This flag is not supported in `ModelExchange`.

|====

==== Definition of Units

In this section, the units of the variables are defined.

_[Unit support is important for technical systems since otherwise it is very easy for errors to occur._
_Unit handling is a difficult topic, and there seems to be no method available that is really satisfactory for all applications, such as unit check, unit conversion, unit propagation or dimensional analysis._
_In FMI, a pragmatic approach is used that takes into account that every software system supporting units has potentially its own specific technique to describe and utilize units.]_

Element `<fmiModelDescription><UnitDefinitions>` is defined as:

.UnitDefinitions element.
[[figure-schema-UnitDefinitions]]
image::images/schema/UnitDefinitions.png[width=90%]

It contains one or more `Unit` definitions.
If no units are defined, element `<UnitDefinitions>` must not be present.

The `name` of a `Unit` must be unique with respect to all other `<Unit>` elements.
If a variable is associated with a `Unit`, the value passed to <<get-and-set-variable-values,`fmi3Set{VariableType}`>> (resp. retrieved with <<get-and-set-variable-values,`fmi3Get{VariableType}`>>) has this unit.
_[The purpose of the name is to uniquely identify a unit and, for example, use it to display the unit in menus or in plots._
_Since there is no standard to represent units in strings, and there are different ways how this is performed in different tools, no specific format for the string representation of the unit is required.]_

The `Unit` definition consists of the exponents of the 7 SI base units `kg`, `m`, `s`, `A`, `K`, `mol`, `cd`, the exponent of the SI derived unit `rad`, and optionally a `factor` and an `offset`.
_[The additional `rad` base unit helps to handle the often occurring quantities in technical systems that depend on an angle.]_

.BaseUnit element.
[[figure-schema-BaseUnit]]
image::images/schema/BaseUnit.png[width=50%, align="center"]

A value latexmath:[v_{unit}] in `Unit` is converted to the base unit latexmath:[v_{base}] by the equation

[latexmath]
++++
v_{base} = \texttt{factor} * v_{unit} + \texttt{if relativeQuantity then 0 else offset}
++++
where `factor` and `offset` are attributes of the `<BaseUnit>`, and  `relativeQuantity` an attrinbute of the `TypeDefinition` of a variable.

_[For example, if_ latexmath:[{p_{\mathit{bar}}}] _is a pressure value in unit `bar`, and_ latexmath:[{p_{\mathit{Pa}}}] _is the pressure value in `<BaseUnit>`, then_

[latexmath]
++++
{p_{\mathit{Pa}} = 10^5 p_{\mathit{bar}}}
++++

_and therefore, `factor = 1.0e5` and `offset = 0.0`._

_In the following table several unit examples are given._
_Note that if in column `exponents` the definition_ latexmath:[\frac{kg \cdot m^2}{s^2}] _is present, then the attributes of `<BaseUnit>` are  `kg=1, m=2, s=-2`._

.Unit examples.
[[table-unit-examples]]
[cols="1,1,1,1,1"]
|====
.2+|Quantity
.2+|Unit.name +
(examples)

3+|Unit.BaseUnit
|exponents
|factor
|offset

|_Torque_
|`N.m`
|latexmath:[{kg \cdot m^2 / s^2}]
|`1.0`
|`0.0`

|_Energy_
|`J`
|latexmath:[{kg \cdot m^2 / s^2}]
|`1.0`
|`0.0`

|_Pressure_
|`bar`
|latexmath:[{\frac{kg}{m \cdot s^2}}]
|`1.0e5`
|`0.0`

|_Angle_
|`deg`
|`rad`
|`0.01745329251994330 (= pi/180)`
|`0.0`

|_Angular velocity_
|`rad/s`
|`rad/s`
|`1.0`
|`0.0`

|_Angular velocity_
|`rpm`
|`rad/s`
|`0.1047197551196598 (= 2*pi/60)`
|`0.0`

|_Frequency_
|`Hz`
|`rad/s`
|`6.283185307179586 (= 2*pi)`
|`0.0`

|_Temperature_
|`&#176;F`
|`K`
|`0.5555555555555556 (= 5/9)`
|`255.3722222222222 (= 273.15-32*5/9)`

|_Per cent by length_
|`%/m`
|`1/m`
|`0.01`
|`0.0`

|_Parts per million_
|`ppm`
|`1`
|`1.0e-6`
|`0.0`

|_Length_
|`km`
|`m`
|`1000`
|`0.0`

|_Length_
|`yd`
|`m`
|`0.9144`
|`0.0`
|====

_Note that `Hz` is typically used as `Unit.name` for a frequency quantity, but it can also be used as `<DisplayUnit>` for an angular velocity quantity (since `revolution/s`).]_

_The `<BaseUnit>` definitions can be utilized for different purposes (the following application examples are optional and a tool may also completely ignore the `Unit` definitions):_

Unit check when connecting variables of different FMUs::
+
_When only one of <<input>> `v2` and <<output>> `v1`, connected with equation `v2 = v1`, defines a `<BaseUnit>` element, <<get-and-set-variable-values,`fmi3Get{VariableType}`>> must be used to get the value of `v1`  to then set it with <<get-and-set-variable-values,`fmi3Set{VariableType}`>> for `v2`._
+
_When two variables v1 and v2 are connected and for both of them `<BaseUnit>` elements are defined, then they must have identical exponents of their `<BaseUnit>`._
_If `factor` and `offset` are also identical, again the connection equation `v2 = v1` holds._
_If `factor` and `offset` are not identical, the tool may either trigger an error or, if supported, perform a conversion; in other words, use the connection equation (in this case the `relativeQuantity` of the `<TypeDefinition>`, see below, has to be taken into account in order to determine whether `offset` shall or shall not be utilized):_
+
`factor(v1) * v1 + (if relativeQuantity(v1) then 0 else offset(v1)) = factor(v2) * v2 + (if relativeQuantity(v2) then 0 else offset(v2))` +
_where_ `relativeQuantity(v1) = relativeQuantity(v2)` _is required_.
+
_As a result, wrong connections can be detected (for example, connecting a force with an angle-based variable would trigger an error) and conversions between, say, US and SI units can be either automatically performed or, if not supported, an error is triggered as well._
+
_This approach is not satisfactory for variables belonging to different quantities that have, however, the same `<BaseUnit>`, such as quantities `Energy` and `Torque`, or `AngularVelocity` and `Frequency`._
_To handle such cases, quantity definitions have to be taken into account (see `<TypeDefinitions>`) and quantity names need to be standardized._
+
_This approach allows a general treatment of units, without being forced to standardize the grammar and allowed values for units (for example, in FMI 1.0, a unit could be defined as `N.m` in one FMU and as `N*m` in another FMU, and a tool would have to reject a connection, since the units are not identical._
_In FMI 2.0, the connection would be accepted, provided both elements have the same `<BaseUnit>` definition)._

Dimensional analysis of equations::
+
_In order to check the validity of equations in a modeling language, the defined units can be used for dimensional analysis, by using the `<BaseUnit>` definition of the respective unit._
_For this purpose, the `<BaseUnit>` `rad` has to be treated as `1`._
_Example:_
+
[latexmath]
++++
\begin{align*}
J \cdot \alpha = \tau \rightarrow [kg.m^2]*[rad/s^2] = [kg.m^2/s^2] & \quad \text{// o.k. ("rad" is treated as "1")} \\
J \cdot \alpha = f \rightarrow [kg.m^2]*[rad/s^2] = [kg.m/s^2] & \quad \text{// error, since dimensions do not agree}
\end{align*}
++++

Unit propagation::
+
_If unit definitions are missing for variables, they might be deduced from the equations where the variables are used._
_If no unit computation is needed, `rad` is propagated._
_If a unit computation is needed and one of the involved units has `rad` as a `<BaseUnit>`, then unit propagation is not possible._
_Examples:_
+
- _a = b + c, and `Unit` of c is provided, but not `Unit` of a and b:_ +
_The Unit definition of `c` (in other words, `Unit.name`, `<BaseUnit>`, `<DisplayUnit>`) is also used for `a` and `b`._
_For example, if BaseUnit(c) = `rad/s`, then BaseUnit(a) = BaseUnit(b) = `rad/s`._
+
- _a = b*c, and `Unit` of a and of c is provided, but not `Unit` of b:_ +
_If `rad` is either part of the `<BaseUnit>` of `a` and/or of `c`, then the `<BaseUnit>` of `b` cannot be deduced (otherwise it can be deduced)._
_Example: If `BaseUnit(a) = kg.m/s2` and `BaseUnit(c) = m/s2`, then the `BaseUnit(b) can be deduced to be `kg`._
_In such a case `Unit.name` of b cannot be deduced from the `Unit.name` of `a` and `c`, and a tool would typically construct the `Unit.name` of `b` from the deduced `<BaseUnit>`.]_

A `<Unit>` can contain any number of `<DisplayUnit>` elements.

.DisplayUnit element.
[[figure-schema-DisplayUnit]]
image::images/schema/DisplayUnit.png[width=70%, align="center"]

A `<DisplayUnit>` is defined by `name`, `factor`, `offset`, and `inverse`.
The attribute `name` must be unique with respect to all other names of the `<DisplayUnit>` definitions of the same `Unit`.
_[Different `Unit` elements may have the same `<DisplayUnit>` names]._ +
`inverse == true` is only allowed if `offset == 0`. +
_[Reason: no use case is known for the combination of inverse and offset, which would also be more complicated.]_

A value latexmath:[v_{unit}] in `Unit` is converted to a value latexmath:[v_{display}] in `DisplayUnit` by the equation:

[latexmath]
++++
v_{display} =
\left\{\begin{array}{ll}
\texttt{factor} *          v_{unit}  + \texttt{offset} &\text{if} \; \texttt{inverse == false} \\
\texttt{factor} * \frac{1}{v_{unit}}  &\text{if} \; \texttt{inverse == true}
\end{array}\right.
++++

_[`offset` is needed for temperature units like `F` (Fahrenheit), `inverse` for inverse display units like `mpg` (miles per gallon) or `S` (Siemens)._

_For example, if latexmath:[{T_K}] is the temperature value of `Unit.name` (in `K`) and latexmath:[{T_F}] is the temperature value of `<DisplayUnit>` (in `&#176;F`), then_

[latexmath]
++++
T_F = (9/5) * (T_K - 273.15) + 32
++++

_and therefore, `factor = 1.8 (=9/5)` and `offset = -459.67 (= 32 - 273.15*9/5)`._

_Both the `DisplayUnit.name` definitions as well as the `Unit.name` definitions are used in the variable elements._

_Example of a definition:_

[source, xml]
----
include::examples/unit_definition.xml[tags=UnitDefinitions]
----
_]_

==== Definition of Types [[definition-of-types]]

Element `<fmiModelDescription><TypeDefinitions>` is defined as:

.TypeDefinitions element.
[[figure-schema-TypeDefinitions]]
image::images/schema/TypeDefinitions.png[width=70%, align="center"]

This element consists of a set of `<TypeDefinition>` elements according to schema `fmi3TypeDefinition` in file `fmi3Type.xsd`.
Each `<TypeDefinition>` has attributes `name` and `description`.
Attribute `name` must be unique with respect to all other elements of the `<TypeDefinitions>` list.
Furthermore, `name` of a `<TypeDefinition>` must be different to all `name` attributes of variables _[if the same names would be used, then this would nearly always give problems when importing the FMU in an environment such as Modelica, where a type name cannot be used as instance name]_.

Additionally, one variable type element must be present.
Each variable type has its own attributes which can be consulted in the schema.
<<figure-schema-Float64Type>>, <<figure-schema-Int32Type>>, <<figure-schema-BooleanType>>, <<figure-schema-BinaryType>>, and <<figure-schema-EnumerationType>>, are representative examples.

.Float64Type element.
[[figure-schema-Float64Type]]
image::images/schema/Float64Type.png[width=90%, align="center"]

.Int32Type element.
[[figure-schema-Int32Type]]
image::images/schema/Int32Type.png[width=90%, align="center"]

.BooleanType element.
[[figure-schema-BooleanType]]
image::images/schema/BooleanType.png[width=90%, align="center"]

.BinaryType element.
[[figure-schema-BinaryType]]
image::images/schema/BinaryType.png[width=100%, align="center"]

.EnumerationType element.
[[figure-schema-EnumerationType]]
image::images/schema/EnumerationType.png[width=100%, align="center"]

.ClockType element.
[[figure-schema-ClockType]]
image::images/schema/ClockType.png[width=100%, align="center"]


The type elements are referred to in variable elements to declare their type.
_[The alternative would be to define a type per variable._
_However, this would lead to a situation where, e.g., the definition of a `Torque` type would have to be repeated over and over.]_
The attributes and elements have the following meaning:

.Type element and attribute details.
[[table-type-details]]
[cols="1,5",options="header"]
|====
|Attribute or Elements
|Description

|`quantity`
|Physical quantity of the variable.
_[For example, `Angle`, or `Energy`._
_The quantity names are not standardized]_

|`unit`
|Unit of the variable defined with attribute `name` of `<UnitDefinitions><Unit>` that is used for the model equations.
_[For example, `N.m`: in this case a `Unit.name = `N.m` must be present under `<UnitDefinitions>`.]_
_[Note that for variables that are without a unit, the element should not have a `unit` attribute.]_
_[Giving an empty string as a `unit` attribute specifies a valid unit that needs to be defined among the unit definitions.]_

|[[displayUnit,`displayUnit`]] `displayUnit`
|Default display unit.
The conversion to the `unit` is defined with the element `<fmiModelDescription><UnitDefinitions>`.
If the corresponding `displayUnit` is not defined under `<UnitDefinitions><Unit><DisplayUnit>`, then `displayUnit` is ignored.
It is an error if `displayUnit` is defined as variable type element, but `unit` is not, or unit is not defined under `<UnitDefinitions><Unit>`.

|`mimeType`
|Indicates the type of data passed as a binary.
Defaults to `application/octet-stream`, which is unspecific.
Implementations can use this information to provide guidance to the user about valid/useful connections.

|`relativeQuantity`
|If this attribute is `true`, then the `offset` of `BaseUnit` and `displayUnit` must be ignored.
_[For example, 10 degree Celsius = 10 Kelvin if `relativeQuantity = true` and not 283.15 Kelvin.]_

|`min`
|Minimum value of variable (variable value latexmath:[\geq] `min`).
If not defined, the minimum is the largest negative number that can be represented on the machine.
The `min` definition is information from the FMU to the environment defining the region in which the FMU is designed to operate, see also comment after this table.

|`max`
|Maximum value of variable (variable value latexmath:[\leq] `max`).
If not defined, the maximum is the largest positive number that can be represented on the machine.
The `max` definition is information from the FMU to the environment defining the region in which the FMU is designed to operate, see also comment after this table.

|`nominal`
|Nominal value of variable.
If not defined and no other information about the nominal value is available, then `nominal = 1` is assumed. +
_[The nominal value of a variable can be, for example, used to determine the absolute tolerance for this variable as needed by numerical algorithms:_ +
`absoluteTolerance = nominal * tolerance * 0.01` +
_where `tolerance` is, for example, the relative tolerance defined in <<DefaultExperiment>>.]_

|`unbounded`
|If `true`, indicates that during time integration, the variable gets a value much larger than its nominal value `nominal`.
_[Typical examples are the monotonically increasing rotation angles of crank shafts and the longitudinal position of a vehicle along the track in long distance simulations._
_This information can, for example, be used to increase numerical stability and accuracy by setting the corresponding bound for the relative error to zero (relative tolerance = 0.0), if the corresponding variable is a continuous <<state>> variable.]_

|`Item`
|`<Item>` of an enumeration has a sequence of `name` and `value` pairs.
The values can be any integer number but must be unique within the same enumeration (in order that the mapping between `name` and `value` is bijective).
An `<Enumeration>` element must have at least one `<Item>`.

2+|Attributes for `ClockType`

|`priority`
|[[priority,`priority`]]
<<clock,`Clocks`>> that have to be activated at the same time instant are ordered according to this attribute.
Smaller values signal higher priorities.
No ordering is defined for multiple <<clock,`clocks`>> with the same <<priority>>.

This attribute is only considered in Scheduled Execution.

|`interval`
|
[[interval,`interval`]]
The attribute `interval` declares the clock type, see <<table-overview-clocks>>.

2+|The values of the following float and integer attributes refer to the unit of the <<independent>> variable.

|`intervalDecimal`
|
[[intervalDecimal,`intervalDecimal`]]
The time interval latexmath:[\mathbf{T}_{interval}] between consecutive <<clock>> ticks.

This value must be greater than 0.0.

|`shiftDecimal`
|
[[shiftDecimal,`shiftDecimal`]]
This value defines the delay of the first clock activation relative to latexmath:[\mathbf{t}_{\mathit{start}}] (<<startTime>>).

This value must be equal or greater than 0.0.

|`supportsFraction`
|
[[supportsFraction,`supportsFraction`]]
This attribute defines, if the functions `fmi3GetXXXFraction` and `fmi3SetXXXFraction` are allowed to be called for all <<time-based-clocks,time-based clocks>>.

|[[resolution, `resolution`]]`resolution`
|Instead of defining clock timing using floating point numbers, FMI allows the definition of rational numbers using <<intervalCounter,`intervalCounters`>> and <<shiftCounter,`shiftCounters`>>.
The `resolution` defines the minimal quanta clock timing can be resolved by.

This attribute is required for <<periodic-clock-ticks,time-based periodic clocks>> if <<supportsFraction,`supportsFraction = true`>> and either <<intervalCounter>> or <<shiftCounter>> is present.

|[[intervalCounter,`intervalCounter`]]`intervalCounter`
|This attribute defines (together with <<resolution>>) the interval between consecutive clock ticks:

latexmath:[\mathbf{T}_{interval} = ] `intervalCounter / resolution`.

`intervalCounter` and `resolution` have no default value.

This value must be greater than 0.

This attribute is allowed if <<supportsFraction,`supportsFraction = true`>> and is required if <<interval,interval == `constant`>> or <<interval,interval == `fixed`>>.

|[[shiftCounter,`shiftCounter`]]`shiftCounter`
|This value defines (together with <<resolution>>) the delay of the first clock activation relative to latexmath:[\mathbf{t}_{\mathit{start}}] (<<startTime>>):

latexmath:[\mathbf{T}_{shift} = ] `shiftCounter / resolution`.

This value must be greater than 0.

This attribute is allowed if <<supportsFraction,`supportsFraction = true`>> and is required if <<interval,interval == `constant`>> or <<interval,interval == `fixed`>>.

|====

==== Definition of Log Categories [[definition-of-log-categories]]

Element `<fmiModelDescription><LogCategories>` is defined as:

.LogCategories element.
[[figure-schema-LogCategories]]
image::images/schema/LogCategories.png[width=80%, align="center"]

`<LogCategories>` defines an unordered set of category strings that can be utilized to define the log output via function <<logMessage>>, see <<FMUStateSetable>>.
A tool is free to use any `normalizedString` for a category value.
The `name` attribute of `<Category>` must be unique with respect to all other elements of the `<LogCategories>` list.

<<table-standard-categories>> shows the standardized names for `<Category>`.
These names should be used if a tool supports the corresponding log category.
If a tool supports one of these log categories and wants to expose it, then an element `<Category>` with this name should be added to `<LogCategories>`.
_[To be clear, only the `<Category>` names listed under `<LogCategories>` in the XML file are known to the importer of the FMU.]_

.Standard names for `<Category>`.
[[table-standard-categories]]
[cols="1,3",options="header"]
|====
|Category
|Description

|`logEvents`
|Log all events (during initialization and simulation).

|`logSingularLinearSystems`
|Log the solution of linear systems of equations if the solution is singular (and the tool picked one solution of the infinitely many solutions).

|`logNonlinearSystems`
|Log the solution of nonlinear systems of equations.

|`logDynamicStateSelection`
|Log the dynamic selection of <<state,`states`>>.

|`logStatusWarning`
|Log messages when returning <<fmi3Warning>> status from any function.

|`logStatusDiscard`
|Log messages when returning <<fmi3Discard>> status from any function.

|`logStatusError`
|Log messages when returning <<fmi3Error>> status from any function.

|`logStatusFatal`
|Log messages when returning <<fmi3Fatal>> status from any function.

|`logAll`
|Log all messages.
|====

The optional attribute `description` shall contain a description of the respective log category.
_[Typically, this string can be shown by a tool if more details for a log category are presented.]_

_[This approach to define `<LogCategories>` has the following advantages:_

. _A simulation environment can present the possible log categories in a menu and the user can select the desired one (in the FMI 1.0 approach, there was no easy way for a user to figure out from a given FMU what log categories could be provided)._ +
_Note that since element `<LogCategories>` is optional, an FMU does not need to expose its log categories._

. _The log output is drastically reduced, because via <<fmi3SetDebugLogging>> exactly the categories are set that shall be logged and therefore the FMU only has to print the messages with the corresponding categories to the <<logMessage>> function._
_In FMI 1.0, it was necessary to provide all log output of the FMU to the <<logMessage>> and then a filter in the <<logMessage>> could select what to show to the end-user._
_The approach introduced in FMI 2.0 is therefore much more efficient.]_

==== Definition of a Default Experiment [[DefaultExperiment]]

Element `<fmiModelDescription><DefaultExperiment>` is defined as:

.DefaultExperiment element.
[[figure-schema-DefaultExperiment]]
image::images/schema/DefaultExperiment.png[width=60%, align="center"]

[[stepSize,`stepSize`]]`<DefaultExperiment>` consists of the optional default start time, stop time, relative tolerance, and step size for the first simulation run.
A tool may ignore this information.
However, it is convenient for a user that <<startTime>>, <<stopTime>>, <<tolerance>> and <<stepSize>> have already a meaningful default value for the model at hand.
Furthermore, for Co-Simulation FMUs the <<stepSize>> defines the preferred <<communicationStepSize>>.
<<startTime>>, <<stopTime>> and <<stepSize>> refer to the unit of the <<independent>> variable.

==== Definition of Model Variables [[definition-of-model-variables]]

===== Static information

The element of `<fmiModelDescription><ModelVariables>` is the central part of the model description.
It provides the static information of all exposed variables and is defined as follows.

.ModelVariables element.
[[figure-schema-ModelVariables]]
image::images/schema/ModelVariables.png[width=60%, align="center"]

The `<ModelVariables>` element consists of variable elements (see <<figure-schema-ModelVariables>>).
Variable elements can uniformly represent variables of primitive (atomic) types, like single floating point or integer variables, as well as arrays of an arbitrary (but fixed) number of dimensions.
The schema definition is present in a separate file `fmi3Variable.xsd`.

===== Array variables and structural parameters

Variable elements representing array variables must contain at least one `<Dimension>` element.
Each `<Dimension>` element specifies the size of one dimension of the array:

- If the <<start>> attribute of the `<Dimension>` element is present, it defines a constant unsigned 64-bit integer size for this dimension.
The <<variability>> of the dimension size is <<constant>> in this case.

- If the <<valueReference>> attribute of the `<Dimension>` element is present, it defines the size of this dimension to be the value of the variable with the value reference given by the <<valueReference>> attribute.
The referenced variable must be a variable of type `<UInt64>`, and must either be a constant (i.e. with <<variability>> = <<constant>>) or a <<structuralParameter,`structural parameter`>>(i.e. with <<causality>> = <<structuralParameter>>).
The <<variability>> of the dimension size is in this case the <<variability>> of the referenced variable.
A <<structuralParameter,`structural parameter`>> must be a variable of type `<UInt64>` only if it is referenced in `<Dimension>`.

These two options are mutually exclusive, i.e., for each `<Dimension>` element either a <<start>> attribute or a <<valueReference>> attribute can be supplied, but not both.
However different dimension sizes can be specified using different mechanisms and can have differing <<variability>> attributes.

All initial dimension sizes (i.e. prior to any configuration or reconfiguration) must be positive integers (i.e. not zero), so that no dimension is initially vanished.

_[This allows importing tools to ignore <<structuralParameter,`structural parameters`>> because that <<start>> value reflects the internal default setting of that <<structuralParameter,`structural parameter`>>._
_The rationale for requiring positive start values for <<structuralParameter, `structural parameters`>> is that this avoids importers having to deal with vanishing dimensions if they do not want to deal with them (or even with changing sizes at all)._
_If we allowed 0 dimension sizes for initial values, tools that do not even care about changing dimension sizes must be prepared to handle vanishing dimensions.]_

_[ Example:_
_`V` is a floating point vector parameter._
_The length of the vector depends on the <<structuralParameter,`structural parameter`>> `len`._
_The default length of the vector is 7._
_This length can be changed in <<ConfigurationMode>> because the <<variability>> of the <<structuralParameter,`structural parameter`>> `len` is <<fixed>>._
_The values of `V` can be changed whenever <<tunable>> parameters can be changed._

[source, xml]
----
include::examples/structural_parameter_example.xml[tags=structuralParameter]
----

_]_

Changes to dimension sizes are constrained by the `min`/`max` attributes of the referenced <<structuralParameter,`structural parameters`>>, which can be any non-negative integer, including zero.
Specifying a minimum size of zero on a <<structuralParameter,`structural parameter`>> allows any related dimension sizes to be changed to zero in <<ConfigurationMode>> or <<ReconfigurationMode>>, thus causing the respective array size to go to zero, which leaves the respective array variable without any active elements.

The actual dimension sizes of arrays are also constrained by the FMU platform, due to memory and addressing constraints:
Since the API functions to access variables and their values are constrained to `size_t` individual elements, platforms with addresses of less than 64-bit width will not be able to access elements beyond their addressing limits, neither will they be able to allocate enough memory or address space to represent such arrays.
For these reasons implementations must take platform-specific constraints into account when changing dimension sizes, and must be prepared to handle the inability of the FMU to adjust to the desired sizes during <<ConfigurationMode>> or <<ReconfigurationMode>>.

Changing any dimension of a variable in <<ConfigurationMode>> or <<ReconfigurationMode>> invalidates the variable's current value (including its <<start>> value).
It should be noted that changing a <<structuralParameter,`structural parameter`>> might affect dimension sizes of several variables.

===== Alias variables

[[alias,`alias`]]
A variable can have any number of `<Alias>` elements that define a variable alias.
Each variable alias has a required attribute `name` whose value must be unique among all variables and variable aliases, and an optional attribute `description`.
Variable aliases of floating point variables may additionally have a <<displayUnit>> that follows the same rules as for variables.

_[ Example:_

[source, xml]
----
include::examples/alias_example.xml[tags=VariableAliases]
----
_]_

===== Variable Attributes

The attributes of variables are shown in <<figure-schema-fmi3VariableBase>>.

.fmi3VariableBase element.
[[figure-schema-fmi3VariableBase]]
image::images/schema/fmi3VariableBase.png[width=80%, align="center"]

.fmi3VariableBase attribute details.
[[table-variableBase-attributes]]
[cols="1,5a",options="header"]
|====
|Attribute
|Description

|`name`
|The full, unique name of the variable.
Every variable is uniquely identified within an FMU instance by this name.

|`valueReference`
|
[[valueReference,`valueReference`]]
A handle of the variable to efficiently identify the variable value in the model interface and for references within the <<modelDescription.xml>>.
This handle is a secret of the tool that generated the C functions.
It is required to be unique for an FMU.
This attribute is `required`.

|`description`
|An optional description string describing the meaning of the variable.

|`causality`
|
[[causality,`causality`]]
Enumeration that defines the causality of the variable.
Allowed values of this enumeration:

[[parameter,`parameter`]]
`= parameter`: A data value that is constant during the simulation (except for <<tunable>> parameters, see there) and is provided by the environment and cannot be used in connections, except for parameter propagation in terminals as described in <<GeneralRemarkOnSignal>>.
<<variability>> must be <<fixed>> or <<tunable>>.
These parameters can be changed independently, unlike <<calculatedParameter,calculated parameters>>.
<<initial>> must be <<exact>> or not present (meaning <<exact>>).

[[calculatedParameter,`calculatedParameter`]]
`= calculatedParameter`: A data value that is constant during the simulation and is computed during initialization or when <<tunable>> <<parameter,`parameters`>> change.
<<variability>> must be <<fixed>> or <<tunable>>.
<<initial>> must be <<approx>>, <<calculated>> or not present (meaning <<calculated>>).

[[input,`input`]]
`= input`: The variable value can be provided by the importer. +
_[For example, the importer could forward the output of another FMU into this input.]_

[[output,`output`]]
`= output`: The variable value can be used by the importer. +
_[For example, this value can be forwarded to an input of another FMU.]_ +
The algebraic relationship to the <<input,`inputs`>> can be defined via the <<dependencies>> attribute of <<Output,`<fmiModelDescription><ModelStructure><Output>`>>.

[[local,`local`]]
`= local`: Local variables are: +

* continuous <<state,`states`>> and their <<ContinuousStateDerivative,`ContinuousStateDerivative`pass:[s]>>, <<ClockedState,`ClockedState`pass:[s]>>, <<EventIndicator,`EventIndicator`pass:[s]>> or <<InitialUnknown,`InitialUnknown`pass:[s]>>.
These variables are listed in the `<fmiModelDescription><ModelStructure>`. +
* [[localClock,`local clock`]] internal, intermediate variables or local clocks which can be read for debugging purposes and are not listed in the `<fmiModelDescription><ModelStructure>`.

Setting of local variables: +

* In <<InitializationMode>> and before, local variables need to be set if they do have start values or are listed as <<InitialUnknown>>.

* In super state <<Initialized>>, <<get-and-set-variable-values,`fmi3Set{VariableType}`>> must not be called on any of the local variables.
Only in Model Exchange, continuous <<state,`states`>> can be set with <<fmi3SetContinuousStates>>.
Local variable values must not be used as input to another model or FMU.

[[independent,`independent`]]
`= independent`: The independent variable (usually `time` _[but could also be, for example, `angle`]_).
All variables are a function of this <<independent>> variable.
<<variability>> must be <<continuous>>.
Exactly one variable of an FMU must be defined as <<independent>>.
If the unit for the independent variable is not defined, it is implicitly`unit = s`.
If one variable is defined as <<independent>>, it must be defined with a floating point type without a <<start>> attribute.
It is not allowed to call function <<get-and-set-variable-values,`fmi3Set{VariableType}`>> on an <<independent>> variable.
Instead, its value is initialized with <<fmi3EnterInitializationMode>> and after initialization set by <<fmi3SetTime>> for Model Exchange and by arguments <<currentCommunicationPoint>> and <<communicationStepSize>> of <<fmi3DoStep>> for Co-Simulation FMUs.
_[The actual value can be inquired with <<get-and-set-variable-values,`fmi3Get{VariableType}`>>.]_

[[structuralParameter,`structuralParameter`]]
`= structuralParameter`: The variable value can only be changed in <<ConfigurationMode>> or <<ReconfigurationMode>>.
The <<variability>> attribute must be <<fixed>> or <<tunable>>.
The <<initial>> attribute must be <<exact>> or not present (meaning <<exact>>).
The <<start>> attribute is mandatory.
A <<structuralParameter,`structural parameter`>> must not have a `<Dimension>` element.
A <<structuralParameter,`structural parameter`>> may be referenced in `<Dimension>` elements.
If a <<structuralParameter,`structural parameters`>> is referenced in `<Dimension>` elements, it must be of type `<UInt64>` and its <<start>> attribute must be larger than 0.
The `min` attribute might still be 0.

The default of <<causality>> is <<local>>. +
A continuous-time <<state>> or an event indicator must have <<causality>> = <<local>> or <<output>>, see also <<ModelStructure>>.

_[<<causality>> = <<calculatedParameter>> and <<causality>> = <<local>> with <<variability>> = <<fixed>> or <<tunable>> are similar._
_The difference is that a <<calculatedParameter>> can be used in another model or FMU, whereas a <<local>> variable cannot._
_For example, when importing an FMU in a Modelica environment, a <<calculatedParameter>> should be imported in a `public` section as `final parameter`, whereas a <<local>> variable should be imported in a `protected` section of the model.]_

|`variability`
|
[[variability,`variability`]]
Enumeration that defines the time dependency of the variable, in other words, it defines the time instants when a variable can change its value.
_[The purpose of this attribute is to define when a result value needs to be inquired and to be stored._
_For example, <<discrete>> variables change their values only at event instants (ME) or at a communication point (CS and SE) and it is therefore only necessary to inquire them with <<get-and-set-variable-values,`fmi3Get{VariableType}`>> and store them at event times.]_
Allowed values of this enumeration:

[[constant,`constant`]]
`= constant`: The value of the variable never changes.

[[fixed,`fixed`]]
`= fixed`: The value of the variable is fixed after initialization, in other words, after <<fmi3ExitInitializationMode>> was called the variable value does not change anymore.

[[tunable,`tunable`]]
`= tunable`: The value of the variable is constant between events (ME) and between communication points (CS and SE) due to changing variables with <<causality>> = <<parameter>> and <<variability>> = <<tunable>>.
Whenever a <<parameter>> with <<variability>> = <<tunable>> changes, an event is triggered externally (ME or CS if events are supported), or the change is performed at the next communication point (CS and SE) and the variables with <<variability>> = <<tunable>> and <<causality>> = <<calculatedParameter>> or <<output>> must be newly computed.
_[<<tunable>> <<input,inputs>> are not allowed, see <<table-allowed-variability-causality-combinations>>.]_

[[discrete,`discrete`]]
`= discrete`: +
Model Exchange: The value of the variable is constant between external and internal events (= <<time event,`time`>>, <<state event,`state`>>, <<step event,`step events`>> defined implicitly in the FMU). +
Co-Simulation: By convention, the variable is from a real sampled data system and its value is only changed at communication points (including event handling).
During <<intermediateUpdate>>, <<discrete>> variables are not allowed to change.
_[If the simulation algorithm notices a change in a discrete variable during <<intermediateUpdate>>, the simulation algorithm will delay the change, raise an event with <<earlyReturnRequested,`earlyReturnRequested == fmi3True`>> and during the communication point it can change the <<discrete>> variable, followed by event handling.]_

[[continuous,`continuous`]]
`= continuous`: Only a variable of `type == fmi3GetFloat32` or `type == fmi3GetFloat64` can be <<continuous>>. +
Model Exchange: No restrictions on value changes (see <<smoothness>>).

[[clock,`clock`]]
`= clock`: Only a variable of type `<Clock>` can have this variability.

The default is <<continuous>> for variables of type `<Float32>` and `<Float64>`, and <<discrete>> for all other types.

_[Note that the information about continuous <<state,`states`>> is defined with elements <<ContinuousStateDerivative>> in `<ModelStructure>`.]_

|`initial`
|
[[initial,`initial`]]
Enumeration that defines how the variable is initialized, i.e. if a <<get-and-set-variable-values,`fmi3Set{VariableType}`>> is allowed and how the FMU internally treats this value in <<Instantiated>> and <<InitializationMode>>.

For the variable with <<causality>> = <<independent>>, the attribute <<initial>> must not be provided, because its start value is set with the <<startTime>> parameter of <<fmi3EnterInitializationMode>>.

The attribute <<initial>> for other variables can have the following values and meanings:
[[exact,`exact`]]
`= exact`: The variable is initialized with the <<start>> value (provided under the variable type element).

[[approx,`approx`]]
`= approx`: The <<start>> value provides an approximation that may be modified during initialization, e.g., if the FMU is part of an algebraic loop where the variable might be an iteration variable and <<start>> value is taken as initial value for an iterative solution process.

[[calculated,`calculated`]]
`= calculated`: The variable is calculated from other variables during initialization.
It is not allowed to provide a <<start>> value.

If <<initial>> is not present, it is defined by <<table-definition-initial>> based on <<causality>> and <<variability>>.
If <<initial>> = <<exact>> or <<approx>>, or <<causality>> = <<input>>, a <<start>> value must be provided.
If <<initial>> = <<calculated>>, or <<causality>> = <<independent>>, it is not allowed to provide a <<start>> value.

_[The environment decides when to use the <<start>> value of a variable with <<causality>> = <<input>>.
Examples: (a) automatic tests of FMUs are performed, and the FMU is tested by providing the <<start>> value as <<constant>> <<input>>.
(b) For a Model Exchange FMU, the FMU might be part of an algebraic loop.
If the <<input>> variable is iteration variable of this algebraic loop, then initialization starts with its <<start>> value.]_

If <<causality>> = <<input>> and <<variability>> = <<clock>>, that is, the variable is an <<inputClock>>, it is required to provide a <<start>> value for describing the expected initial condition of the <<inputClock>> for that FMU.
If an <<inputClock>> has `fmi3True` as a <<start>> value, the environment should activate the <<clock>> the first time it enters <<EventMode>>.
The environment can nevertheless choose different <<start>> values if it is not possible to fulfill the conditions in a simulation setup.

If <<causality>> = <<output>> the <<initial>> attribute value is set to <<calculated>> and no <<start>> value is provided.

If <<get-and-set-variable-values,`fmi3Set{VariableType}`>> is not called on a variable with <<causality>> = <<input>>, then the FMU must use the <<start>> value as value of this <<input>>.

|`canHandleMultipleSetPerTimeInstant`
|
[[canHandleMultipleSetPerTimeInstant,`canHandleMultipleSetPerTimeInstant`]]
Only for variables with <<variability>> = <<input>>. +
The default value is `true`.
If `canHandleMultipleSetPerTimeInstant = false`, then only one <<get-and-set-variable-values,`fmi3Set{VariableType}`>> call is allowed for this variable per super-dense time instant in <<EventMode>>.
_[This flag can be set to `false` for variables where discrete-time states are directly updated when assigned (_ latexmath:[\mathbf{x}_\mathit{d} := f(\mathbf{x}_\mathit{d},\mathbf{u}_\mathit{c+d})] _instead of_ latexmath:[\mathbf{x}_\mathit{d} := f({}^\bullet\mathbf{x}_\mathit{d},\mathbf{u}_\mathit{c+d})] _)._
_If an <<output>> depends on this <<input>> and on discrete-time states, then an algebraic loop could be formed with such an <<input>>._
_Such loops cannot be solved iteratively because of the limitation on <<get-and-set-variable-values,`fmi3Set{VariableType}`>>._
_Therefore, such an <<input>> should not appear in an algebraic loop.]_

|`intermediateUpdate`
|
[[intermediateUpdate,`intermediateUpdate`]]
If this boolean attribute is `true`, the variable can be accessed in <<IntermediateUpdateMode>>.
Variables with <<causality>> <<parameter>> must not be marked with <<intermediateUpdate,`intermediateUpdate = true`>>.

This attribute is ignored in Model Exchange.
The default value of this attribute is `false`.

|`previous`
|
[[previous,`previous`]]
If present, this variable is a <<ClockedState>> and this attribute is a value reference to the variable with the previous value.
Only clocked variables (they are listed in at least one of the <<clockedVariables>> lists) may have the <<previous>> attribute.
Only variables with <<variability,`variability == discrete`>> may have a previous value.

_[For example, if `previous == 3` for variable `8`, then variable `3` is the previous value of variable `8`. See also <<fmi3UpdateDiscreteStates>>._
_Note: This is reverse compared to the <<derivative>> attribute.]_

|====

If <<initial>> is not present, its value is defined by <<table-definition-initial>> based on the values of <<causality>> and <<variability>> (default [.underline]#underlined#):

.Definition of <<initial>>.
[#table-definition-initial]
[cols="1,1,1,1,1,1,1,1,1"]
|====
2.2+|
7+^|<<causality>>
^|<<structuralParameter,`structural Parameter`>>
^|<<parameter>>
^|<<calculatedParameter,`calculated Parameter`>>
^|<<input>>
^|<<output>>
^|<<local>>
^|<<independent>>

.6+^|<<variability>>
^|<<constant>> data
^|--
^|--
^|--
^|--
^|[.underline]#exact#
^|[.underline]#exact#
^|--

^|<<fixed>> data
^|[.underline]#exact#
^|[.underline]#exact#
^|[.underline]#calculated#, approx
^|--
^|--
^|[.underline]#calculated#, approx
^|--

^|<<tunable>> data
^|[.underline]#exact#
^|[.underline]#exact#
^|[.underline]#calculated#, approx
^|--
^|--
^|[.underline]#calculated#, approx
^|--

^|<<discrete>> variables
^|--
^|--
^|--
^|[.underline]#exact#
^|[.underline]#calculated#, exact, approx
^|[.underline]#calculated#, exact, approx
^|--

^|<<continuous>> variables
^|--
^|--
^|--
^|[.underline]#exact#
^|[.underline]#calculated#, exact, approx
^|[.underline]#calculated#, exact, approx
^|--

^|<<clock,`clocks`>>
^|--
^|--
^|--
^|[.underline]#exact#
^|[.underline]#calculated#
^|[.underline]#calculated#
^|--
|====

_[Note: For local and output variables and <<initial>> = <<exact>>, then the variable is explicitly set in <<InitializationMode>>._
_The value of the variable is either the <<start>> value stored in a variable element `<XXX start=YYY/>` or the value set with <<get-and-set-variable-values,`fmi3Set{VariableType}`>> during <<InitializationMode>>.]_

<<table-allowed-variability-causality-combinations>> shows the combinations of <<variability>>/<<causality>> settings that are allowed.

.Allowed combinations of <<variability>>/<<causality>>.
[[table-allowed-variability-causality-combinations]]
[cols="1,1,1,1,1,1,1,1,1"]
|====
2.2+|
7+^|<<causality>>
^|<<structuralParameter,`structural Parameter`>>
^|<<parameter>>
^|<<calculatedParameter,`calculated Parameter`>>
^|<<input>>
^|<<output>>
^|<<local>>
^|<<independent>>

.6+^|<<variability>>
^|<<constant>> data
^|-- (a)
^|-- (a)
^|-- (a)
^|-- (a)
^|(7)
^|(10)
^|-- (c)

^|<<fixed>> data
^|(16)
^|(1)
^|(3)
^|-- (d)
^|-- (e)
^|(11)
^|-- (c)

^|<<tunable>> data
^|(17)
^|(2)
^|(4)
^|-- (d)
^|-- (e)
^|(12)
^|-- (c)

^|<<discrete>> variables
^|-- (b)
^|-- (b)
^|-- (b)
^|(5)
^|(8)
^|(13)
^|-- (c)

^|<<continuous>> variables
^|-- (b)
^|-- (b)
^|-- (b)
^|(6)
^|(9)
^|(14)
^|(15)

^|<<clock,`clocks`>>
^|--
^|--
^|--
^|(18)
^|(18)
^|(18)
^|--
|====

_[Discussion of the combinations that are not allowed:_

.Combinations of variability and causality that are not allowed and why.
[[table-Combinations-not-allowed]]
[cols="1,10", options="header"]
|====
|
|_Explanation why this combination is not allowed_

^|_(a)_
|_The combinations <<constant>> / <<structuralParameter>>, <<constant>> / <<parameter>>, <<constant>> / <<calculatedParameter>> and <<constant>> / <<input>> do not make sense, since <<parameter,`parameters`>> and <<input,`inputs`>> are set from the environment, whereas <<constant>> variables have an unchangeable value._

^|_(b)_
|_The combinations <<discrete>> / <<structuralParameter>>, <<discrete>> / <<parameter>>, <<discrete>> / <<calculatedParameter>> , <<continuous>> / <<structuralParameter>>, <<continuous>> / <<parameter>> and <<continuous>> / <<calculatedParameter>> do not make sense, since <<causality>> = <<structuralParameter>>, <<causality>> = <<parameter>> and <<causality>> = <<calculatedParameter>> define variables that do not depend on time, whereas <<discrete>> and <<continuous>> define variables where the values can change during simulation._

^|_(c)_
|_For an <<independent>> variable only <<variability>> = <<continuous>> makes sense._

^|_(d)_
|_A <<fixed>> or <<tunable>> <<input>> has exactly the same properties as a <<fixed>> or <<tunable>> <<parameter>>._
_For simplicity, only <<fixed>> and <<tunable>> <<parameter,`parameters`>> shall be defined._

^|_(e)_
|_A <<fixed>> or <<tunable>> <<output>> has exactly the same properties as a <<fixed>> or <<tunable>> <<calculatedParameter>>._
_For simplicity, only <<fixed>> and <<tunable>> <<calculatedParameter,`calculatedParameters`>> shall be defined._
|====

_Discussion of the combinations that are allowed_:

.Combinations of variability and causality that are allowed and why.
[[table-Combinations-allowed]]
[cols="1,3,8", options="header"]
|====
|
|_Setting_
|_Example_

>|_(1)_
|_<<fixed>> <<parameter>>_
|_Non-<<tunable>> <<parameter>>_

>|_(2)_
|_<<tunable>> <<parameter>>_
|_<<tunable,`Tunable`>> <<parameter>> (changing such a <<parameter>> triggers event handling (ME) or takes effect at the next communication point (CS and SE), and <<tunable>> <<calculatedParameter>>/<<output>>/<<local>> variables might change their values)._

>|_(3)_
|_<<fixed>> <<calculatedParameter>>_
|_Non-<<tunable>> <<calculatedParameter>> (variable that is computed directly or indirectly from constants or <<parameter,`parameters`>>)._

>|_(4)_
|_<<tunable>> <<calculatedParameter>>_
|_<<tunable,`Tunable`>> <<calculatedParameter>> (changing a <<parameter>> triggers event handling (ME) or takes effect at the next communication point (CS and SE), and <<tunable>> <<calculatedParameter>> and <<tunable>> <<local>> variables might change their values)._

>|_(5)_
|_<<discrete>> <<input>>_
|_<<discrete,`Discrete`>> <<input>> variable from another model._

>|_(6)_
|_<<continuous>> <<input>>_
|_<<continuous,`Continuous`>> <<input>> variable from another model._

>|_(7)_
|_<<constant>> <<output>>_
|_Variable where the value never changes and that can be used in another model._

>|_(8)_
|_<<discrete>> <<output>>_
|_<<discrete,`Discrete`>> variable that is computed in the FMU._
_Can be used in another model._

>|_(9)_
|_<<continuous>> <<output>>_
|_<<continuous,`Continuous`>> variable that is computed in the FMU and can be used in another model._

>|_(10)_
|_<<constant>> <<local>>_
|_Variable where the value never changes._
_Cannot be used in another model._

>|_(11)_
|_<<fixed>> <<local>>_
|_Local variable that depends on <<fixed>> <<parameter,`parameters`>> only and is computed in the FMU._
_Cannot be used in another model._
_After initialization, the value of this <<local>> variable cannot change._

>|_(12)_
|_<<tunable>> <<local>>_
|_Local variable that depends on <<tunable>> <<parameter,`parameters`>> only and is computed in the FMU._
_Cannot be used in another model._
_The value of this <<local>> variable can only change during initialization and at event instants, provided a <<tunable>> <<parameter>> was changed._

>|_(13)_
|_<<discrete>> <<local>>_
|_<<discrete,`Discrete`>> variable that is computed in the FMU and cannot be used in another model._

>|_(14)_
|_<<continuous>> <<local>>_
|_<<continuous,`Continuous`>> variable that is computed in the FMU and cannot be used in another model._

>|_(15)_
|_<<continuous>> <<independent>>_
|_All variables are a function of the continuous-time variable marked as <<independent>>._
_Usually, this is `time`._

>|_(16)_
|_<<fixed>> <<structuralParameter>>_
|_<<parameter,`Parameter`>> used in  `<Dimension>` element;  can be changed before initialization in <<ConfigurationMode>>._

>|_(17)_
|_<<tunable>> <<structuralParameter>>_
|_<<parameter,`Parameter`>> used in  `<Dimension>` element;  can be changed before initialization in <<ConfigurationMode>> and in <<ReconfigurationMode>>._

>|_(18)_
|_<<clock>>_
|_Variable that defines a <<clock>>._

|====

_How to treat <<tunable>> variables:_

_A <<parameter>> p is a variable that does not change its value during simulation, in other words, dp/dt = 0._
_If the <<parameter>> p is changing, then Dirac impulses are introduced since dp/dt of a discontinuous <<constant>> variable `p` is a Dirac impulse._
_Even if this Dirac impulse would be modeled correctly by the modeling environment, it would introduce unwanted `vibrations`._
_Furthermore, in many cases the model equations are derived under the assumption of a <<constant>> value (like mass or capacity), and the model equations would be different if `p` would be time varying._

_FMI for Model Exchange:_ +
_Therefore, "tuning a (structural) <<parameter>>" during simulation does not mean to "change the parameter online" during simulation._
_Instead, this is a short hand notation for:_

. _Stop the simulation at an event instant (usually, a <<step event>>, in other words, after a successful integration step)._

. _Change the values of the <<tunable>> (structural) <<parameter,`parameters`>>._
_For <<tunable>> <<structuralParameter,`structural parameters`>>, the <<ReconfigurationMode>> must be entered before and left afterwards._

. _Compute all <<parameter,`parameters`>> (and sizes of variables, <<state,`states`>>, <<derivative,`derivatives`>>, event indicators, ...) that depend on the <<tunable>> (structural) <<parameter,`parameters`>>._

. _Newly start the simulation using as initial values previously stored values and the new values of the <<parameter,`parameters`>>._

_Basically this means that a new simulation run is started from the previous FMU state with changed <<parameter>> values._
_With this interpretation, changing <<parameter,`parameters`>> online is "clean", as long as these changes appear at an event instant._

_FMI for Co-Simulation:_
_Changing of <<tunable>> <<parameter,`parameters`>> is allowed before an <<fmi3DoStep>> call (so, whenever an <<input>> can be set with <<get-and-set-variable-values,`fmi3Set{VariableType}`>>) and before <<fmi3ExitInitializationMode>> is called (that is before and during <<InitializationMode>>)._
_The FMU internally carries out event handling if necessary.]_

_FMI for Scheduled Execution:_
_Changing of <<tunable>> <<parameter,`parameters`>> is allowed before an <<fmi3ActivateModelPartition>> call (so, whenever an <<input>> can be set with <<get-and-set-variable-values,`fmi3Set{VariableType}`>>) and before <<fmi3ExitInitializationMode>> is called (that is before and during <<InitializationMode>>)._

===== Type specific properties

Type specific properties are defined in the required choice element, where exactly one float, integer or enumeration must be present in the XML file:
<<figure-schema-Float64>>, <<figure-schema-Int32>>, <<figure-schema-Boolean>>, <<figure-schema-Binary>>, <<figure-schema-Enumeration>> and <<figure-schema-Clock>>, are representative examples.

.Float64 element.
[[figure-schema-Float64]]
image::images/schema/Float64.png[width=70%, align="center"]

.Int32 element.
[[figure-schema-Int32]]
image::images/schema/Int32.png[width=70%, align="center"]

.Boolean element.
[[figure-schema-Boolean]]
image::images/schema/Boolean.png[width=70%, align="center"]

.Binary element.
[[figure-schema-Binary]]
image::images/schema/Binary.png[width=70%, align="center"]

.Enumeration element.
[[figure-schema-Enumeration]]
image::images/schema/Enumeration.png[width=70%, align="center"]

.Clock element.
[[figure-schema-Clock]]
image::images/schema/Clock.png[width=70%, align="center"]

The attributes are defined in <<definition-of-types>> (`<TypeDefinitions>`), except:

.TypeDefinition attribute details.
[[table-type-attributes]]
[cols="1,7a", options="header"]
|====
|Attribute
|Description

|`declaredType`
|If present, name of type defined with `<TypeDefinitions><TypeDefinition>`.
The value defined in the corresponding `<TypeDefinition>` (see <<definition-of-types>>) is used as default.
_[For example, if `min` is present both in variable type element of `<TypeDefinition>` and in the concrete variable type element of the variable, then the `min` of the variable is actually used.]_
For `<Enumeration>` the attribute `declaredType` is required because the `<Enumeration>` items are defined in `<TypeDefinitions><TypeDefinition>`.
For all other types, this attribute is optional.

|`start`
|
[[start,`start`]]
Initial or guess value of variable.
This value is also stored in the C functions.
_[Therefore, calling_ <<get-and-set-variable-values,`fmi3Set{VariableType}`>> _to set <<start>> values is only necessary, if a different value as stored in the XML file is desired._
_It is not allowed to change the start values in the <<modelDescription.xml>> file of an FMU, as this would break the consistency with the hard-coded start values in the C-Code._
_This could lead to unpredictable behavior of the FMU in different importing tools, as it is not mandatory to call <<get-and-set-variable-values,`fmi3Set{VariableType}`>> to set start values during initialization._
_Instead it is recommended to use the SSP Standard (https://ssp-standard.org/) to handle modified parameters of FMUs or different parameter sets.]_

The <<start>> is either a single value or a list of values.
The serialization of a multi-dimensional array variable is described in <<serialization-of_variables>>.
If only a single value is given for a multi-dimensional array, all values of the multi-dimensional array are equal to this value.

For variables of type `<String>`, the start values are not given as a list in the `start` attribute but as a sequence of `<Start>` elements with a `value` attribute.

_[ Example:_
_Start values of string array variable_
[source, xml]
----
include::examples/string_vector_example.xml[tags=string_start_values]
----
_]_


The interpretation of <<start>> is defined by variable attribute <<initial>>.
A different <<start>> value can be provided with an <<get-and-set-variable-values,`fmi3Set{VariableType}`>> function before <<fmi3ExitInitializationMode>> is called (but not for variables with <<variability>> = <<constant>>).

_[The standard approach is to set the <<start>> value before <<fmi3EnterInitializationMode>>._
_However, if the initialization shall be modified in the calling environment (for example, changing from initialization of states to steady-state initialization), it is also possible to use the <<start>> value as iteration variable of an algebraic loop: using an additional condition in the environment, such as_ latexmath:[{\dot{x} = 0}] _, the actual <<start>> value is determined.]_

If <<initial>> = <<exact>> or <<approx>> or <<causality>> = <<input>>, a <<start>> value must be provided.

If <<initial>> = <<calculated>> or <<causality>> = <<independent>>, it is not allowed to provide a <<start>> value.

Variables with <<causality>> = <<parameter>> or <<input>>, as well as variables with <<variability>> = <<constant>>, must have a <<start>> value.

- If <<causality>> = <<parameter>>, the <<start>> value is the value of it.

- If <<causality>> = <<input>>, the <<start>> value is used by the model as value of the <<input>>, if the <<input>> is not set by the environment.

- If <<variability>> = <<constant>>, the <<start>> value is the value of the constant.

- If <<causality>> = <<output>> or <<local>>, then the <<start>> value is either an <<initial>> or a `guess` value, depending on the setting of attribute <<initial>>.

|`derivative`
|
[[derivative,`derivative`]]
If present, this variable is the derivative of variable with value reference `derivative`.
_[For example, if there are 10 variables and `derivative = 3` for variable 8, then variable 8 is the derivative of variable 3 with respect to the <<independent>> variable (usually time)._
_This information might be especially used if an <<input>> or an <<output>> is the derivative of another <<input>> or <<output>>, or to define the <<state,`states`>>.]_

The <<state>> <<derivative,`derivatives`>> of an FMU are listed as elements <<ContinuousStateDerivative>> in `<ModelStructure>`.
All variables listed in this element must have attribute `derivative` (in order that the continuous-time <<state,`states`>> are uniquely defined).

|`reinit`
|[[reinit,`reinit`]]
Only for Model Exchange (if only a Co-Simulation FMU, this attribute must not be present.
If both Model Exchange and a Co-Simulation FMU, this attribute is ignored for co-simulation): +
Can only be present for a continuous-time <<state>>. +
If `true`, <<state>> can be reinitialized at an event by the FMU. +
If `false`, <<state>> will not be reinitialized at an event by the FMU.

|`min / max`
|[[min-max,`min / max`]]
The `min / max` definitions are information from the FMU to the environment defining the region in which the FMU is designed to operate (see <<min-max-violations>>). +
_[If, for example, an `<Enumeration>` is defined with `name1 = -4`, `name2 = 1`, `name3 = 5`, `name4 = 11` and `min = -2`, `max = 5`, then only `name2` and `name3` are allowed.]_
|====

====== Variable Naming Conventions [[namingSection]]

With attribute <<variableNamingConvention>> in `<fmiModelDescription>`, the convention is defined how the variable names have been constructed.
If this information is known, the environment may be able to represent the names in a better way (for example, as a tree and not as a linear list).

In the following definitions, the http://en.wikipedia.org/wiki/Extended_BNF[EBNF] is used:

----
=   production rule
[ ] optional
{ } repeat zero or more times
|   or
----

The names must be unique, non-empty strings. +
_[It is recommended that the names are visually clearly different from each other; but it is not required.]_

The following conventions for scalar names are defined:

*<<variableNamingConvention,`variableNamingConvention = flat`>>*

----
name = Unicode-char { Unicode-char } // identical to xs:normalizedString
Unicode-char = any Unicode character without carriage return (#xD),
line feed (#xA) nor tab (#x9)
----

*<<variableNamingConvention,`variableNamingConvention = structured`>>*

Structured names are hierarchical using "." as a separator between hierarchies.
A name consists of "pass:[_]", letters and digits or may consist of any characters enclosed in single apostrophes.
A name may identify an array element on every hierarchical level using "[...]" to identify the respective array index.
If an array is a leaf node of the variable hierarchy then the array can also be represented as a single variable of type array.
A <<derivative>> of a variable is defined with `der(name)` for the first time derivative and `der(name,N)` for the N-th derivative.
Examples:

----
vehicle.engine.speed
resistor12.u
v_min
robot.axis.'motor #234'
der(pipe[3,4].T[14],2) // second time derivative of pipe[3,4].T[14]
----

The precise syntax is:

----
name            = identifier | "der(" identifier ["," unsignedInteger ] ")"
identifier      = B-name [ arrayIndices ] {"." B-name [ arrayIndices ] }
B-name          = nondigit { digit | nondigit } | Q-name
nondigit        = "pass:[_]" | letters "a" to "z" | letters "A" to "Z"
digit           = "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"
Q-name          = "'" ( Q-char | escape ) { Q-char | escape } "'"
Q-char          = nondigit | digit | "!" | "#" | "$" | "%" | "&" | "(" | ")" |
                                     "*" | "+" | "," | "-" | "." | "/" | ":" |
                                     ";" | "<" | ">" | "=" | "?" | "@" | "[" |
                                     "]" | "^" | "{" | "}" | "|" | "~" | " "
escape          = "\'" | "\"" | "\?" | "\\" | "\a" | "\b" |
                  "\f" | "\n" | "\r" | "\t" | "\v"
arrayIndices    = "[" unsignedInteger {"," unsignedInteger} "]"
unsignedInteger = digit { digit }
----

_[This definition is identical to the syntax of an identifier in Modelica version 3.2.]_

The tree of names is mapped to an ordered list of variable names in http://en.wikipedia.org/wiki/Depth-first_search[depth-first] order.
Example:

----
vehicle
  transmission
    ratio
    outputSpeed
  engine
    inputSpeed
    temperature
----

is mapped to the following list of variable names:

----
vehicle.transmission.ratio
vehicle.transmission.outputSpeed
vehicle.engine.inputSpeed
vehicle.engine.temperature
----

All flattened array elements are given in a consecutive sequence of variables.
Elements of multi-dimensional arrays are ordered according to "row major" order that is elements of the last index are given in sequence.

_[For example, the vector `centerOfMass` in body `arm1` is mapped to the following variables:_

----
robot.arm1.centerOfMass[1]
robot.arm1.centerOfMass[2]
robot.arm1.centerOfMass[3]
----

_[For example, a controller might receive 3 rpm sensors mapped to the following variables:_

----
transmission.rpms[0]
transmission.rpms[1]
transmission.rpms[2]
----

_For example, a table `T[4,3,2]` (first dimension 4 entries, second dimension 3 entries, third dimension 2 entries) is mapped to the following variables:_

----
T[1,1,1]
T[1,1,2]
T[1,2,1]
T[1,2,2]
T[1,3,1]
T[1,3,2]
T[2,1,1]
T[2,1,2]
T[2,3,1]
...
----
_]_

It might be that not all elements of an array are present.
If they are present, they are given in consecutive order in the XML file.

The <<variableNamingConvention>> `structured` does not define if arrays are 0-based or 1-based.

_[FMI 3.0 introduces arrays of variables to improve handling of arrays.]_

==== Definition of the Model Structure [[ModelStructure]]

The structure of the model is defined in element `<fmiModelDescription><ModelStructure>`.
It defines the <<model-dependencies,dependencies>> between variables.

The required part of the model structure defines an ordering of the <<output,`outputs`>>, the (exposed) <<derivative,`derivatives`>>, the event indicators, and the unknowns that are available during Initialization.
A Model Exchange FMU must expose all <<derivative,`derivatives`>> of its continuous-time <<state,`states`>> in <<ContinuousStateDerivative>> in `<ModelStructure>` elements and must expose all event indicators in <<EventIndicator>> elements.

The optional part of the model structure defines in which way <<derivative,`derivatives`>>, <<output,`outputs`>>, and initial unknowns depend on <<input,`inputs`>> and/or <<parameter,`parameters`>>, and continuous-time <<state,`states`>>, at the current super-dense time instant (ME) or at the current communication point (CS and SE).
The listed <<dependencies>> declare the dependencies between whole (multi-dimensional-)variables and not individual elements of the variables.
_[Dependencies of individual array elements can be retrieved during runtime using <<fmi3GetVariableDependencies>>.]_

<<figure-schema-ModelStructure>> shows the definition of `<ModelStructure>`.

.ModelStructure element.
[#figure-schema-ModelStructure]
image::images/schema/ModelStructure.png[width=90%]

Note that attribute <<dependenciesKind>> for element <<InitialUnknown>> has less enumeration values as <<dependenciesKind>> in the other lists, as detailed in <<table-model-structure-elements>>.

`<ModelStructure>` consists of the elements detailed in <<table-model-structure-elements>> (see also <<figure-schema-ModelStructure>>; the symbols of the mathematical equations describing the dependency are defined in <<concepts-model-exchange>>):

.ModelStructure elements.
[#table-model-structure-elements]
[cols="1,5",options="header"]
|====
|Element
|Description

|`Output`
|[[Output,`<Output>`]]
Ordered list of all outputs, in other words, a list of value references where every corresponding variable must have <<causality>> = <<output>> (and every variable with <<causality>> = <<output>> must be listed here).
_[Note that all <<output>> variables are listed here, especially <<discrete>> and <<continuous>> <<output,`outputs`>>._
_The ordering of the variables in this list is defined by the exporting tool._
_Usually, it is best to order according to the declaration order in the source model, since then the <<Output>> list does not change if the declaration order of <<output,`outputs`>> in the source model is not changed._
_This is for example, important for linearization, in order that the interpretation of the output vector does not change for a re-exported FMU.]_
Attribute <<dependencies>> defines the dependencies of the <<output,`outputs`>> from the knowns at the current super-dense time instant in Event and in <<ContinuousTimeMode>> (ME) and at the current communication point (CS and SE).
Attribute <<dependencies>> for output clocks (variables with <<causality>> = <<output>> and <<variability>> = <<clock>>) lists all known variables (including input clocks) that contribute to trigger a clock tick for that output clock.
Beside the knowns, the <<output,`outputs`>> also depend on "frozen" variables (= variables which cannot be changed in the current mode) but these "frozen" variables are not listed as <<dependencies>>.
The functional dependency is defined as (dependencies of variables that are fixed in Event and <<ContinuousTimeMode>> and at communication points are not shown): +
latexmath:[{(\mathbf{y}_c, \mathbf{y}_d) := \mathbf{f}_{\mathit{output}}(\mathbf{x}_c, \mathbf{u}_c, \mathbf{u}_d, t, \mathbf{p}_{\mathit{tune}})}]

|`ContinuousStateDerivative`
|[[ContinuousStateDerivative,`<ContinuousStateDerivative>`]]
Ordered list of all state derivatives, in other words, a list of value references where every corresponding variable must be a state derivative.
_[Note that only <<continuous>> floating point variables are listed here._
_If a <<state>> or a <<derivative>> of a <<state>> shall not be exposed from the FMU, or if states are not statically associated with a variable (due to <<dynamic-state-selection,dynamic state selection>>), then dummy variables have to be introduced, for example, `x[4]`, or `xDynamicStateSet2[5]`._
_The ordering of the variables in this list is defined by the exporting tool._
_Usually, it is best to order according to the declaration order of the <<state,`states`>> in the source model, since then the <<ContinuousStateDerivative>> list does not change if the declaration order of states in the source model is not changed._
_This is for example, important for linearization, in order that the interpretation of the state vector does not change for a re-exported FMU.]_

The corresponding continuous-time <<state,`states`>> are defined by attribute <<derivative>> of the corresponding variable state derivative element.
_[Note that higher order derivatives must be mapped to first order derivatives but the mapping definition can be preserved due to attribute <<derivative>>._
_Example: if_ latexmath:[{\frac{\text{ds}}{\text{dt}} = v,\ \frac{\text{dv}}{\text{dt}} =f(..)}] _,then_ latexmath:[{\left\{ v,\ \frac{\text{dv}}{\text{dt}} \right\}}] _is the vector of state derivatives and attribute <<derivative>> of_ latexmath:[{v}] _references_ latexmath:[{s}] _, and attribute <<derivative>> of_ latexmath:[{\frac{\text{dv}}{\text{dt}}}] _references_ latexmath:[{v}] _.]_ +
For Co-Simulation, elements <<ContinuousStateDerivative>> are ignored if capability flag <<providesDirectionalDerivatives>> has a value of `false`, in other words, it cannot be computed.
_[This is the default._
_If an FMU supports more than Model Exchange , then the <<ContinuousStateDerivative>> elements might be present, since it is needed for Model Exchange._
_If the above flag is set to `false` for the Co-Simulation cases, then the <<ContinuousStateDerivative>> elements are ignored for Co-Simulation._
_If "inline integration" is used for a co-simulation FMU, then the model still has continuous-time <<state,`states`>> and just a special solver is used (internally the implementation results in a discrete-time system, but from the outside, it is still a continuous-time system).]_ +
Attribute <<dependencies>> defines the dependencies of the state derivatives from the knowns at the current super-dense time instant in Event and in <<ContinuousTimeMode>> (ME) and at the current communication point (CS and SE).
Beside the knowns the derivatives also depend on the "frozen" variables (= variables which cannot be changed in the current mode) but these "frozen" variables are not listed as <<dependencies>>.
The functional dependency is defined as (dependencies of variables that are fixed in Event and <<ContinuousTimeMode>> and at communication points are not shown): +
latexmath:[{\dot{\mathbf{x}_c} := \mathbf{f}_{\mathit{der}}(\mathbf{x}_c, \mathbf{u}_c, \mathbf{u}_d, t, \mathbf{p}_{\mathit{tune}})}]

|`ClockedState`
|
[[ClockedState,`<ClockedState>`]]
A <<ClockedState>> is part of the discrete state of a model partition and represented by a <<ClockElement,clocked>> variable.
To which clock or clocks it belongs is described in <<ClockElement>>.
Each <<ClockedState>> must have the attribute <<previous>> to represent the previous value of this <<ClockedState>>.
All <<ClockedState,clocked states>> must have <<variability,`variability == discrete`>>.

|`InitialUnknown`
|
[[InitialUnknown,`<InitialUnknown>`]]
Ordered list of all exposed unknowns in <<InitializationMode>>.
This list consists of all variables with

- <<causality>> = <<output>> and (<<initial>> = <<approx>> or <<calculated>>), and

- <<causality>> = <<calculatedParameter>> and

- all continuous-time <<state,`states`>> and all state derivatives (defined with elements <<ContinuousStateDerivative>>) with <<initial>> = <<approx>> or <<calculated>> _[if a Co-Simulation FMU does not define the <<ContinuousStateDerivative>> elements, (3) cannot be present]_.

The resulting list is not allowed to have duplicates (for example, if a <<state>> is also an <<output>>, it is included only once in the list). +
Attribute <<dependencies>> defines the dependencies of the unknowns from the knowns in <<InitializationMode>> at the initial time.
Beside the knowns the initial unknowns also depend on the "frozen" variables (= variables which cannot be changed in the current mode) but these "frozen" variables are not listed as <<dependencies>>.
The functional dependency is defined as:

latexmath:[{\mathbf{v}_{\mathit{initialUnknowns}} := \mathbf{f}_{\mathit{init}}(\mathbf{u}_c, \mathbf{u}_d, t_0, \mathbf{v}_{\mathit{initial=exact}})}]

Since, <<output,`outputs`>>, continuous-time <<state,`states`>> and state derivatives are either present as knowns (if <<initial>> = <<exact>>) or as unknowns (if <<initial>> = <<approx>> or <<calculated>>), they can be inquired with <<get-and-set-variable-values,`fmi3Get{VariableType}`>> in <<InitializationMode>>.

_[Example: Assume an FMU is defined in the following way:_

latexmath:[{(\mathbf{y}_{c+d}, \dot{\mathbf{x}}_c) := \mathbf{f}_{\mathit{init}}(\mathbf{x}_c, \mathbf{u}_{c+d}, t_0, \mathbf{p})}] +

latexmath:[{(\mathbf{y}_{c+d}, \dot{\mathbf{x}}_c) := \mathbf{f}_{\mathit{sim}}(\mathbf{x}_c, \mathbf{u}_{c+d}, t_i, \mathbf{p})}] +

_Therefore, the initial state latexmath:[{\mathbf{x}_c(t_0)}] has <<initial>> = <<exact>> and the initial state derivative latexmath:[{\dot{\mathbf{x}}_c(t_0)}] has <<initial>> = <<calculated>>._
_The environment can still initialize this FMU in steady-state, by using latexmath:[{\mathbf{x}_c(t_0)}] as iteration variables and adding the equations latexmath:[{\dot{\mathbf{x}}_c(t_0) = \mathbf{0}}] in the environment.]_

|`EventIndicator`
|
[[EventIndicator,`<EventIndicator>`]]
Ordered list of all event indicators, in other words, a list of value references where every corresponding variable must be an event indicator.
_[Note that only <<continuous>> floating point variables are listed here._
_If an event indicator shall not be exposed from the FMU, or if event indicators are not statically associated with a variable (due to dynamic event indicator selection), then dummy variables have to be introduced, for example, `eventIndicator[4]`._
_The ordering of the variables in this list is defined by the exporting tool.]_

For Co-Simulation, elements <<EventIndicator>> are ignored.
_[If an FMU supports both Model Exchange and Co-Simulation, then the <<EventIndicator>> elements might be present, since it is needed for Model Exchange.]_

|`Clock`
|
[[ClockElement,`<Clock>`]]
List of all clocks and their clocked variables.
All variables referenced by these lists must have <<variability,`variability == discrete`>>.
A clocked variable my depend on multiple clocks and may therefore be listed in multiple <<ClockElement>> elements.
_[More rigorous importers requiring a variable to be dependent on a single clock can reject FMUs violating this restriction.]_

|====

Elements <<Output>>, <<ContinuousStateDerivative>>, <<ClockedState>>, <<InitialUnknown>>, <<EventIndicator>> and <<ClockElement>> have (partially) the following attributes:

.<<Output>>, <<ContinuousStateDerivative>>, <<ClockedState>>, <<InitialUnknown>>, <<EventIndicator>> and <<ClockElement>> attribute details.
[[table-output-der-initialUknown-details]]
[cols="1,5", options="header"]
|====
|Attribute
|Description

|`valueReference`
|The value reference of the unknown latexmath:[{v_{\mathit{unknown}}}].

|`dependencies`
|
[[dependencies,`dependencies`]]
Optional attribute defining the dependencies of the unknown latexmath:[{v_{\mathit{unknown}}}] (directly or indirectly via auxiliary variables) with respect to latexmath:[{\mathbf{v}_{\mathit{known}}}].
If not present, it must be assumed that the unknown depends on all knowns.
If present as empty list, the unknown depends on none of the knowns.
Otherwise the unknown depends on the knowns defined by the given value references. +
Knowns latexmath:[{\mathbf{v}_{\mathit{known}}}] in <<EventMode>> and <<ContinuousTimeMode>> (ME) and at communication points (CS and SE) for <<Output>> and <<ContinuousStateDerivative>> elements:

* inputs (variables with <<causality>> = <<input>>),

* continuous states and discrete-time states,

* parameters (variables with <<causality>> = <<parameter>>),

* <<independent>> variable (usually time; <<causality>> = <<independent>>).

_[The list of dependencies may include input clocks (variables with <<causality>> = <<input>> and <<variability>> = <<clock>>)._
_If an <<outputClock>> depends on an <<inputClock>>, then clock ticks of the <<inputClock>> in <<EventMode>> or <<ClockActivationMode>> may create <<outputClock>> ticks during this event handling.]_

Knowns latexmath:[{\mathbf{v}_{\mathit{known}}}] in <<InitializationMode>> (for elements <<InitialUnknown>>):

* inputs (variables with <<causality>> = <<input>>),

* variables with <<initial>> = <<exact>>, _[for example, <<parameter,`parameters`>> or initial <<state,`states`>>]_

* <<independent>> variable (usually time; <<causality>> = <<independent>>).

For Co-Simulation, if the capability flag <<providesDirectionalDerivatives>> has a value of `false`, then <<dependencies>> does not list the dependency on continuous-time.
In other words, the respective partial derivatives cannot be computed.

|`dependenciesKind`
|
[[dependenciesKind, `dependenciesKind`]]
If <<dependenciesKind>> is present, <<dependencies>> must be present and must have the same number of list elements.
If not present, it must be assumed that the unknown latexmath:[{\mathbf{v}_{\mathit{unknow}}}] depends on the knowns latexmath:[{\mathbf{v}_{\mathit{known}}}] without a particular structure.
Otherwise, the corresponding known latexmath:[{\mathbf{f}_{\mathit{known},i}}] enters the equation as:

`= dependent`: no particular structure, latexmath:[{{\mathbf{f}(..,\ v}_{\mathit{known},i}}],..)

Only for floating point type unknowns latexmath:[{\mathbf{v}_{\mathit{unknown}}}]:

`=` <<constant>>: constant factor, latexmath:[{c \cdot \mathbf{v}_{\mathit{known},i}}] where latexmath:[{c}] is an expression that is evaluated before <<fmi3EnterInitializationMode>> is called.

Only for floating point type unknowns latexmath:[{\mathbf{v}_{\mathit{unknown}}}] in Event and <<ContinuousTimeMode>> (ME) and at communication points (CS and SE), and not for <<InitialUnknown>> for <<InitializationMode>>:

`=` <<fixed>>: fixed factor, latexmath:[{p \cdot \mathbf{v}_{\mathit{known},i}}] where latexmath:[{p}] is an expression that is evaluated before <<fmi3ExitInitializationMode>> is called.

`=` <<tunable>>: tunable factor, latexmath:[{p \cdot \mathbf{v}_{\mathit{known},i}}] where latexmath:[{p}] is an expression that is evaluated before <<fmi3ExitInitializationMode>> is called and in <<EventMode>> due to event handling (ME) or at a communication point (CS and SE)

`=` <<discrete>>: discrete factor, latexmath:[{d \cdot \mathbf{v}_{\mathit{known},i}}] where latexmath:[{d}] is an expression that is evaluated before <<fmi3ExitInitializationMode>> is called and in <<EventMode>> due to an external or internal event or at a communication point (CS and SE).

|`clockedVariables`
|
[[clockedVariables, `clockedVariables`]]
This element is only available with the <<ClockElement>> element and is a list of value references indicating clocked variables depending on this clock.

|====

_[Example 1:_

_An FMU is defined by the following equations:_

[latexmath]
++++
\begin{align*}

\frac{d}{\text{dt}}\begin{bmatrix}
x_{1} \\
x_{2} \\
x_{3} \\
\end{bmatrix}

&=

\begin{bmatrix}
f_{1}\left( x_{2} \right) \\
f_{2}\left( x_{1} \right) + 3 \cdot p^{2} \cdot x_{2} + 2 \cdot u_{1} + 3 \cdot u_{3} \\
f_{3}\left( x_{1},x_{3},u_{1},u_{2},u_{3} \right) \\
\end{bmatrix}

\\

y &= g_1(x_2, x_3)

\end{align*},
++++

_where_ latexmath:[{u_{1}}] _is a continuous-time <<input>> (<<variability>> = <<continuous>>),_ latexmath:[{u_{2}}] _is any type of <<input>>,_ latexmath:[{u_{3}}] _is a floating point discrete-time <<input>> (<<variability>> = "discrete"`), and_ latexmath:[{p}] _is a <<fixed>> <<parameter>> (<<variability>> = <<fixed>>)._
_The initialization is defined by:_

[latexmath]
++++
x_1 = 1.1, \frac{dx_2}{dt} = 0, y = 3.3,
++++

_and therefore, the initialization equations are:_

[latexmath]
++++
\begin{align*}
x_{2} &= \frac{1}{3 \cdot p^{2}} \cdot ( f_{2}\left( x_{1} \right) + 2 \cdot u_{1} + 3 \cdot u_{3} )
\\
x_{3} &= g_{1}^{- 1}( x_{2}, y)
\end{align*}
++++

_This equation system can be defined as:_

[source, xml]
----
include::examples/model_structure_example1.xml[tags=VariablesAndStructure]
----

_Example 2:_

[latexmath]
++++
y = \left\{ \begin{matrix}
2 \cdot u \ \mathrm{if} \ u > 0 \\
3 \cdot u \ \mathrm{else} \\
\end{matrix}\right.
++++

_where_ latexmath:[{u}] _is a continuous-time <<input>> with <<valueReference>> = `1` and_ latexmath:[{y}] _is a continuous-time <<output>> with <<valueReference>> = `2`._
_The definition of the model structure is then:_

[source, xml]
----
include::examples/model_structure_example2.xml[tags=ModelStructure]
----

_[Note that_ latexmath:[{y = d \cdot u}] _where_ latexmath:[{d}] _changes only during <<EventMode>> (_ latexmath:[{d = 2 \cdot u}] _or_ latexmath:[{3 \cdot u\ }] _depending on relation_ latexmath:[{u > 0}] _that changes only at <<EventMode>>)._
_Therefore <<dependenciesKind>> = <<discrete>>.]_

_Example 3:_

[latexmath]
++++
y = \left\{ \begin{matrix}
2\ \ \mathrm{if}\ \ u > 0 \\
3\ \ \mathrm{else} \\
\end{matrix}\right.
++++

_where_ latexmath:[{u}] _is a continuous-time <<input>> with <<valueReference>> = `1` and_ latexmath:[{y}] _is a continuous-time <<output>> with <<valueReference>> = `2`._
_The definition of the model structure is then:_

[source, xml]
----
include::examples/model_structure_example3.xml[tags=ModelStructure]
----

_[Note that_ latexmath:[{y = c}] _where_ latexmath:[{c}] _changes only during <<EventMode>> (_ latexmath:[{c = 2}] _or_ latexmath:[{3\ }] _depending on relation_ latexmath:[{u > 0}] _that changes only at <<EventMode>>)._
_Therefore <<dependenciesKind>> = <<dependenciesKind,`dependent`>> because it is not a linear relationship on_ latexmath:[{u}]. _]_

_Example 4:_

[latexmath]
++++
\frac{dx}{dt}=u, y=x
++++

where `u` is continuous-time input value reference `1`, `y` is a continuous-time output with value reference `2` and `dxdt` is a continuous-time derivative with value reference `4`.
The definition of the model structure is then:

[source, xml]
----
include::examples/model_structure_example4.xml[tags=VariablesAndStructure]
----

_Defining FMU features with the_ <<dependencies>> _list:_

_[Note that via the <<dependencies>> list the supported features of the FMU can be defined._
_Examples:_

- _If a state derivative `der_x` is a function of a <<parameter>> p (so of a <<start>> value of a variable with <<causality>> = <<parameter>> and <<variability>> = <<fixed>>), and the FMU does not support an iteration over `p` during <<InitializationMode>> (for example, to iterate over p such that the state derivative `der_x` is zero), then the <<dependencies>> list of `der_x` should not include `p`._
_If an FMU is imported in an environment and such an iteration is set up, then the tool can figure out that the resulting algebraic system of equations is structurally singular and therefore can reject such a definition._

- _For Co-Simulation FMUs, it is common that no algebraic loops over the <<input>> / <<output>> variables nor over <<start>> values is supported._
_In such a case, all <<dependencies>> lists for <<output>> variables under the <<InitialUnknown>> element should be defined as empty lists defining that the setting of <<input,`inputs`>> and/or of <<start>> values does not influence the <<output,`outputs`>>._
_As a result, it is not possible to formulate algebraic loops of connected FMUs during <<InitializationMode>>.]_

==== Definition of Terminals and Icons [[fmiTerminalsAndIcons]]

Terminals define semantic groups of variables to ease connecting compatible signals on the system level.
Icons define a graphical representation of an FMU and its terminals.

Both can be defined in the separate XML file `icons/terminalsAndIcons.xml`:

.fmiTerminalsAndIcons element.
[[terminals_and_icons_overview]]
image::images/schema/fmiTerminalsAndIcons.png[width=60%, align="center"]

On the top level, the schema consists of the following elements (see <<terminals_and_icons_overview>>).

.fmiTerminalAndIcons element details.
[[table-terminal-and-icon-details]]
[cols="1,3",options="header"]
|====
|Element
|Description

|`<GraphicalRepresentation>`
|If present, contains information for importers of FMUs to draw graphical representations of the FMU in a system view.

|`<Terminals>`
|If present, this allows combining input and output variables into logical groups to ease connections on a system level.
|====

===== Definition of a Graphical Representation [[graphicalRepresentation]]


====== Overview

The graphical representation of the FMU and terminals are needed in order to more easily comprehend the meaning of connected FMUs and to help an importing tool to display the terminals and the FMU icon in the way the exporter intended.

The graphical representation is fully optional.
The graphical representation of terminals is separate from the terminal definitions in the `<Terminals>` element.

There are two optional elements in the `<GraphicalRepresentation>`:

. The `<CoordinateSystem>` defines the extent of the whole icon (graphical items may exceed that rectangle).
. The `<Icon>` defines an image source for the FMU.

.GraphicalRepresentation element.
[[figure-schema-GraphicalRepresentation]]
image::images/schema/GraphicalRepresentation.png[width=100%, align="center"]

====== CoordinateSystem

.CoordinateSytem element.
[[figure-schema-CoordinateSystem]]
image::images/schema/CoordinateSystem.png[width=70%, align="center"]

The `<CoordinateSystem>` element and its defined extent is used as reference for other graphical items.
It also provides a scaling factor to millimeter.

The coordinate system is defined by the coordinates of two points, the lower left (`x1`, `y1`) corner and the upper right (`x2`, `y2`) corner, where the coordinates of the first point shall be less than the coordinates of the second point _[a first quadrant coordinate system]_.
The x-axis is directed to the right, the y-axis is directed upwards.

_[The exporting tool should define how the coordinate system unit relates to mm display or print out size._
_However, an importing tool might choose to use the factor from the default coordinate system extent to the actual coordinate system extent to calculate a scaling factor, to match the default icon size in the importing tool._

_The area defined by the coordinate system is suggested to be used as "clickable icon size" in other tools._
_A `<Terminal>` might be placed outside of this area, so the visible bounding box has to be determined by the importing tool.]_

The coordinate system default is `x1=-100, y1=-100, x2=100, y2=100`.
This extent is used if the `<CoordinateSystem>` element is missing.
The default `suggestedScalingFactorTo_mm` is 0.1.
So the default coordinate system display size should be 20 mm width and 20 mm height.

The FMU icon and all graphical representations provide the position and extent with the attributes `x1`, `y1`, `x2`, `y2`.
The values of these attributes directly relate to this coordinate system and are not normalized.
Flipping of the FMU icon or a terminal can be realized by setting its attributes `x2 < x1` or `y2 < y1` without changing the coordinate system.

====== Icon

.Icon element.
[[figure-schema-Icon]]
image::images/schema/Icon.png[width=40%, align="center"]

The extent and position of the FMU icon are defined in the `<Icon>` element.
The optional image file of the FMU icon is placed at the path `icons/icon.png` in the ZIP archive of the FMU.
The terminals should not be visible in the image.
Optionally an SVG file can be provided if also the PNG file is present.
This enables high quality rendering and printing in importing tools.
This SVG file has to be placed at the path `icons/icon.svg` in the ZIP archive.

The point (`x1`, `y1`) maps to the left lower corner of the PNG image or SVG viewport.
The point (`x2`, `y2`) maps to the right upper corner of the PNG image or SVG viewport.

====== Placement, Extent, and Painting Order of Graphical Items

image::images/GraphicalRepresentation.svg[width=70%, pdfwidth=70%, align="center"]

The clickable icon size is defined by the `<CoordinateSystem>` element.
The FMU icon itself may exceed this extent (or bounding box).
The bounding box of the terminals is given by the extent in the terminals element.
Their location is neither limited to the extent of the icon nor the extent of the coordinate system.
_[An importing tool has to determine the outer bounding box enclosing all graphical items.]_

Transparent SVG or PNG files are allowed and wanted.
The order of the elements in the XML file defines the order of painting.
The first element in the `<TerminalGraphicalRepresentation>` is painted first and therefore behind the others, the last element is painted on top of the others and because of that in front of them.
_[So the FMU icon should be placed first in the XML file, terminal below.]_

===== Definition of Terminals [[definitionOfTerminals]]

====== Overview

Terminals are fully optional and can be ignored by any importing tool.

Definition `<Terminal>`: A terminal is...

* a structured interface for connections to other models
* intended to be used for signal flow between models, parameter propagation, and compatibility checks of the model configuration
* a sequence of references to variables with connection meta data

Predefined rules for variable matching in a connection are given in <<table-predefined-matching-rules>>.
Predefined variable kinds are used to describe how the member variables have to be handled.
Domain specific connection rules, terminals and their member variables can be provided by other standards.

_[Co-simulation errors are not addressed by the terminals._
_The co-simulation algorithm has to be chosen and implemented by the importing tool._
_Features that might be required for specific co-simulation algorithms had to be implemented by the FMU exporting tool._

_Algebraic loops in systems of connected Model Exchange FMUs are not addressed or resolved by the terminals._
_It is not required that the <<causality>> of the terminal member variables in connected terminals match._

_The SSP standard refers to a `connectorKind`._
_This `connectorKind` is not related to the `terminalKind` or `variableKind` described in <<section-terminals>> and <<section-terminalvars>>.]_

[[section-terminals]]
====== Terminals

Element `<fmiTerminalsAndIcons><Terminals>` is defined as:

.Terminals element.
[[figure-schema-Terminals]]
image::images/schema/Terminals.png[width=80%, align="center"]

All instances of `<Terminal>` have the type `fmi3Terminal` and are listed in the `<Terminals>` sequence.

The normalized string attribute `name` of the `<Terminal>` element is the instance name of the terminal.
The terminal name must be unique on each level.
//_[The terminal name may contain dots, to enable structured terminals.]_

The normalized string attribute `matchingRule` describes the rules for variable matching in a connection.
As detailed in <<table-predefined-matching-rules>>, there are three predefined matching rules: plug, bus, and sequence.
Other standards may define new matching rules.
In order to avoid ambiguities and conflicts, rule names must follow the reverse domain notation of a domain that is controlled by the entity defining the semantics and content of the additional entries.
The rule names beginning with `org.modelica` and `org.fmi-standard` are explicitly reserved for use by MAP FMI-defined layered standards.

There is a sequence of terminal member variables, terminal stream member variables, nested terminals, and an optional `<TerminalGraphicalRepresentation>` element in the `<Terminal>` element.
The member variables are the exchanged variables.
The type of the nested terminals is `fmi3Terminal`, and they can be used to implement structured terminals.

.Predefined matching rules.
[#table-predefined-matching-rules]
[cols="1,3",options="header"]
|====
|`matchingRule`
|Description

[[plug,`plug`]]
|`plug`
|Matching of the variables is based on `memberName`.
An importing tool should connect terminals only if all member variables are present and match.

[[bus,`bus`]]
|`bus`
|Matching of the variables is based on `memberName`.
An importing tool may connect terminals if some or no terminal member variables are present.

[[sequence,`sequence`]]
|`sequence`
|Matching of the variables is based on the order of the terminal member variables.
An importing tool should connect terminals only if the number of member variables matches.

|====

The normalized string `terminalKind` is an optional attribute.
Other standards may define terminal kinds.
It is intended that the `terminalKind` is used to define domain specific member variable sequences, member names and order, or high level restrictions for connections.

_[Other terminal kinds should refer to the predefined `matchingRule`._
_Vendor specific terminal kinds should start with `_vendorName` or `_toolName` to avoid namespace clashes._

_Examples for `terminalKind`: `StandardXXX_Mechanical_Translational`, `Modelica.Mechanics.Translational.Interfaces.Flange_a`, `vendorNameA_customTypeA`, `_vendorNameB_customLibrary_customTypeB`._

_The structured naming convention of the `<ModelVariables>` is independent from the terminal names and member variable names._

_A tool may choose to connect terminals with a different or unknown `terminalKind`, if the `matchingRule` matches.]_

[[section-terminalvars]]
====== Terminal Member Variable

The `<TerminalMemberVariable>` is defined as:

.TerminalMemberVariable element.
[[figure-schema-TerminalMemberVariable]]
image::images/schema/TerminalMemberVariable.png[width=70%, pdfwidth=50%, align="center"]

The normalized string `variableName` is used to identify the terminal member variable in the element `<ModelVariables>`.
The information about minimum, maximum, and nominal values is available in there.

One variable can be part of several terminals.

If the `matchingRule` `plug` and `bus` are used, then the normalized string `memberName` is used for member variable matching.
So the `memberName` attribute is required for `plug` and `bus` and it has to be unique for a terminal.
The `memberName` is not required for `matchingRule` `sequence`.

The normalized string `variableKind` is used to provide general information about the variable.
This information defines how the connection of this variable has to be implemented (e.g. Kirchhoff's current law or common signal flow).

The predefined `variableKind` are:
.Predefined kinds of variables.
[[table-variable-kinds]]
[cols="1,3",options="header"]
|====
|`variableKind`
|Description

[[signal,`signal`]]
|`signal`
|The values in connected terminals are intended to be equal.
Restricted to <<input>> and <<output>>, <<parameter>> and <<calculatedParameter>>.
_[Example: Signal flow, parameter propagation, equality checks]_

[[inoutflow,`inflow/outflow`]]
|`inflow` / `outflow`
|Variables which fulfill Kirchhoff's current law.
Restricted to <<input>> and <<output>>, <<parameter>> and <<calculatedParameter>>.
_[Example: Electric current]_
|====

_[The suggested variable naming scheme for the structured naming convention is <ModelVariable name> = <terminalName>.<memberName>._

_Not all `<ModelVariables>` which have the prefix "<terminalName>." are a member variable, and there may exist member variables which don't have this prefix._

_Example 1 (suggested scheme): <ModelVariable name> is `portA.U`, <terminalName> is `portA`, <memberName> is `U`._

_Example 2 (suggested scheme): <ModelVariable name> is `hierarchConn.innerConn.U`, <outer terminal name> is `hierarchConn`, <inner terminal name> is `innerConn`, <memberName> is `U`._

_Example 3 (no prefix): <ModelVariable name> is `u`, <terminalName> is `portA`, <memberName> is `u`._

_Example 4 (prefix but not a member): <ModelVariable name> is `portA.u`, there is a terminal with <terminalName> `portA`, but this variable is not a terminal member._

_The suggested variable naming scheme for the non-structured naming convention is: <ModelVariable name> = <memberName>_

_Matching is not restricted by <<variability>>, <<causality>> or variable type._
_Example: A <<fixed>> variable may be connected to a <<tunable>> variable, a variable of type `fmi3Float64` may be connected to a variable of type `fmi3Int32`._
_However, it is recommended that the variable types and variabilities are equal._

_The `matchingRule` refers to the `<TerminalMemberVariable>` on the same level only._
_Nested terminals can have different `matchingRule`s._

_There is no special handling of <<derivative,`derivatives`>>._
_If a <<derivative>> is a terminal member variable then it is considered as normal member variable._
_However, if a <<derivative>> of a terminal member variable is not terminal member, then this <<derivative>> information may be used by an importing tool.]_

====== Terminal Stream Member Variable

The `<TerminalStreamMemberVariable>` is defined as:

.TerminalStreamMemberVariable element.
[[figure-schema-TerminalStreamMemberVariable]]
image::images/schema/TerminalStreamMemberVariable.png[width=80%, pdfwidth=60%, align="center"]

This element is used for variables which fulfill the balance equation for transported quantities.
It is restricted to <<input>> and <<output>>, <<parameter>> and <<calculatedParameter>>.

The Stream concept is described in the appendix D.3 of the Modelica specification.
Only one terminal member variable with the `variableKind` `inflow` or `outflow` per terminal is allowed, if a `<TerminalStreamMemberVariable>` is present.
_[More sophisticated structures can be implemented using hierarchical terminals.]_

The attribute `inStreamVariableName` and `outStreamVariableName` are used to identify the `<ModelVariables>`.
If the referenced model variables are arrays, then the size of the `inStreamVariableName` and `outStreamVariableName` has to be equal.
A terminal may have more than one `<TerminalStreamMemberVariable>`.
The `inStreamMemberName` and `outStreamMemberName` describe the terminal member name for matching purposes, similar to the `memberName` attribute in the `<TerminalMemberVariable>`.

_[An example of use for an array of stream variables is a gas mixture flow._
_The gas composition could be implemented as a mass fraction vector._
_The `outStreamVariableName` refers to_ latexmath:[portA.q_\textit{outStream}\textit{[\]}] _and the `inStreamVariableName` refers to_  latexmath:[portA.q_\textit{inStream}\textit{[\]}] _._
_The `inStreamMemberName` and `outStreamMemberName` are "_ latexmath:[q_\textit{inStream}\textit{[\]}] _" and "_ latexmath:[q_\textit{outStream}\textit{[\]}] _"._

_Balance equation for transported quantities:_

_latexmath:[0 = \sum{q_i\dot{m}_i}]_

_latexmath:[0 = \sum{\dot{m}_i}\cdot
\left\{\begin{array}{ll}
q_{i, \mathit{outStream}} &\textit{if $\dot{m}$ is outflowing through terminal $i$}\\
q_{i, \mathit{inStream}} &\textit{if $\dot{m}$ is inflowing through terminal $i$}
\end{array}\right.]_

_The_ latexmath:[q_{i,\mathit{outStream}}] _is the convective quantity in case the matter flows out of the FMU._
latexmath:[q_{i,\mathit{inStream}}] _is the convective quantity in case the matter flows into the FMU._
_Both variables are present in the terminal._
_The outStream variable has the <<causality>> <<output>> or <<calculatedParameter>> because this information has to be provided by each FMU._
_The inStream variable has the <<causality>> <<input>> or <<parameter>>._
_To display the actual value in an importing tool, this actual value has to be selected depending on the sign of the terminal member variable with `variableKind` `inflow` or `outflow`._
_However, calculating the actual value is not necessary._

_If only two terminals with a variable are connected and their <<causality>> matches, then the values of the outStream variables can be forwarded to the corresponding inStream values._

_In Modelica the inStream variable is not directly visible, the value can only be accessed using "inStream()", therefore an additional model variable has to be added during the export._
_It is suggested that Modelica tools exporting an FMU derive the member name for the inStream variable according to the scheme "<outStream name>_inStream"._
_E.g. if the outStream name is "h_outflow" then the inStream name should be "h_outflow_inStream".]_

====== Terminal Graphical Representation

The `<TerminalGraphicalRepresentation>` is defined as:

.TerminalGraphicalRepresentation element.
[[figure-schema-TerminalGraphicalRepresenation]]
image::images/schema/TerminalGraphicalRepresentation.png[width=75%, pdfwidth=60%, align="center"]

The `iconBaseName` attribute is mandatory.
This attribute defines the base name of the image file as a relative URI according to RFC 3986.
The base URI that this relative URI is resolved against is the URI of the `icons/terminalsAndIcons.xml` file in the FMU ZIP archive.
Implementations are required to support relative URIs, excluding relative URIs that move beyond the baseURI (i.e. go "up" a level via ..).
Implementations are not required to support any absolute URIs and any specific URI schemes.
The PNG file with the extension '.png' has to be provided.
An additional SVG file with extension '.svg' is optional.

_[Note that this specification is functionally equivalent to looking up image sources from the icons folder of the FMU ZIP archive after dot removal from the path as per section 5.2.4 of RFC 3986.]_

The `defaultConnectionStrokeSize` and `defaultConnectionColor` can be provided to define the intended connection line layout in the importing tool.
The stroke size is given relative to the coordinate system extent.
The stroke color is given in RGB values from 0 to 255. E.g.: `255 255 0`.

_[Nested terminals may have a `<TerminalGraphicalRepresentation>` element._
_However, if and how nested terminals are displayed, is up to the importing tool.]_

_[The order of painting of the `<TerminalGraphicalRepresentation>` of terminals on each level is equal to the order of appearance in the `<Terminal>` element._
_So graphical representations appearing first, are painted first, are behind graphical representations which appear below.]_

The `Annotations` element can be used by vendors to store additional information for the graphical representation.
_[It is suggested that Modelica tools store the Modelica annotation of the connector under the `type` `org.modelica.Modelica4Annotation` in the annotations of an element `connector`._
_The attribute `name` of the connector element is equal to the `name` attribute of the referenced `fmi3Terminal`.]_

_[If the graphical representation is used for an <<input>> or <<output>> (e.g. a `fmi3Float64` <<input>> `u`), then a `<Terminal>` has to be added to the `<Terminals>` element which has one `<TerminalMemberVariable>`.]_

====== General Remark on Signal [[GeneralRemarkOnSignal]]

_[The signal `variableKind` can be applied for different use cases._
_The first use case is a signal flow from an <<output>> of one FMU to an <<input>> of another FMU._
_The <<output>> value has to be forwarded to the <<input>>._

_The signal flow can cause algebraic loops._
_If variables in connected terminals have the <<causality>> <<output>>, then an importing tool may iterate an undefined <<input>> of an FMU to ensure that the connected output values are equal._

_Another use case is the parameter propagation._
_If a variable in both connected terminals has the <<causality>> <<parameter>>, then an importing tool could ask the user for the value of one of those <<parameter,`parameters`>> only, and propagate this value to the other FMU._
_If only one of the variables has <<causality>> <<parameter>>, and the other is a <<constant>> <<output>> or <<calculatedParameter>>, then the importing tool could also propagate the <<parameter>> value without presenting a parameter to the user._
_One example of use would be the name of a substance flowing through a pipe._
_If the fluid flows from one pipe FMU to another, the substance should be the same._
_This substance name could be propagated over several FMUs._

_Finally the `variableKind` `signal` can be applied to implement compatibility checks._
_If for example the <<variability>> of the variables in connected terminals are <<constant>>, then the importing tool can implement an equality assertion._
_This is also possible with <<calculated>> <<parameter,`parameters`>>._
_One example of use would be the cross sectional flow area in pipes which is calculated from geometry parameters._
_A change in the cross sectional flow area is relevant for the momentum equation, and therefore the connection has to be deemed incompatible if these variables are present and unequal.]_

====== General Remark on Inflow and Outflow

_[Flow variables have a direction and must fulfill a zero sum constraint i.e. the sum of all flow variables connected must be zero (Kirchhoff's current law)._
_In addition because different tools might have different direction definitions both, `inflow` and `outflow` are available as `variableKind`._
_For variables with `inflow` a positive value means that the flow is inwards, and for `outflow` a positive value means that the flow is outwards._
_For the sake of simplicity in the following latexmath:[\dot{m}_i] denotes an inflowing quantity:_

_latexmath:[0 = \sum{\dot{m}_i}]_

_[Connecting a single <<output>> `outflow` to a single <<input>> `inflow`, or vice versa automatically fulfills the flow constraint, while connecting two variables of the same flow type requires a negation of the variable value._

`inflow` _and_ `outflow` _is only used as a sign convention for scalar flow quantities which obey Kirchhoff's current law (sum up to zero)._
_Other, nonscalar, quantities which also sum up to zero, like a mechanical force in 3D space according to D'Alembert's principle, are not covered by this sign convention._
_This is the case since Kirchhoff's current law only holds for scalars where a sign convention is sufficient._
_Other definitions are beyond the scope of this terminal specification and need clear definition in other specifications on top of this.]_
