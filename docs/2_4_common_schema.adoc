=== FMI Description Schema [[fmi-description-schema]]

[[modelDescription.xml,`modelDescription.xml`]]
All static information related to the core functionality of an FMU is stored in the text file <<modelDescription.xml>> in XML format as specified by the XML schema file `fmi3ModelDescription.xsd`.
Especially, the FMU variables and their attributes such as `name`, `unit`, default <<initial>> value, etc. are stored in this file.

Additional optional information about the graphical representation and the grouping of FMU variables into terminals is stored in the optional text file `icons/terminalsAndIcons.xml` in XML format as specified by the XML schema file `fmi3TerminalsAndIcons.xsd`.

Build information for source code FMUs is provided together with a `buildDescription.xml` file in the `sources` directory that adheres to the `fmi3BuildDescription.xsd` schema file.

It is not allowed to change the <<modelDescription.xml>> file.
_[Reason: The <<modelDescription.xml>> file has to be consistent with the binary or source code implementations._
_Specifically, changes to the start values are not allowed.]_

The structure of the XML files is defined with the schema file `fmi3ModelDescription.xsd` and the optional `fmi3TerminalsAndIcons.xsd` and `fmi3BuildDescription.xsd` files.
These schema files utilize several helper schema files.

In this section these schema files are discussed.
The normative definition are the above mentioned schema files.
In the graphical representation of the schema, optional elements are marked with a dashed box (e.g., see <<figure-schema-Annotations>>).
The required data types (like: `xs:normalizedString`) are defined in https://www.w3.org/TR/xmlschema-2/[XML Schema Part 2: Datatypes Second Edition].
The types used in the FMI schema files are:

[cols="1,3,1,1"]
|====
|XML
|Description (http://www.w3.org/TR/xmlschema-2/)
|Mapping to C
|Mapping to FMI 3.0

|`double`
|IEEE 754 double-precision 64-bit floating point type _[An IEEE 754 double-precision floating point value can have up to 17 significant digits in its decimal representation.
In order to not loose precision, either an appropriate minimal printer algorithm should be used, or alternatively a number of this type should be stored in XML files with at least 17 significant digits.]_
|`double`
|`fmi3Float64`

|`single`
|IEEE 754 single-precision 32-bit floating point type _[An IEEE 754 single-precision floating point value can have up to 9 significant digits in its decimal representation.
In order to not loose precision, either an appropriate minimal printer algorithm should be used, or alternatively a number of this type should be stored in XML files with at least 9 significant digits.]_
|`float`
|`fmi3Float32`

|`byte`
|Integer number with maximum value 127 and minimum value -128 (8 bit signed integer)
|`int8_t`
|`fmi3Int8`

|`unsignedByte`
|Integer number with maximum value 255 and minimum value 0 (8 bit unsigned integer)
|`uint8_t`
|`fmi3UInt8`

|`short`
|Integer number with maximum value 32767 and minimum value -32768 (16 bit signed integer)
|`int16_t`
|`fmi3Int16`

|`unsignedShort`
|Integer number with maximum value 65535 and minimum value 0 (16 bit unsigned integer)
|`uint16_t`
|`fmi3UInt16`

|`int`
|Integer number with maximum value 2147483647 and minimum value -2147483648 (32 bit signed integer)
|`int32_t`
|`fmi3Int32`

|`unsignedInt`
|Integer number with maximum value 4294967295 and minimum value 0 (32 bit unsigned integer)
|`uint32_t`
|`fmi3UInt32`

|`long`
|Integer number with maximum value 9223372036854775807 and minimum value -9223372036854775808 (64 bit signed integer)
|`int64_t`
|`fmi3Int64`

|`unsignedLong`
|Integer number with maximum value 18446744073709551615 and minimum value 0 (64 bit unsigned integer)
|`uint64_t`
|`fmi3UInt64`

|`boolean`
|Boolean number.
Legal literals: `false`, `true`, `0`, `1`
|`int`
|`fmi3Boolean`

|`string`
|Any number of characters
|`char*`
|`fmi3String`

|`normalizedString`
|String without carriage return, line feed, and tab characters
|`char*`
|`fmi3String`

|`hexBinary`
|Arbitrary hex-encoded binary data
|`char*`
|`fmi3Binary`

|`dateTime`
|Date, time and time zone (for details see https://www.w3.org/TR/xmlschema-2/[XML Schema Part 2: Datatypes Second Edition]).
Example: `2002-10-23T12:00:00Z` (noon on October 23, 2002, Greenwich Mean Time)
|tool specific
|not defined
|====

The first line of an XML file, such as <<modelDescription.xml>>, must contain the encoding scheme of the XML file.
It is required that the encoding scheme is always UTF-8:

[source, xml]
----
include::examples/co_simulation.xml[lines=1]
----

The FMI schema files (`fmi3*.xsd`) are also stored in UTF-8. +
_[Note that the definition of an encoding scheme is a prerequisite in order for the XML file to contain letters outside of the 7 bit ANSI ASCII character set, such as German umlauts, or Asian characters._
_Furthermore, note the FMI calling interface requires that strings are encoded in UTF-8._
_Since the XML files are also required to be encoded in UTF-8, string variables need not to be transformed when reading from the XML files in to C string variables.]._

_[Note that child information items, such as elements in a sequence are ordered lists according to document order, whereas attribute information items are unordered sets (see http://www.w3.org/TR/XML-infoset/#infoitem.element)._
_The FMI schema is based on ordered lists in a sequence and therefore parsing must preserve this order._
_For example, the information stored in `<ModelVariables><Derivative>` is only correct if this property is fulfilled.]_

All XML-based file formats defined in this standard allow optional `Annotation` elements to be inserted in all XML elements that represent entities of the underlying data model.
This is achieved through the `Annotations` element:

.Annotations Element.
[#figure-schema-Annotations]
image::images/schema/Annotations.png[width=80%]

Each `Annotation` element contains a required `type` attribute, which contains the namespace for that annotation.
The content of the `Annotation` element can be arbitrary XML data, and can make use of XML namespaces and XML schemas for combined validation where appropriate.

The namespace mechanism for the `type` attribute is based on reverse domain notation:
The originator of a specification for additional data specifies a domain name under their control as the namespace for the additional data, in order to avoid conflicts due to name collisions.
The namespace is used in reverse domain notation.
All namespaces under both the `org.modelica` and `org.fmi-standard` domains are reserved for use in future layered standards.

_[For example, extensions defined by the Modelica Association might make use of the `org.modelica.fmi` namespace._
_This could lead to annotations with a `type` attribute of `org.modelica.fmi.something`, and/or extra files under the `extra/org.modelica.ssp.something` sub-directory.]_

Annotations are intended to allow structured extensions of the FMI XML files, without creating conflicting extensions, or leaving ambiguities in interpretation.
All annotations can safely be ignored by implementations that just implement the base FMI standard.

==== Definition of an FMU [[fmiModelDescription]]

This is the root-level schema file and is illustrated in <<system_overview>>.
The figure contains all elements in the schema file.
Data is defined by attributes to these elements.

.fmiModelDescription element.
[[system_overview]]
image::images/schema/fmiModelDescription.png[width=70%]

On the top level, the schema consists of the elements detailed in <<table-schema-fmiModelDescription>>.
_[If an optional element is present and defines a list (such as `<UnitDefinitions>`), the list must have at least one element (such as `<Unit>`).]_

.fmiModelDescription element details.
[[table-schema-fmiModelDescription]]
[cols="1,3",options="header"]
|====
|Element
|Description

|`<ModelExchange>`
|If present, the FMU is based on FMI for Model Exchange (<<fmi-for-model-exchange>>) _[(in other words, the FMU includes the model or the communication to a tool that provides the model, and the environment provides the simulation engine)]_.

|`<CoSimulation>`
|If present, the FMU is based on FMI for Co-Simulation (<<fmi-for-co-simulation>>).

|`<ScheduledExecution>`
|If present, the FMU is based on FMI for Scheduled Execution (<<fmi-for-scheduled-execution>>).

|`<UnitDefinitions>`
|A global list of unit and display unit definitions _[for example, used to convert display units into the units used in the model equations]_.
These definitions are used in the XML element `<ModelVariables>`.

|`<TypeDefinitions>`
|A global list of type definitions that are utilized in `<ModelVariables>`.

|`<LogCategories>`
|A global list of log categories that can be set to define the log information that is supported from the FMU.

|`<DefaultExperiment>`
|Providing default settings for the integrator, such as stop time and relative tolerance.

|`<ModelVariables>`
|The central FMU data structure defining all variables of the FMU that are visible/accessible via the FMU functions.

|`<ModelStructure>`
|Defines the structure of the model.
Especially, the ordered lists of <<output,`outputs`>>, continuous-time <<state,`states`>>, initial unknowns (the unknowns during *Initialization Mode*) and the event indicators are defined here.
For more details on `<ModelStructure>`, see <<ModelStructure>>.
Furthermore, the dependency of the unknowns from the knowns can be optionally defined for <<output,`outputs`>>, continuous-time <<state,`states`>> and initial unknowns.
_[This information can be, for example, used to compute efficiently a sparse Jacobian for simulation, or to utilize the <<input>> / <<output>> dependency in order to detect that in some cases there are actually no algebraic loops when connecting FMUs together]_.
Dependencies for event indicators are not provided.
_[The calculation of derivatives of event indicators is not provided.]_.

|`<Annotations>`
|Optional annotations for the top-level element.

|====

At least one element of `<ModelExchange>`, `<CoSimulation>` or `<ScheduledExecution>` must be present to identify the type of the FMU.
If multiple elements are defined, different types of models are included in the FMU.
The details of these elements are defined in <<fmi-for-model-exchange>>, <<fmi-for-co-simulation>> or <<fmi-for-scheduled-execution>>.

The XML attributes of `<fmiModelDescription>` are:

[cols="1,3",options="header"]
|====
|Attribute
|Description

|`fmiVersion`
|Version of FMI that was used to generate the XML file.
The value for this version is `3.0`.
Future minor revisions are denoted as `3.1`, `3.2` ...

_[During development prototype FMU implementations can indicate compliance with a certain development version based on the tags available at https://github.com/modelica/fmi-standard/tags._
_For example the value for the FMI 3.0 Alpha 2 release is `3.0-alpha.2`.]_

|`modelName`
|The name of the model as used in the modeling environment that generated the XML file, such as `Modelica.Mechanics.Rotational.Examples.CoupledClutches`.

|`instantiationToken`
|The `instantiationToken` is a string that can be used by the FMU to check that the XML file is compatible with the implementation of the FMU.
For this purpose the importing tool must pass the `instantiationToken` from the <<modelDescription.xml>> to the <<fmi3Instantiate>> function call.

|`description`
|Optional string with a brief description of the model.

|`author`
|Optional string with the name and organization of the model author.

|`version`
|Optional version of the model _[for example `1.0`]_.

|`copyright`
|Optional information on the intellectual property copyright for this FMU _[for example `(C) My Company 2011`]_.

|`license`
|Optional information on the intellectual property licensing
for this FMU _[for example `BSD license <license text or link to license>`]_.

|`generationTool`
|Optional name of the tool that generated the XML file.

|`generationDateAndTime`
|Optional date and time when the XML file was generated.
The format is a subset of `dateTime` and should be: `YYYY-MM-DDThh:mm:ssZ` (with one `T` between date and time; `Z` characterizes the Zulu time zone, in other words, Greenwich meantime) _[for example `2009-12-08T14:33:22Z`]_.

|`variableNamingConvention`
|Defines whether the variable names in `<ModelVariables>` and in `<TypeDefinitions>` follow a particular convention.
For the details, see <<variableNamingConvention>>.
Currently standardized are:

`= flat`: A list of strings (the default).

`= structured`: Hierarchical names with `.` as hierarchy separator, and with array elements and derivative characterization.

|====

==== Definition of Capability Flags [[common-capability-flags]]

The elements `<ModelExchange>`, `<CoSimulation>` and `<ScheduledExecution>` contain attributes representing capability flags describing which optional functionalities the FMU supports.

The following table contains capability flags common to all three interface types.
[cols="1,1",options="header"]
|====
|Attribute
|Description

|`needsExecutionTool`
|If `true`, a tool is needed to execute the model and the FMU just contains the communication to this tool.
_[Typically, this information is only utilized for information purposes._
_For example, when loading an FMU with `needsExecutionTool = true`, the environment can inform the user that a tool has to be available on the computer where the model is instantiated._
_The name of the tool can be taken from attribute `generationTool` in `<fmiModelDescription>`.]_

|`canBeInstantiatedOnlyOncePerProcess`
|This flag indicates cases (especially for embedded code), where only one instance per FMU is possible (multiple instantiation is default = `false`; if multiple instances are needed and the flag `canBeInstantiatedOnlyOncePerProcess = true`, the FMUs must be instantiated in different processes).

|[[canGetAndSetFMUState,`canGetAndSetFMUState`]]`canGetAndSetFMUState`
|If `true`, the environment can inquire the internal FMU state and can restore it.
That is, functions <<fmi3GetFMUState>>, <<fmi3SetFMUState>>, and <<fmi3FreeFMUState>> are supported by the FMU.

|`canSerializeFMUState`
|If `true`, the environment can serialize the internal FMU state, in other words, functions <<fmi3SerializedFMUStateSize>>, <<fmi3SerializeFMUState>>, <<fmi3DeSerializeFMUState>> are supported by the FMU.
If this is the case, then flag `canGetAndSetFMUState` must be `true` as well.

|`providesDirectionalDerivatives`
|If `true`, the directional derivative of the equations can be computed with <<fmi3GetDirectionalDerivative>>.

|`providesAdjointDerivatives`
|If `true`, the adjoint derivatives of the equations can be computed with <<fmi3GetAdjointDerivative>>.

|`providesPerElementDependencies`
|The FMU is able to provide detailed dependency information at run time using <<fmi3GetNumberOfVariableDependencies>> and <<fmi3GetVariableDependencies>>.

|`maxOutputDerivativeOrder`
|The FMU is able to provide <<derivative,`derivatives`>> of <<output,`outputs`>> with maximum order.
Calling of `fmi3GetOutputDerivatives` is allowed up to the order defined by `maxOutputDerivativeOrder`.
This flag is ignored in `ModelExchange`.

|`providesIntermediateUpdate`
|The FMU supports *Intermediate Update Mode* and will call <<fmi3CallbackIntermediateUpdate>>, if provided.
This flag is ignored in `ModelExchange`.

|[[recommendedIntermediateInputSmoothness,`recommendedIntermediateInputSmoothness`]]`recommendedIntermediateInputSmoothness`
|A value of latexmath:[k] with latexmath:[k>0] signals to the co-simulation algorithm, that it is beneficial for the solver to receive intermediate inputs that are k-time continuously differentiable (latexmath:[C^k]) on the current communication interval.
latexmath:[k=0] means continuous (see <<smoothness>>). +
This flag is not supported in `ModelExchange`.

|====

==== Definition of Units

In this section, the units of the variables are defined.

_[Unit support is important for technical systems since otherwise it is very easy for errors to occur._
_Unit handling is a difficult topic, and there seems to be no method available that is really satisfactory for all applications, such as unit check, unit conversion, unit propagation or dimensional analysis._
_In FMI, a pragmatic approach is used that takes into account that every software system supporting units has potentially its own specific technique to describe and utilize units.]_

Element `<fmiModelDescription><UnitDefinitions>` is defined as:

image::images/schema/UnitDefinitions.png[width=90%]

It contains one or more `Unit` definitions.
If no units are defined, element `<UnitDefinitions>` must not be present.

The `name` of a `Unit` must be unique with respect to all other `<Unit>` elements.
If a variable is associated with a `Unit`, the value passed to `fmi3Set{VariableType}` (resp. retrieved with `fmi3Get{VariableType}`) has this unit.
_[The purpose of the name is to uniquely identify a unit and, for example, use it to display the unit in menus or in plots._
_Since there is no standard to represent units in strings, and there are different ways how this is performed in different tools, no specific format for the string representation of the unit is required.]_

The `Unit` definition consists of the exponents of the 7 SI base units `kg`, `m`, `s`, `A`, `K`, `mol`, `cd`, the exponent of the SI derived unit `rad`, and optionally a `factor` and an `offset`.
_[The additional `rad` base unit helps to handle the often occurring quantities in technical systems that depend on an angle.]_

image::images/schema/BaseUnit.png[width=50%, align="center"]

A value latexmath:[v_{unit}] in `Unit` is converted to the base unit latexmath:[v_{base}] by the equation

[latexmath]
++++
v_{base} = \texttt{factor} * v_{unit} + \texttt{if relativeQuantity then 0 else offset}
++++

_[For example, if_ latexmath:[{p_{\mathit{bar}}}] _is a pressure value in unit `bar`, and_ latexmath:[{p_{\mathit{Pa}}}] _is the pressure value in `<BaseUnit>`, then_

[latexmath]
++++
{p_{\mathit{Pa}} = 10^5 p_{\mathit{bar}}}
++++

_and therefore, `factor = 1.0e5` and `offset = 0.0`._

_In the following table several unit examples are given._
_Note that if in column `exponents` the definition_ latexmath:[\frac{kg \cdot m^2}{s^2}] _is present, then the attributes of `<BaseUnit>` are  `kg=1, m=2, s=-2`._

[cols="1,1,1,1,1"]
|====
.2+|Quantity
.2+|Unit.name +
(examples)

3+|Unit.BaseUnit
|exponents
|factor
|offset

|_Torque_
|`N.m`
|latexmath:[{kg \cdot m^2 / s^2}]
|`1.0`
|`0.0`

|_Energy_
|`J`
|latexmath:[{kg \cdot m^2 / s^2}]
|`1.0`
|`0.0`

|_Pressure_
|`bar`
|latexmath:[{\frac{kg}{m \cdot s^2}}]
|`1.0e5`
|`0.0`

|_Angle_
|`deg`
|`rad`
|`0.01745329251994330 (= pi/180)`
|`0.0`

|_Angular velocity_
|`rad/s`
|`rad/s`
|`1.0`
|`0.0`

|_Angular velocity_
|`rpm`
|`rad/s`
|`0.1047197551196598 (= 2*pi/60)`
|`0.0`

|_Frequency_
|`Hz`
|`rad/s`
|`6.283185307179586 (= 2*pi)`
|`0.0`

|_Temperature_
|`&#176;F`
|`K`
|`0.5555555555555556 (= 5/9)`
|`255.3722222222222 (= 273.15-32*5/9)`

|_Per cent by length_
|`%/m`
|`1/m`
|`0.01`
|`0.0`

|_Parts per million_
|`ppm`
|`1`
|`1.0e-6`
|`0.0`

|_Length_
|`km`
|`m`
|`1000`
|`0.0`

|_Length_
|`yd`
|`m`
|`0.9144`
|`0.0`
|====

_Note that `Hz` is typically used as `Unit.name` for a frequency quantity, but it can also be used as `<DisplayUnit>` for an angular velocity quantity (since `revolution/s`).]_

_The `<BaseUnit>` definitions can be utilized for different purposes (the following application examples are optional and a tool may also completely ignore the `Unit` definitions):_

Unit check when connecting variables of different FMUs::
+
_When only one of <<input>> `v2` and <<output>> `v1`, connected with equation `v2 = v1`, defines a `<BaseUnit>` element, `fmi3Get{VariableType}` must be used to get the value of `v1`  to then set it with `fmi3Set{VariableType}` for `v2`._
+
_When two variables v1 and v2 are connected and for both of them `<BaseUnit>` elements are defined, then they must have identical exponents of their `<BaseUnit>`._
_If `factor` and `offset` are also identical, again the connection equation `v2 = v1` holds._
_If `factor` and `offset` are not identical, the tool may either trigger an error or, if supported, perform a conversion; in other words, use the connection equation (in this case the `relativeQuantity` of the `<TypeDefinition>`, see below, has to be taken into account in order to determine whether `offset` shall or shall not be utilized):_
+
`factor(v1) * v1 + offset(v1) = factor(v2) * v2 + offset(v2)`
+
_As a result, wrong connections can be detected (for example, connecting a force with an angle-based variable would trigger an error) and conversions between, say, US and SI units can be either automatically performed or, if not supported, an error is triggered as well._
+
_[Note that this approach is not satisfactory for variables belonging to different quantities that have, however, the same `<BaseUnit>`, such as quantities `Energy` and `Torque`, or `AngularVelocity` and `Frequency`._
_To handle such cases, quantity definitions have to be taken into account (see `<TypeDefinitions>`) and quantity names need to be standardized.]_
+
_This approach allows a general treatment of units, without being forced to standardize the grammar and allowed values for units (for example, in FMI 1.0, a unit could be defined as `N.m` in one FMU and as `N*m` in another FMU, and a tool would have to reject a connection, since the units are not identical._
_In FMI 2.0, the connection would be accepted, provided both elements have the same `<BaseUnit>` definition)._

Dimensional analysis of equations::
+
_In order to check the validity of equations in a modeling language, the defined units can be used for dimensional analysis, by using the `<BaseUnit>` definition of the respective unit._
_For this purpose, the `<BaseUnit>` `rad` has to be treated as `1`._
_Example:_
+
[latexmath]
++++
\begin{align*}
J \cdot \alpha = \tau \rightarrow [kg.m^2]*[rad/s^2] = [kg.m^2/s^2] & \quad \text{// o.k. ("rad" is treated as "1")} \\
J \cdot \alpha = f \rightarrow [kg.m^2]*[rad/s^2] = [kg.m/s^2] & \quad \text{// error, since dimensions do not agree}
\end{align*}
++++

Unit propagation::
+
_If unit definitions are missing for variables, they might be deduced from the equations where the variables are used._
_If no unit computation is needed, `rad` is propagated._
_If a unit computation is needed and one of the involved units has `rad` as a `<BaseUnit>`, then unit propagation is not possible._
_Examples:_
+
- _a = b + c, and `Unit` of c is provided, but not `Unit` of a and b:_ +
_The Unit definition of `c` (in other words, `Unit.name`, `<BaseUnit>`, `<DisplayUnit>`) is also used for `a` and `b`._
_For example, if BaseUnit(c) = `rad/s`, then BaseUnit(a) = BaseUnit(b) = `rad/s`._
+
- _a = b*c, and `Unit` of a and of c is provided, but not `Unit` of b:_ +
_If `rad` is either part of the `<BaseUnit>` of `a` and/or of `c`, then the `<BaseUnit>` of `b` cannot be deduced (otherwise it can be deduced)._
_Example: If `BaseUnit(a) = kg.m/s2` and `BaseUnit(c) = m/s2`, then the `BaseUnit(b) can be deduced to be `kg`._
_In such a case `Unit.name` of b cannot be deduced from the `Unit.name` of `a` and `c`, and a tool would typically construct the `Unit.name` of `b` from the deduced `<BaseUnit>`._

_]_

A `<Unit>` can contain any number of `<DisplayUnit>` elements.

image::images/schema/DisplayUnit.png[width=60%, align="center"]

A `<DisplayUnit>` is defined by `name`, `factor`, `offset`, and `inverse`.
The attribute `name` must be unique with respect to all other names of the `<DisplayUnit>` definitions of the same `Unit`.
_[Different `Unit` elements may have the same `<DisplayUnit>` names]._

A value latexmath:[v_{unit}] in `Unit` is converted to a value latexmath:[v_{display}] in `DisplayUnit` by the equation:

[latexmath]
++++
v_{display} =
\left\{\begin{array}{ll}
\texttt{factor} *          v_{unit}  + \texttt{offset} &\text{if} \; \texttt{inverse == false} \\
\texttt{factor} * \frac{1}{v_{unit}} + \texttt{offset} &\text{if} \; \texttt{inverse == true}
\end{array}\right.
++++

_[`offset` is needed for temperature units like `F` (Fahrenheit), `inverse` for inverse display units like `mpg` (miles per gallon) or `S` (Siemens)._

_For example, if latexmath:[{T_K}] is the temperature value of `Unit.name` (in `K`) and latexmath:[{T_F}] is the temperature value of `<DisplayUnit>` (in `&#176;F`), then_

[latexmath]
++++
T_F = (9/5) * (T_K - 273.15) + 32
++++

_and therefore, `factor = 1.8 (=9/5)` and `offset = -459.67 (= 32 - 273.15*9/5)`._

_Both the `DisplayUnit.name` definitions as well as the `Unit.name` definitions are used in the variable elements._

_Example of a definition:_

[source, xml]
----
include::examples/unit_definition.xml[tags=UnitDefinitions]
----
_]_

==== Definition of Types [[definition-of-types]]

Element `<fmiModelDescription><TypeDefinitions>` is defined as:

image::images/schema/TypeDefinitions.png[width=70%, align="center"]

This element consists of a set of `<TypeDefinition>` elements according to schema `fmi3TypeDefinition` in file `fmi3Type.xsd`.
Each `<TypeDefinition>` has attributes `name` and `description`.
Attribute `name` must be unique with respect to all other elements of the `<TypeDefinitions>` list.
Furthermore, `name` of a `<TypeDefinition>` must be different to all `name` attributes of variables _[if the same names would be used, then this would nearly always give problems when importing the FMU in an environment such as Modelica, where a type name cannot be used as instance name]_.

Additionally, one variable type element must be present.
Each variable type has its own attributes which can be consulted in the schema.
<<figure-schema-Float64Type>>, <<figure-schema-Int32Type>>, <<figure-schema-BooleanType>>, <<figure-schema-BinaryType>>, and <<figure-schema-EnumerationType>>, are representative examples.

.Float64Type element.
[[figure-schema-Float64Type]]
image::images/schema/Float64Type.png[width=60%, align="center"]

.Int32Type element.
[[figure-schema-Int32Type]]
image::images/schema/Int32Type.png[width=50%, align="center"]

.BooleanType element.
[[figure-schema-BooleanType]]
image::images/schema/BooleanType.png[width=50%, align="center"]

.BinaryType element.
[[figure-schema-BinaryType]]
image::images/schema/BinaryType.png[width=70%, align="center"]

.EnumerationType element.
[[figure-schema-EnumerationType]]
image::images/schema/EnumerationType.png[width=75%, align="center"]

The type elements are referred to in variable elements to declare their type.
_[The alternative would be to define a type per variable._
_However, this would lead to a situation where, e.g., the definition of a `Torque` type would have to be repeated over and over.]_
The attributes and elements have the following meaning:

[cols="1,5",options="header"]
|====
|Attribute or Elements
|Description

|`quantity`
|Physical quantity of the variable.
_[For example, `Angle`, or `Energy`._
_The quantity names are not standardized]_

|`unit`
|Unit of the variable defined with attribute `name` of `<UnitDefinitions><Unit>` that is used for the model equations.
_[For example, `N.m`: in this case a `Unit.name = `N.m` must be present under `<UnitDefinitions>`.]_
_[Note that for variables that are without a unit, the element should not have a `unit` attribute.]_
_[Giving an empty string as a `unit` attribute specifies a valid unit that needs to be defined among the unit definitions.]_

|[[displayUnit,`displayUnit`]] `displayUnit`
|Default display unit.
The conversion to the `unit` is defined with the element `<fmiModelDescription><UnitDefinitions>`.
If the corresponding `displayUnit` is not defined under `<UnitDefinitions><Unit><DisplayUnit>`, then `displayUnit` is ignored.
It is an error if `displayUnit` is defined as variable type element, but `unit` is not, or unit is not defined under `<UnitDefinitions><Unit>`.

|`mimeType`
|Indicates the type of data passed as a binary.
Defaults to `application/octet-stream`, which is unspecific.
Implementations can use this information to provide guidance to the user about valid/useful connections.

|`relativeQuantity`
|If this attribute is `true`, then the `offset` of `BaseUnit` and `displayUnit` must be ignored.
_[For example, 10 degree Celsius = 10 Kelvin if `relativeQuantity = true` and not 283.15 Kelvin.]_

|`min`
|Minimum value of variable (variable value latexmath:[\geq] `min`).
If not defined, the minimum is the largest negative number that can be represented on the machine.
The `min` definition is information from the FMU to the environment defining the region in which the FMU is designed to operate, see also comment after this table.

|`max`
|Maximum value of variable (variable value latexmath:[\leq] `max`).
If not defined, the maximum is the largest positive number that can be represented on the machine.
The `max` definition is information from the FMU to the environment defining the region in which the FMU is designed to operate, see also comment after this table.

|`nominal`
|Nominal value of variable.
If not defined and no other information about the nominal value is available, then `nominal = 1` is assumed. +
_[The nominal value of a variable can be, for example, used to determine the absolute tolerance for this variable as needed by numerical algorithms:_ +
`absoluteTolerance = nominal * tolerance * 0.01` +
_where `tolerance` is, for example, the relative tolerance defined in <<DefaultExperiment>>.]_

|`unbounded`
|If `true`, indicates that during time integration, the variable gets a value much larger than its nominal value `nominal`.
_[Typical examples are the monotonically increasing rotation angles of crank shafts and the longitudinal position of a vehicle along the track in long distance simulations._
_This information can, for example, be used to increase numerical stability and accuracy by setting the corresponding bound for the relative error to zero (relative tolerance = 0.0), if the corresponding variable is a continuous <<state>> variable.]_

|`Item`
|`<Item>` of an enumeration has a sequence of `name` and `value` pairs.
The values can be any integer number but must be unique within the same enumeration (in order that the mapping between `name` and `value` is bijective).
An `<Enumeration>` element must have at least one `<Item>`.
|====

_[Attributes `min` and `max` can be set for variables of numeric type or `<Enumeration>`._
_The question is how `fmi3Set{VariableType}`, `fmi3Get{VariableType}` shall utilize this definition._
_There are several conflicting requirements:_ +
_Avoiding forbidden regions (for example, if `u` is an <<input>> and "sqrt(u)" is computed in the FMU, `min = 0` on `u` shall guarantee that only values of `u` in the allowed regions are provided)._
_Numerical algorithms (solvers or optimizers) do not guarantee constraints._
_If a variable is outside of the bounds, the solver tries to bring it back into the bounds._
_As a consequence, calling `fmi3Get{VariableType}` during an iteration of such a solver might return values that are not in the defined min/max region._
_After the iteration is finalized, it is only guaranteed that a value is within its bounds up to a certain numerical precision._ +
_During system creation and prototyping, checks on min/max should be performed._
_For maximum performance on production or real-time systems, these checks might not be performed._ +
_The approach in FMI is therefore that min/max definitions are an information from the FMU to the environment defining the region in which the FMU is designed to operate._
_In any case, it is expected that the FMU handles variables appropriately where the region definition is critical._
_For example, dividing by an <<input>> (so the <<input>> should not be in a small range of zero) or taking the square root of an <<input>> (so the <<input>> should not be negative) may either result in <<fmi3Error>>, or the FMU is able to handle this situation in other ways._

_If the FMU is generated so that min/max shall be checked whenever meaningful (for example, for debug purposes), then the following strategy should be used:_

_If `fmi3Set{VariableType}` is called violating the min/max attribute settings of the corresponding variable, the following actions are performed:_

- _On a <<fixed>> or <<tunable>> <<parameter>> <<fmi3Discard,`fmi3Status == fmi3Discard`>> is returned._
- _On an <<input>>, the FMU decides what to return (If no computation is possible, it could return <<fmi3Discard,`fmi3Status == fmi3Discard`>>, in other situations it may return <<fmi3Warning>> or <<fmi3Error>>, or <<fmi3OK>>, if it is uncritical)._

_If an FMU defines min/max values for integer types and `<Enumeration>` variables (<<local>> and <<output>> variables), then the expected behavior of the FMU is that `fmi3Get{VariableType}` functions return values in the defined range._

_If an FMU defines min/max values for numeric types, then the expected behavior of the FMU is that `fmi3Get{VariableType}` returns values at the solution (accepted steps of the integrators) in the defined range with a certain uncertainty related to the tolerances of the numerical algorithms.]_

===== Clock Type Definition [[clock-type-definition]]

Clocks are integrated in the element `<fmiModelDescription><ModelVariables>` as a variable element with the base type `fmi3Clock`.
The variable sub type `fmi3Clock` provides additional attributes for defining <<clock,`clocks`>>.

[cols="1,5",options="header"]
|====
|Attribute
|Description

|`clockType`

a|
[[clockType,`clockType`]]
The type of <<clock,`clocks`>> is defined based on the mandatory attribute `clockType` with the following two values:

[[synchronousTime,`synchronousTime`]]
`= synchronousTime` is used, if the properties of the <<clock>> adhere to synchronous clock theory.

[[communicationPoint,`communicationPoint`]]
`= communicationPoint` <<clock,`clocks`>> define sampling points (i.e. communication points) for the variables of model partitions.

It is not allowed to include <<clock,`clocks`>> of different `clockType` in one FMU.
`clockType` is a required attribute.

|`triggeredBy`
|
[[triggeredBy,`triggeredBy`]]
The optional attribute <<triggeredBy>> is used to define a tick relationship from an <<outputClock>> to an <<periodic,aperiodic>> <<inputClock>> (see <<clock-relationships-for-communication-point-clocks>>).

Only <<clock,`clocks`>> with <<causality>> = <<input>> can have this attribute.
It is not allowed to combine <<outputClock,`output clocks`>> with <<periodic>> or <<strict>> <<periodic>> <<inputClock,`input clocks`>> based on <<triggeredBy>>.


|`priority`
|The <<clock,`clocks`>> are ordered descending based on their priorities.
The priority of a <<clock>> has to be defined via the unsigned integer attribute `priority` - smaller values have a higher priority.
It is possible to define multiple <<clock,`clocks`>> with the same priority.
No ordering is defined for <<clock,`clocks`>> of the same priority.
If a computational order information is needed, different priorities have to be defined.

_[For <<periodic>> <<clock,`clocks`>> it is recommended to derive the priorities based on a rate monotonic scheduling scheme (smallest period leads to highest priority, that is, has the smallest priority value.]_

`priority` is a required attribute.

|`periodic`
|
[[periodic,`periodic`]]
Clocks can be periodic or aperiodic.
If a <<clock>> is periodic, the attribute `periodic = true`.

`periodic` is an optional attribute.
The default value is `false`.

|`strict`
|
[[strict,`strict`]]
If a <<periodic>> <<clock>> is strictly periodic, the `strict` attribute is `true`.
If the optional attribute `strict` is set to `true`, then the FMU and the simulation algorithm have to respect the predefined interval and offset.
If the optional attribute `strict` is set to `false` another interval or offset can be used, derived from the current simulation setup.

`strict` is an optional attribute.
The default value is `false`.
The FMU exporter is not allowed to set `strict` to `true` if `periodic = false`.

|`intervalCounter`, `shiftCounter`, `resolution`
|The interval of <<output>> or <<input>> <<periodic>> <<clock,`clocks`>> is a rational number defined with unsignedLong valued `intervalCounter` and `resolution` attributes:

`interval = intervalCounter / resolution`.

The initial tick of <<periodic>> <<clock,`clocks`>> may be delayed by an offset.
The offset can be defined by the `unsignedLong` valued `shiftCounter` attribute (default value 0).

This results in the actual

`offset = shiftCounter / resolution`.

The time `t` of the `n`th activation of a periodic clock is therefore computed as

`t = (shiftCounter + n * intervalCounter) / resolution`.

More information about clock intervals:
 <<periodic-clock-ticks>>.

The attributes `intervalCounter`, `shiftCounter` and `resolution` are interval <<start>> values for <<periodic>> <<clock,`clocks`>> and must not be used together with <<periodic,aperiodic>> <<clock,`clocks`>>.
If `strict = true` it is required to provide values for `intervalCounter` and `resolution`.

`intervalCounter` and `resolution` have no default value.
|====

[#TypeDefinitions]
image::images/schema/ClockType.png[width=55%, align="center"]

==== Definition of Log Categories [[definition-of-log-categories]]

Element `<fmiModelDescription><LogCategories>` is defined as:

image::images/schema/LogCategories.png[width=80%, align="center"]

`<LogCategories>` defines an unordered set of category strings that can be utilized to define the log output via function <<logMessage>>, see <<FMUStateSetable>>.
A tool is free to use any `normalizedString` for a category value.
The `name` attribute of `<Category>` must be unique with respect to all other elements of the `<LogCategories>` list.

<<table-standard-categories>> shows the standardized names for `<Category>`.
These names should be used if a tool supports the corresponding log category.
If a tool supports one of these log categories and wants to expose it, then an element `<Category>` with this name should be added to `<LogCategories>`.
_[To be clear, only the `<Category>` names listed under `<LogCategories>` in the XML file are known to the importer of the FMU.]_

.Standard names for `<Category>`.
[[table-standard-categories]]
[cols="1,3",options="header"]
|====
|Category
|Description

|`logEvents`
|Log all events (during initialization and simulation).

|`logSingularLinearSystems`
|Log the solution of linear systems of equations if the solution is singular (and the tool picked one solution of the infinitely many solutions).

|`logNonlinearSystems`
|Log the solution of nonlinear systems of equations.

|`logDynamicStateSelection`
|Log the dynamic selection of <<state,`states`>>.

|`logStatusWarning`
|Log messages when returning <<fmi3Warning>> status from any function.

|`logStatusDiscard`
|Log messages when returning <<fmi3Discard>> status from any function.

|`logStatusError`
|Log messages when returning <<fmi3Error>> status from any function.

|`logStatusFatal`
|Log messages when returning <<fmi3Fatal>> status from any function.

|`logAll`
|Log all messages.
|====

The optional attribute `description` shall contain a description of the respective log category.
_[Typically, this string can be shown by a tool if more details for a log category are presented.]_

_[This approach to define `<LogCategories>` has the following advantages:_

. _A simulation environment can present the possible log categories in a menu and the user can select the desired one (in the FMI 1.0 approach, there was no easy way for a user to figure out from a given FMU what log categories could be provided)._ +
_Note that since element `<LogCategories>` is optional, an FMU does not need to expose its log categories._

. _The log output is drastically reduced, because via <<fmi3SetDebugLogging>> exactly the categories are set that shall be logged and therefore the FMU only has to print the messages with the corresponding categories to the <<logMessage>> function._
_In FMI 1.0, it was necessary to provide all log output of the FMU to the <<logMessage>> and then a filter in the <<logMessage>> could select what to show to the end-user._
_The approach introduced in FMI 2.0 is therefore much more efficient.]_

==== Definition of a Default Experiment [[DefaultExperiment]]

Element `<fmiModelDescription><DefaultExperiment>` is defined as:

image::images/schema/DefaultExperiment.png[width=60%, align="center"]

`<DefaultExperiment>` consists of the optional default start time, stop time, relative tolerance, and step size for the first simulation run.
A tool may ignore this information.
However, it is convenient for a user that `startTime`, `stopTime`, `tolerance` and `stepSize` have already a meaningful default value for the model at hand.
Furthermore, for Co-Simulation FMUs the `stepSize` defines the preferred <<communicationStepSize>>.

==== Definition of Terminals and Icons [[fmiTerminalsAndIcons]]

This is the root element of the XML file `icons/terminalsAndIcons.xml`, and is defined as:

.Overview of fmiTerminalsAndIcons.
[[terminals_and_icons_overview]]
image::images/schema/fmiTerminalsAndIcons.png[width=60%, align="center"]

On the top level, the schema consists of the following elements (see <<terminals_and_icons_overview>>).

[cols="1,3",options="header"]
|====
|Element
|Description

|`<GraphicalRepresentation>`
|If present, contains information for importers of FMUs to draw graphical representations of the FMU in a system view.

|`<Terminals>`
|If present, this allows combining input and output variables into logical groups to ease connections on a system level.
|====

===== Definition of a Graphical Representation [[graphicalRepresentation]]


====== Overview

The graphical representation of the FMU and terminals are needed in order to more easily comprehend the meaning of connected FMUs and to help an importing tool to display the terminals and the FMU icon in the way the exporter intended.

The graphical representation is fully optional.
The graphical representation of terminals is separate from the terminal definitions in the `<Terminals>` element.

There are two optional elements in the `<GraphicalRepresentation>`:

. The `<CoordinateSystem>` defines the extent of the whole icon (graphical items may exceed that rectangle).
. The `<Icon>` defines an image source for the FMU.


image::images/schema/GraphicalRepresentation.png[width=100%, align="center"]

====== CoordinateSystem

image::images/schema/CoordinateSystem.png[width=70%, align="center"]

The `<CoordinateSystem>` element and its defined extent is used as reference for other graphical items.
It also provides a scaling factor to millimeter.

The coordinate system is defined by the coordinates of two points, the lower left (`x1`, `y1`) corner and the upper right (`x2`, `y2`) corner, where the coordinates of the first point shall be less than the coordinates of the second point _[a first quadrant coordinate system]_.
The x-axis is directed to the right, the y-axis is directed upwards.

_[The exporting tool should define how the coordinate system unit relates to mm display or print out size._
_However, an importing tool might choose to use the factor from the default coordinate system extent to the actual coordinate system extent to calculate a scaling factor, to match the default icon size in the importing tool._

_The area defined by the coordinate system is suggested to be used as "clickable icon size" in other tools._
_A `<Terminal>` might be placed outside of this area, so the visible bounding box has to be determined by the importing tool.]_

The coordinate system default is `x1=-100, y1=-100, x2=100, y2=100`.
This extent is used if the `<CoordinateSystem>` element is missing.
The default `suggestedScalingFactorTo_mm` is 0.1.
So the default coordinate system display size should be 20 mm width and 20 mm height.

The FMU icon and all graphical representations provide the position and extent with the attributes `x1`, `y1`, `x2`, `y2`.
The values of these attributes directly relate to this coordinate system and are not normalized.
Flipping of the FMU icon or a terminal can be realized by setting its attributes `x2 < x1` or `y2 < y1` without changing the coordinate system.

====== Icon

image::images/schema/Icon.png[width=40%, align="center"]

The extent and position of the FMU icon are defined in the `<Icon>` element.
The optional image file of the FMU icon is placed at the path `icons/icon.png` in the ZIP archive of the FMU.
The terminals should not be visible in the image.
Optionally an SVG file can be provided if also the PNG file is present.
This enables high quality rendering and printing in importing tools.
This SVG file has to be placed at the path `icons/icon.svg` in the ZIP archive.

The point (`x1`, `y1`) maps to the left lower corner of the PNG image or SVG viewport.
The point (`x2`, `y2`) maps to the right upper corner of the PNG image or SVG viewport.

====== Placement, Extent, and Painting Order of Graphical Items

image::images/GraphicalRepresentation.svg[width=70%, pdfwidth=70%, align="center"]

The clickable icon size is defined by the `<CoordinateSystem>` element.
The FMU icon itself may exceed this extent (or bounding box).
The bounding box of the terminals is given by the extent in the terminals element.
Their location is neither limited to the extent of the icon nor the extent of the coordinate system.
_[An importing tool has to determine the outer bounding box enclosing all graphical items.]_

Transparent SVG or PNG files are allowed and wanted.
The order of the elements in the XML file defines the order of painting.
The first element in the `<TerminalGraphicalRepresentation>` is painted first and therefore behind the others, the last element is painted on top of the others and because of that in front of them.
_[So the FMU icon should be placed first in the XML file, terminal below.]_

===== Definition of Terminals

====== Overview

Terminals are fully optional and can be ignored by any importing tool.

Definition `<Terminal>`: A terminal is...

* a structured interface for connections to other models
* intended to be used for signal flow between models, parameter propagation, and compatibility checks of the model configuration
* a sequence of references to variables with connection meta data

Predefined rules for variable matching in a connection are given in <<table-predefined-matching-rules>>.
Predefined variable kinds are used to describe how the member variables have to be handled.
Domain specific connection rules, terminals and their member variables can be provided by other standards.

_[Co-simulation errors are not addressed by the terminals._
_The co-simulation algorithm has to be chosen and implemented by the importing tool._
_Features that might be required for specific co-simulation algorithms had to be implemented by the FMU exporting tool._

_Algebraic loops in systems of connected Model Exchange FMUs are not addressed or resolved by the terminals._
_It is not required that the <<causality>> of the terminal member variables in connected terminals match._

_The SSP standard refers to a `connectorKind`._
_This `connectorKind` is not related to the `terminalKind` or `variableKind` described in <<section-terminals>> and <<section-terminalvars>>.]_

[[section-terminals]]
====== Terminals

Element `<fmiTerminalsAndIcons><Terminals>` is defined as:

image::images/schema/Terminals.png[width=80%, align="center"]

All instances of `<Terminal>` have the type `fmi3Terminal` and are listed in the `<Terminals>` sequence.

The normalized string attribute `name` of the `<Terminal>` element is the instance name of the terminal.
The terminal name must be unique on each level.
//_[The terminal name may contain dots, to enable structured terminals.]_

The normalized string attribute `matchingRule` describes the rules for variable matching in a connection.
As detailed in <<table-predefined-matching-rules>>, there are three predefined matching rules: plug, bus, and sequence.
Other standards may define new matching rules.
In order to avoid ambiguities and conflicts, rule names must follow the reverse domain notation of a domain that is controlled by the entity defining the semantics and content of the additional entries.
The rule names beginning with `org.modelica` and `org.fmi-standard` are explicitly reserved for use by MAP FMI-defined layered standards.

There is a sequence of terminal member variables, terminal stream member variables, nested terminals, and an optional `<TerminalGraphicalRepresentation>` element in the `<Terminal>` element.
The member variables are the exchanged variables.
The type of the nested terminals is `fmi3Terminal`, and they can be used to implement structured terminals.

.Predefined matching rules.
[#table-predefined-matching-rules]
[cols="1,3",options="header"]
|====
|`matchingRule`
|Description

[[plug,`plug`]]
|`plug`
|Matching of the variables is based on `memberName`.
An importing tool should connect terminals only if all member variables are present and match.

[[bus,`bus`]]
|`bus`
|Matching of the variables is based on `memberName`.
An importing tool may connect terminals if some or no terminal member variables are present.

[[sequence,`sequence`]]
|`sequence`
|Matching of the variables is based on the order of the terminal member variables.
An importing tool should connect terminals only if the number of member variables matches.

|====

The normalized string `terminalKind` is an optional attribute.
Other standards may define terminal kinds.
It is intended that the `terminalKind` is used to define domain specific member variable sequences, member names and order, or high level restrictions for connections.

_[Other terminal kinds should refer to the predefined `matchingRule`._
_Vendor specific terminal kinds should start with `_vendorName` or `_toolName` to avoid namespace clashes._

_Examples for `terminalKind`: `StandardXXX_Mechanical_Translational`, `Modelica.Mechanics.Translational.Interfaces.Flange_a`, `vendorNameA_customTypeA`, `_vendorNameB_customLibrary_customTypeB`._

_The structured naming convention of the `<ModelVariables>` is independent from the terminal names and member variable names._

_A tool may choose to connect terminals with a different or unknown `terminalKind`, if the `matchingRule` matches.]_

[[section-terminalvars]]
====== Terminal Member Variable

The `<TerminalMemberVariable>` is defined as:

image::images/schema/TerminalMemberVariable.png[width=70%, pdfwidth=50%, align="center"]

The normalized string `variableName` is used to identify the terminal member variable in the element `<ModelVariables>`.
The information about minimum, maximum, and nominal values is available in there.

One variable can be part of several terminals.

If the `matchingRule` `plug` and `bus` are used, then the normalized string `memberName` is used for member variable matching.
So the `memberName` attribute is required for `plug` and `bus` and it has to be unique for a terminal.
The `memberName` is not required for `matchingRule` `sequence`.

The normalized string `variableKind` is used to provide general information about the variable.
This information defines how the connection of this variable has to be implemented (e.g. Kirchhoff's current law or common signal flow).

The predefined `variableKind` are:
[cols="1,3",options="header"]
|====
|`variableKind`
|Description

[[signal,`signal`]]
|`signal`
|The values in connected terminals are intended to be equal.
Restricted to <<input>> and <<output>>, <<parameter>> and <<calculatedParameter>>.
_[Example: Signal flow, parameter propagation, equality checks]_

[[inoutflow,`inflow/outflow`]]
|`inflow` / `outflow`
|Variables which fulfill Kirchhoff's current law.
Restricted to <<input>> and <<output>>, <<parameter>> and <<calculatedParameter>>.
_[Example: Electric current]_
|====

_[The suggested variable naming scheme for the structured naming convention is <ModelVariable name> = <terminalName>.<memberName>._

_Not all `<ModelVariables>` which have the prefix "<terminalName>." are a member variable, and there may exist member variables which don't have this prefix._

_Example 1 (suggested scheme): <ModelVariable name> is `portA.U`, <terminalName> is `portA`, <memberName> is `U`._

_Example 2 (suggested scheme): <ModelVariable name> is `hierarchConn.innerConn.U`, <outer terminal name> is `hierarchConn`, <inner terminal name> is `innerConn`, <memberName> is `U`._

_Example 3 (no prefix): <ModelVariable name> is `u`, <terminalName> is `portA`, <memberName> is `u`._

_Example 4 (prefix but not a member): <ModelVariable name> is `portA.u`, there is a terminal with <terminalName> `portA`, but this variable is not a terminal member._

_The suggested variable naming scheme for the non-structured naming convention is: <ModelVariable name> = <memberName>_

_Matching is not restricted by <<variability>>, <<causality>> or variable type._
_Example: A <<fixed>> variable may be connected to a <<tunable>> variable, a variable of type `fmi3Float64` may be connected to a variable of type `fmi3Int32`._
_However, it is recommended that the variable types and variabilities are equal._

_The `matchingRule` refers to the `<TerminalMemberVariable>` on the same level only._
_Nested terminals can have different `matchingRule`s._

_There is no special handling of <<derivative,`derivatives`>>._
_If a <<derivative>> is a terminal member variable then it is considered as normal member variable._
_However, if a <<derivative>> of a terminal member variable is not terminal member, then this <<derivative>> information may be used by an importing tool.]_

====== Terminal Stream Member Variable

The `<TerminalStreamMemberVariable>` is defined as:

image::images/schema/TerminalStreamMemberVariable.png[width=80%, pdfwidth=60%, align="center"]

This element is used for variables which fulfill the balance equation for transported quantities.
It is restricted to <<input>> and <<output>>, <<parameter>> and <<calculatedParameter>>.

The Stream concept is described in the appendix D.3 of the Modelica specification.
Only one terminal member variable with the `variableKind` `inflow` or `outflow` per terminal is allowed, if a `<TerminalStreamMemberVariable>` is present.
_[More sophisticated structures can be implemented using hierarchical terminals.]_

The attribute `inStreamVariableName` and `outStreamVariableName` are used to identify the `<ModelVariables>`.
If the referenced model variables are arrays, then the size of the `inStreamVariableName` and `outStreamVariableName` has to be equal.
A terminal may have more than one `<TerminalStreamMemberVariable>`.
The `inStreamMemberName` and `outStreamMemberName` describe the terminal member name for matching purposes, similar to the `memberName` attribute in the `<TerminalMemberVariable>`.

_[An example of use for an array of stream variables is a gas mixture flow._
_The gas composition could be implemented as a mass fraction vector._
_The `outStreamVariableName` refers to_ latexmath:[portA.q_\textit{outStream}\textit{[\]}] _and the `inStreamVariableName` refers to_  latexmath:[portA.q_\textit{inStream}\textit{[\]}] _._
_The `inStreamMemberName` and `outStreamMemberName` are "_ latexmath:[q_\textit{inStream}\textit{[\]}] _" and "_ latexmath:[q_\textit{outStream}\textit{[\]}] _"._

_Balance equation for transported quantities:_

_latexmath:[0 = \sum{q_i\dot{m}_i}]_

_latexmath:[0 = \sum{\dot{m}_i}\cdot
\left\{\begin{array}{ll}
q_{i, \mathit{outStream}} &\textit{if $\dot{m}$ is outflowing through terminal $i$}\\
q_{i, \mathit{inStream}} &\textit{if $\dot{m}$ is inflowing through terminal $i$}
\end{array}\right.]_

_The_ latexmath:[q_{i,\mathit{outStream}}] _is the convective quantity in case the matter flows out of the FMU._
latexmath:[q_{i,\mathit{inStream}}] _is the convective quantity in case the matter flows into the FMU._
_Both variables are present in the terminal._
_The outStream variable has the <<causality>> <<output>> or <<calculatedParameter>> because this information has to be provided by each FMU._
_The inStream variable has the <<causality>> <<input>> or <<parameter>>._
_To display the actual value in an importing tool, this actual value has to be selected depending on the sign of the terminal member variable with `variableKind` `inflow` or `outflow`._
_However, calculating the actual value is not necessary._

_If only two terminals with a variable are connected and their <<causality>> matches, then the values of the outStream variables can be forwarded to the corresponding inStream values._

_In Modelica the inStream variable is not directly visible, the value can only be accessed using "inStream()", therefore an additional model variable has to be added during the export._
_It is suggested that Modelica tools exporting an FMU derive the member name for the inStream variable according to the scheme "<outStream name>_inStream"._
_E.g. if the outStream name is "h_outflow" then the inStream name should be "h_outflow_inStream".]_

====== Terminal Graphical Representation

The `<TerminalGraphicalRepresentation>` is defined as:

image::images/schema/TerminalGraphicalRepresentation.png[width=75%, pdfwidth=60%, align="center"]

The `iconBaseName` attribute is mandatory.
This attribute defines the base name of the image file as a relative URI according to RFC 3986.
The base URI that this relative URI is resolved against is the URI of the `icons/terminalsAndIcons.xml` file in the FMU ZIP archive.
Implementations are required to support relative URIs, excluding relative URIs that move beyond the baseURI (i.e. go "up" a level via ..).
Implementations are not required to support any absolute URIs and any specific URI schemes.
The PNG file with the extension '.png' has to be provided.
An additional SVG file with extension '.svg' is optional.

_[Note that this specification is functionally equivalent to looking up image sources from the icons folder of the FMU ZIP archive after dot removal from the path as per section 5.2.4 of RFC 3986.]_

The `defaultConnectionStrokeSize` and `defaultConnectionColor` can be provided to define the intended connection line layout in the importing tool.
The stroke size is given relative to the coordinate system extent.
The stroke color is given in RGB values from 0 to 255. E.g.: `255 255 0`.

_[Nested terminals may have a `<TerminalGraphicalRepresentation>` element._
_However, if and how nested terminals are displayed, is up to the importing tool.]_

_[The order of painting of the `<TerminalGraphicalRepresentation>` of terminals on each level is equal to the order of appearance in the `<Terminal>` element._
_So graphical representations appearing first, are painted first, are behind graphical representations which appear below.]_

The `Annotations` element can be used by vendors to store additional information for the graphical representation.
_[It is suggested that Modelica tools store the Modelica annotation of the connector under the `type` `org.modelica.Modelica4Annotation` in the annotations of an element `connector`._
_The attribute `name` of the connector element is equal to the `name` attribute of the referenced `fmi3Terminal`.]_

_[If the graphical representation is used for an <<input>> or <<output>> (e.g. a `fmi3Float64` <<input>> `u`), then a `<Terminal>` has to be added to the `<Terminals>` element which has one `<TerminalMemberVariable>`.]_

====== General Remark on Signal [[GeneralRemarkOnSignal]]

_[The signal `variableKind` can be applied for different use cases._
_The first use case is a signal flow from an <<output>> of one FMU to an <<input>> of another FMU._
_The <<output>> value has to be forwarded to the <<input>>._

_The signal flow can cause algebraic loops._
_If variables in connected terminals have the <<causality>> <<output>>, then an importing tool may iterate an undefined <<input>> of an FMU to ensure that the connected output values are equal._

_Another use case is the parameter propagation._
_If a variable in both connected terminals has the <<causality>> <<parameter>>, then an importing tool could ask the user for the value of one of those <<parameter,`parameters`>> only, and propagate this value to the other FMU._
_If only one of the variables has <<causality>> <<parameter>>, and the other is a <<constant>> <<output>> or <<calculatedParameter>>, then the importing tool could also propagate the <<parameter>> value without presenting a parameter to the user._
_One example of use would be the name of a substance flowing through a pipe._
_If the fluid flows from one pipe FMU to another, the substance should be the same._
_This substance name could be propagated over several FMUs._

_Finally the `variableKind` `signal` can be applied to implement compatibility checks._
_If for example the <<variability>> of the variables in connected terminals are <<constant>>, then the importing tool can implement an equality assertion._
_This is also possible with <<calculated>> <<parameter,`parameters`>>._
_One example of use would be the cross sectional flow area in pipes which is calculated from geometry parameters._
_A change in the cross sectional flow area is relevant for the momentum equation, and therefore the connection has to be deemed incompatible if these variables are present and unequal.]_

====== General Remark on Inflow and Outflow

_[Flow variables have a direction and must fulfill a zero sum constraint i.e. the sum of all flow variables connected must be zero (Kirchhoff's current law)._
_In addition because different tools might have different direction definitions both, `inflow` and `outflow` are available as `variableKind`._
_For variables with `inflow` a positive value means that the flow is inwards, and for `outflow` a positive value means that the flow is outwards._
_For the sake of simplicity in the following latexmath:[\dot{m}_i] denotes an inflowing quantity:_

_latexmath:[0 = \sum{\dot{m}_i}]_

_[Connecting a single <<output>> `outflow` to a single <<input>> `inflow`, or vice versa automatically fulfills the flow constraint, while connecting two variables of the same flow type requires a negation of the variable value._

`inflow` _and_ `outflow` _is only used as a sign convention for scalar flow quantities which obey Kirchhoff's current law (sum up to zero)._
_Other, nonscalar, quantities which also sum up to zero, like a mechanical force in 3D space according to D'Alembert's principle, are not covered by this sign convention._
_This is the case since Kirchhoff's current law only holds for scalars where a sign convention is sufficient._
_Other definitions are beyond the scope of this terminal specification and need clear definition in other specifications on top of this.]_

==== Definition of Model Variables [[definition-of-model-variables]]

The element of `<fmiModelDescription><ModelVariables>` is the central part of the model description.
It provides the static information of all exposed variables and is defined as follows.

.ModelVariables element.
[[figure-schema-ModelVariables]]
image::images/schema/ModelVariables.png[width=60%, align="center"]

The `<ModelVariables>` element consists of an ordered set of variable elements (see <<figure-schema-ModelVariables>>).
Variable elements can uniformly represent variables of primitive (atomic) types, like single floating point or integer variables, or as well as arrays of an arbitrary (but fixed) number of dimensions.
The schema definition is present in a separate file `fmi3Variable.xsd`.

Variable elements representing array variables must contain at least one `<Dimension>` element.
Each `<Dimension>` element specifies the size of one dimension of the array:

- If the <<start>> attribute of the `<Dimension>` element is present, it defines a constant unsigned 64-bit integer size for this dimension.
The <<variability>> of the dimension size is <<constant>> in this case.

- If the <<valueReference>> attribute of the `<Dimension>` element is present, it defines the size of this dimension to be the value of the variable with the value reference given by the <<valueReference>> attribute.
The referenced variable must be a variable of type `<UInt64>`, and must either be a constant (i.e. with <<variability>> = <<constant>>) or a <<structuralParameter,`structural parameter`>>(i.e. with <<causality>> = <<structuralParameter>>).
The <<variability>> of the dimension size is in this case the <<variability>> of the referenced variable.

These two options are mutually exclusive, i.e., for each `<Dimension>` element either a <<start>> attribute or a <<valueReference>> attribute can be supplied, but not both.
However different dimension sizes can be specified using different mechanisms and can have differing <<variability>> attributes.

All initial dimension sizes (i.e. prior to any configuration or reconfiguration) must be positive integers (i.e. not zero), so that no dimension is initially vanished.

_[This allows importing tools to ignore <<structuralParameter,`structural parameters`>> because that <<start>> value reflects the internal default setting of that <<structuralParameter,`structural parameter`>>._
_The rationale for requiring positive start values for <<structuralParameter, `structural parameters`>> is that this avoids importers having to deal with vanishing dimensions if they do not want to deal with them (or even with changing sizes at all)._
_If we allowed 0 dimension sizes for initial values, tools that do not even care about changing dimension sizes must be prepared to handle vanishing dimensions.]_

Changes to dimension sizes are constrained by the `min`/`max` attributes of the referenced <<structuralParameter,`structural parameters`>>, which can be any non-negative integer, including zero.
Specifying a minimum size of zero on a <<structuralParameter,`structural parameter`>> allows any related dimension sizes to be changed to zero in *Configuration Mode* or *Reconfiguration Mode*, thus causing the respective array size to go to zero, which leaves the respective array variable without any active elements.

The actual dimension sizes of arrays are also constrained by the FMU platform, due to memory and addressing constraints:
Since the API functions to access variables and their values are constrained to `size_t` individual elements, platforms with addresses of less than 64-bit width will not be able to access elements beyond their addressing limits, neither will they be able to allocate enough memory or address space to represent such arrays.
For these reasons implementations must take platform-specific constraints into account when changing dimension sizes, and must be prepared to handle the inability of the FMU to adjust to the desired sizes during *Configuration Mode* or *Reconfiguration Mode*.

Changing any dimension of a variable in *Configuration Mode* or *Reconfiguration Mode* invalidates the variable's current value (including its <<start>> value).
It should be noted that changing a <<structuralParameter,`structural parameter`>> might affect dimension sizes of several variables.

[[alias,`alias`]]
A variable can have any number of `<Alias>` elements that define a variable alias.
Each variable alias has a required attribute `name` whose value must be unique among all variables and variable aliases, and an optional attribute `description`.
Variable aliases of floating point variables may additionally have a <<displayUnit>> that follows the same rules as for variables.

_[ Example:_

[source, xml]
----
include::examples/alias_example.xml[tags=VariableAliases]
----
_]_

The attributes of variables are:

image::images/schema/fmi3VariableBase.png[width=80%, align="center"]

[cols="1,5a",options="header"]
|====
|Attribute
|Description

|`name`
|The full, unique name of the variable.
Every variable is uniquely identified within an FMU instance by this name.

|`valueReference`
|
[[valueReference,`valueReference`]]
A handle of the variable to efficiently identify the variable value in the model interface and for references within the <<modelDescription.xml>>.
This handle is a secret of the tool that generated the C functions.
It is required to be unique for an FMU.
This attribute is `required`.

|`description`
|An optional description string describing the meaning of the variable.

|`causality`
|
[[causality,`causality`]]
Enumeration that defines the causality of the variable.
Allowed values of this enumeration:

[[parameter,`parameter`]]
`= parameter`: A data value that is constant during the simulation (except for <<tunable>> parameters, see there) and is provided by the environment and cannot be used in connections, except for parameter propagation in terminals as described in <<GeneralRemarkOnSignal>>.
<<variability>> must be <<fixed>> or <<tunable>>.
These parameters can be changed independently, unlike <<calculatedParameter,calculated parameters>>.
<<initial>> must be <<exact>> or not present (meaning <<exact>>).

[[calculatedParameter,`calculatedParameter`]]
`= calculatedParameter`: A data value that is constant during the simulation and is computed during initialization or when <<tunable>> <<parameter,`parameters`>> change.
<<variability>> must be <<fixed>> or <<tunable>>.
<<initial>> must be <<approx>>, <<calculated>> or not present (meaning <<calculated>>).

[[input,`input`]]
`= input`: The variable value can be provided from another FMU. +
[[inputClock,`inputClock`]] If <<variability>> = <<clock>> the variable defines an <<inputClock, `input clock`>> that is controlled by the importer.
An <<inputClock, `input clock`>> can be left unconnected, can be connected to an <<outputClock,`output clock`>>, or the importer generates the clock variable.

[[output,`output`]]
`= output`: The variable value can be used by another FMU.
The algebraic relationship to the <<input,`inputs`>> is defined via the <<dependencies>> attribute of `<fmiModelDescription><ModelStructure><Output>`. +
[[outputClock,`outputClock`]] If <<variability>> = <<clock>> the variable defines an <<outputClock,`output clock`>> that is controlled by the FMU.
An <<outputClock,`output clock`>> can be left unconnected or can be connected to an <<inputClock, `input clock`>>, usually of another FMU (for exceptions see <<triggeredBy>>).

[[local,`local`]]
`= local`: Local variables are: +

* continuous-time <<state,`states`>> and their `Derivative`pass:[s], `ClockedState`pass:[s], `EventIndicator`pass:[s] or `InitialUnknown`pass:[s].
These variables are listed in the `<fmiModelDescription><ModelStructure>`. +
* [[localClock,`local clock`]] internal, intermediate variables or local clocks which can be read for debugging purposes and are not listed in the `<fmiModelDescription><ModelStructure>`.

Setting of local variables: +

* In *Initialization Mode* and before, local variables need to be set if they do have start values or are listed as `InitialUnknown`.

* In super state *Initialized*, `fmi3Set{VariableType}` must not be called on any of the local variables.
Only in Model Exchange, continuous <<state,`states`>> can be set with <<fmi3SetContinuousStates>>.
Local variable values must not be used as input to another model or FMU.

_[Continuous-time <<state,`states`>> and their `Derivative`pass:[s], `ClockedState`pass:[s], `EventIndicator`pass:[s] or `InitialUnknown`pass:[s] are listed as local variables to give them properties like name and unit for debugging purposes and a value reference to be listed in <fmiModelDescription><ModelStructure>.]_

_[TODO: add ClockedState elements to ModelStructure.]_
_[TODO: rename Derivative to StateDerivative to differentiate between derivatives of states and general derivatives of any other variable.]_

[[independent,`independent`]]
`= independent`: The independent variable (usually `time` _[but could also be, for example, `angle`]_).
All variables are a function of this <<independent>> variable.
<<variability>> must be <<continuous>>.
Exactly one variable of an FMU must be defined as <<independent>>.
If the unit for the independent variable is not defined, it is implicitely`unit = s`.
If one variable is defined as <<independent>>, it must be defined with a floating point type without a <<start>> attribute.
It is not allowed to call function `fmi3Set{VariableType}` on an <<independent>> variable.
Instead, its value is initialized with <<fmi3EnterInitializationMode>> and after initialization set by <<fmi3SetTime>> for Model Exchange and by arguments <<currentCommunicationPoint>> and <<communicationStepSize>> of <<fmi3DoStep>> for Co-Simulation FMUs.
_[The actual value can be inquired with `fmi3Get{VariableType}`.]_

[[structuralParameter,`structuralParameter`]]
`= structuralParameter`: parameter (a data value that is constant during the simulation and is provided by the environment and cannot be used in connections).
<<variability>> must be <<fixed>> or <<tunable>>.
<<initial>> must be <<exact>> or not present (meaning <<exact>>).
This <<causality>> requires the variable not to have a `<Dimension>` element.

_[_
_Example:_

[source, xml]
----
include::examples/structural_parameter_example.xml[tags=structuralParameter]
----

_]_

<<structuralParameter,`structural parameters`>> that are referenced in `<Dimension>` elements may have a `min` attribute with 0 but the <<start>> attribute, which is mandatory for <<structuralParameter,`structural parameters`>>, must have a value larger than 0 for <<structuralParameter,`structural parameters`>> used in `<Dimension>` elements.

The default of <<causality>> is <<local>>. +
A continuous-time <<state>> or a event indicator must have <<causality>> = <<local>> or <<output>>, see also <<ModelStructure>>.

_[<<causality>> = <<calculatedParameter>> and <<causality>> = <<local>> with <<variability>> = <<fixed>> or <<tunable>> are similar._
_The difference is that a <<calculatedParameter>> can be used in another model or FMU, whereas a <<local>> variable cannot._
_For example, when importing an FMU in a Modelica environment, a <<calculatedParameter>> should be imported in a `public` section as `final parameter`, whereas a <<local>> variable should be imported in a `protected` section of the model.]_

|`variability`
|
[[variability,`variability`]]
Enumeration that defines the time dependency of the variable, in other words, it defines the time instants when a variable can change its value.
_[The purpose of this attribute is to define when a result value needs to be inquired and to be stored._
_For example, <<discrete>> variables change their values only at event instants (ME) or at a communication point (CS and SE) and it is therefore only necessary to inquire them with `fmi3Get{VariableType}` and store them at event times.]_
Allowed values of this enumeration:

[[constant,`constant`]]
`= constant`: The value of the variable never changes.

[[fixed,`fixed`]]
`= fixed`: The value of the variable is fixed after initialization, in other words, after <<fmi3ExitInitializationMode>> was called the variable value does not change anymore.

[[tunable,`tunable`]]
`= tunable`: The value of the variable is constant between events (ME) and between communication points (CS and SE) due to changing variables with <<causality>> = <<parameter>> and <<variability>> = <<tunable>>.
Whenever a <<parameter>> with <<variability>> = <<tunable>> changes, an event is triggered externally (ME or CS if events are supported), or the change is performed at the next communication point (CS and SE) and the variables with <<variability>> = <<tunable>> and <<causality>> = <<calculatedParameter>> or <<output>> must be newly computed.
_[<<tunable>> <<input,inputs>> are not allowed, see <<table-allowed-variability-causality-combinations>>.]_

[[discrete,`discrete`]]
`= discrete`: +
Model Exchange: The value of the variable is constant between external and internal events (= <<time event,`time`>>, <<state event,`state`>>, <<step event,`step events`>> defined implicitly in the FMU). +
Co-Simulation: By convention, the variable is from a real sampled data system and its value is only changed at communication points (including event handling).
During <<intermediateUpdate>>, <<discrete>> variables are not allowed to change.
_[If the simulation algorithm notices a change in a discrete variable during <<intermediateUpdate>>, the simulation algorithm will delay the change, raise an event with <<earlyReturnRequested,`earlyReturnRequested == fmi3True`>> and during the communication point it can change the <<discrete>> variable, followed by event handling.]_

[[continuous,`continuous`]]
`= continuous`: Only a variable of `type == fmi3GetFloat32` or `type == fmi3GetFloat64` can be <<continuous>>. +
Model Exchange: No restrictions on value changes (see <<smoothness>>).

[[clock,`clock`]]
`= clock`: Only a variable of type `<Clock>` can have this variability.

The default is <<continuous>> for variables of type `<Float32>` and `<Float64>`, and <<discrete>> for all other types.

_[Note that the information about continuous <<state,`states`>> is defined with elements `<ModelStructure><Derivative>`.]_

|`initial`
|
[[initial,`initial`]]
Enumeration that defines how the variable is initialized.
It is not allowed to provide a value for <<initial>> if <<causality>> = <<input>> or <<independent>>:

[[exact,`exact`]]
`= exact`: The variable is initialized with the <<start>> value (provided under the variable type element).

[[approx,`approx`]]
`= approx`: The <<start>> value provides an approximation that may be modified during initialization, e.g., if the FMU is part of an algebraic loop where the variable might be an iteration variable and <<start>> value is taken as initial value for an iterative solution process.

[[calculated,`calculated`]]
`= calculated`: The variable is calculated from other variables during initialization.
It is not allowed to provide a <<start>> value.

If <<initial>> is not present, it is defined by <<table-definition-initial>> based on <<causality>> and <<variability>>.
If <<initial>> = <<exact>> or <<approx>>, or <<causality>> = <<input>>, a <<start>> value must be provided.
If <<initial>> = <<calculated>>, or <<causality>> = <<independent>>, it is not allowed to provide a <<start>> value.

_[The environment decides when to use the <<start>> value of a variable with <<causality>> = <<input>>.
Examples: (a) automatic tests of FMUs are performed, and the FMU is tested by providing the <<start>> value as <<constant>> <<input>>.
(b) For a Model Exchange FMU, the FMU might be part of an algebraic loop.
If the <<input>> variable is iteration variable of this algebraic loop, then initialization starts with its <<start>> value.]_

If <<causality>> = <<input>> and <<variability>> = <<clock>>, that is, the variable is an <<inputClock>>, it is required to provide a <<start>> value for describing the expected initial condition of the <<inputClock>> for that FMU.
If an <<inputClock>> has `fmi3True` as a <<start>> value, the environment should activate the <<clock>> the first time it enters *Event Mode*.
The environment can nevertheless choose different <<start>> values if it is not possible to fulfill the conditions in a simulation setup.

If <<causality>> = <<output>> the <<initial>> attribute value is set to <<calculated>> and no <<start>> value is provided.

If `fmi3Set{VariableType}` is not called on a variable with <<causality>> = <<input>>, then the FMU must use the <<start>> value as value of this <<input>>.

|`canHandleMultipleSetPerTimeInstant`
|
[[canHandleMultipleSetPerTimeInstant,`canHandleMultipleSetPerTimeInstant`]]
Only for variables with <<variability>> = <<input>> : +
If not present, the default value is assumed to be `true`.
If `canHandleMultipleSetPerTimeInstant = false`, then only one `fmi3Set{VariableType}` call is allowed at one super-dense time instant (model evaluation) on this variable.
That is, this <<input>> is not allowed to appear in a (real) algebraic loop requiring multiple calls of `fmi3Set{VariableType}` on this variable _[for example, due to a Newton iteration]_. +
_[This flag must be set to `false` for variables where (internal) discrete-time states are directly updated when assigned (xd := f(xd) instead of xd = f(previous(xd)), and at least one <<output>> depends on this <<input>> and on discrete-time states._ +
_It is strongly recommended that such an FMU checks the fulfillment of the requirement by itself during run-time, because an environment might not be able to check it; usually, there is a generic mechanism to import an FMU in an environment, but the mechanism to connect FMUs together is unrelated to the import mechanism._
_For example, there is no mechanism in the Modelica language to formulate connection restrictions for C functions (the FMU) called in a Modelica model.]_


|`clockReference`
|
[[clockReference,`clockReference`]]

The optional attribute <<clockReference>> is used, in conjunction with the <<clockElementIndex>> attribute, to reference the <<clock,`clocks`>> this variable is assigned to.
The <<clockReference>> holds only <<valueReference>> information for variables with base type `fmi3Clock`.

If the <<clock>> referenced by <<clockReference>> is a <<SynchronousClocks,Synchronous Clock>> (<<clockType>> = <<synchronousTime>>), the variable is a clocked variable associated uniquely with this <<clock>>.
It is not possible to associate more than one <<clock>> to a variable.

If the <<clock>> referenced by <<clockReference>> is a <<CommunicationPointClocks,Communication Point Clock>> (<<clockType>> = <<communicationPoint>>) the variable is not necessarily `clocked` in the sense of synchronous time clock theory.
Such variables can also be continuous-time or discrete-time variables.

If <<causality>> = <<output>> and <<variability>> = <<clock>> the <<outputClock>> activation can occur only in the model partition that is related to the referenced <<inputClock>>, i.e. the <<outputClock,`output clock`>> value (active/inactive) can only change in this model partition.

|`clockElementIndex`
|
[[clockElementIndex,`clockElementIndex`]]
The optional attribute <<clockElementIndex>> is used in conjunction with the <<clockReference>> attribute to define the element index of the <<clock,`clocks`>> this variable is assigned to for array clock variables.
The element index is the 1-based index of the element (with serialization of indices for multi-dimensional arrays in the usual row-major order).
For scalar clock variables this attribute must not be specified or must be specified as 0.

|`intermediateUpdate`
|
[[intermediateUpdate,`intermediateUpdate`]]
If this boolean attribute is `true`, the variable can be accessed during a communication step.
Variables with <<causality>> <<parameter>> must not be marked with <<intermediateUpdate,`intermediateUpdate = true`>>.

This attribute is only used for Co-Simulation.
The default value of this attribute is `false`.
|====

If <<initial>> is not present, its value is defined by <<table-definition-initial>> based on the values of <<causality>> and <<variability>> (default [.underline]#underlined#):

.Definition of <<initial>>.
[#table-definition-initial]
[cols="1,1,1,1,1,1,1,1,1"]
|====
2.2+|
7+^|<<causality>>
^|<<structuralParameter,`structural Parameter`>>
^|<<parameter>>
^|<<calculatedParameter,`calculated Parameter`>>
^|<<input>>
^|<<output>>
^|<<local>>
^|<<independent>>

.6+^|<<variability>>
^|<<constant>> data
^|[.underline]#exact#, --
^|--
^|--
^|--
^|[.underline]#exact#
^|[.underline]#exact#
^|--

^|<<fixed>> data
^|[.underline]#exact#
^|[.underline]#exact#
^|[.underline]#calculated#, approx
^|--
^|--
^|[.underline]#calculated#, approx
^|--

^|<<tunable>> data
^|[.underline]#exact#
^|[.underline]#exact#
^|[.underline]#calculated#, approx
^|--
^|--
^|[.underline]#calculated#, approx
^|--

^|<<discrete>> variables
^|--
^|--
^|--
^|--
^|[.underline]#calculated#, exact, approx
^|[.underline]#calculated#, exact, approx
^|--

^|<<continuous>> variables
^|--
^|--
^|--
^|--
^|[.underline]#calculated#, exact, approx
^|[.underline]#calculated#, exact, approx
^|--

^|<<clock,`clocks`>>
^|--
^|--
^|--
^|[.underline]#exact#
^|[.underline]#calculated#
^|[.underline]#calculated#
^|--
|====

_[Note: For local and output variables and <<initial>> = <<exact>>, then the variable is explicitly set in *Initialization Mode*._
_The value of the variable is either the <<start>> value stored in a variable element `<XXX start=YYY/>` or the value set with `fmi3Set{VariableType}` during *Initialization Mode*.]_

<<table-allowed-variability-causality-combinations>> shows the combinations of <<variability>>/<<causality>> settings that are allowed.

.Allowed combinations of <<variability>>/<<causality>>.
[[table-allowed-variability-causality-combinations]]
[cols="1,1,1,1,1,1,1,1,1"]
|====
2.2+|
7+^|<<causality>>
^|<<structuralParameter,`structural Parameter`>>
^|<<parameter>>
^|<<calculatedParameter,`calculated Parameter`>>
^|<<input>>
^|<<output>>
^|<<local>>
^|<<independent>>

.6+^|<<variability>>
^|<<constant>> data
^|--
^|-- (a)
^|-- (a)
^|-- (a)
^|(7)
^|(10)
^|-- (c)

^|<<fixed>> data
^|(16)
^|(1)
^|(3)
^|-- (d)
^|-- (e)
^|(11)
^|-- (c)

^|<<tunable>> data
^|(17)
^|(2)
^|(4)
^|-- (d)
^|-- (e)
^|(12)
^|-- (c)

^|<<discrete>> variables
^|-- (b)
^|-- (b)
^|-- (b)
^|(5)
^|(8)
^|(13)
^|--(c)

^|<<continuous>> variables
^|-- (b)
^|-- (b)
^|-- (b)
^|(6)
^|(9)
^|(14)
^|(15)

^|<<clock,`clocks`>>
^|--
^|--
^|--
^|(18)
^|(18)
^|(19)
^|--
|====

_[Discussion of the combinations that are not allowed:_

[cols="1,10", options="header"]
|====
|
|_Explanation why this combination is not allowed_

^|_(a)_
|_The combinations <<constant>> / <<parameter>>, <<constant>> / <<calculatedParameter>> and <<constant>> / <<input>> do not make sense, since <<parameter,`parameters`>> and <<input,`inputs`>> are set from the environment, whereas a constant has always a value._

^|_(b)_
|_The combinations <<discrete>> / <<structuralParameter>>, <<discrete>> / <<parameter>>, <<discrete>> / <<calculatedParameter>> , <<continuous>> / <<structuralParameter>>, <<continuous>> / <<parameter>> and <<continuous>> / <<calculatedParameter>> do not make sense, since <<causality>> = <<structuralParameter>>, <<causality>> = <<parameter>> and <<causality>> = <<calculatedParameter>> define variables that do not depend on time, whereas <<discrete>> and <<continuous>> define variables where the values can change during simulation._

^|_(c)_
|_For an <<independent>> variable only <<variability>> = <<continuous>> makes sense._

^|_(d)_
|_A <<fixed>> or <<tunable>> <<input>> has exactly the same properties as a <<fixed>> or <<tunable>> <<parameter>>._
_For simplicity, only <<fixed>> and <<tunable>> <<parameter,`parameters`>> shall be defined._

^|_(e)_
|_A <<fixed>> or <<tunable>> <<output>> has exactly the same properties as a <<fixed>> or <<tunable>> <<calculatedParameter>>._
_For simplicity, only <<fixed>> and <<tunable>> <<calculatedParameter,`calculatedParameters`>> shall be defined._
|====

_Discussion of the combinations that are allowed_:

[cols="1,3,8", options="header"]
|====
|
|_Setting_
|_Example_

>|_(1)_
|_<<fixed>> <<parameter>>_
|_Non-<<tunable>> <<parameter>>_

>|_(2)_
|_<<tunable>> <<parameter>>_
|_<<tunable,`Tunable`>> <<parameter>> (changing such a <<parameter>> triggers event handling (ME) or takes effect at the next communication point (CS and SE), and <<tunable>> <<calculatedParameter>>/<<output>>/<<local>> variables might change their values)._

>|_(3)_
|_<<fixed>> <<dependenciesKind,`dependent`>> <<parameter>>_
|_Non-<<tunable>> <<dependenciesKind,`dependent`>> <<parameter>> (variable that is computed directly or indirectly from constants or <<parameter,`parameters`>>)._

>|_(4)_
|_<<tunable>> <<dependenciesKind,`dependent`>> <<parameter>>_
|_<<tunable,`Tunable`>> <<dependenciesKind,`dependent`>> <<parameter>> (changing a <<parameter>> triggers event handling (ME) or takes effect at the next communication point (CS and SE), and <<tunable>> <<dependenciesKind,`dependent`>> <<parameter,`parameters`>> and <<tunable>> <<local>> variables might change their values)._

>|_(5)_
|_<<discrete>> <<input>>_
|_<<discrete,`Discrete`>> <<input>> variable from another model._

>|_(6)_
|_<<continuous>> <<input>>_
|_<<continuous,`Continuous`>> <<input>> variable from another model._

>|_(7)_
|_<<constant>> <<output>>_
|_Variable where the value never changes and that can be used in another model._

>|_(8)_
|_<<discrete>> <<output>>_
|_<<discrete,`Discrete`>> variable that is computed in the FMU._
_Can be used in another model._

>|_(9)_
|_<<continuous>> <<output>>_
|_<<continuous,`Continuous`>> variable that is computed in the FMU and can be used in another model._

>|_(10)_
|_<<constant>> <<local>>_
|_Variable where the value never changes._
_Cannot be used in another model._

>|_(11)_
|_<<fixed>> <<local>>_
|_Local variable that depends on <<fixed>> <<parameter,`parameters`>> only and is computed in the FMU._
_Cannot be used in another model._
_After initialization, the value of this <<local>> variable cannot change._

>|_(12)_
|_<<tunable>> <<local>>_
|_Local variable that depends on <<tunable>> <<parameter,`parameters`>> only and is computed in the FMU._
_Cannot be used in another model._
_The value of this <<local>> variable can only change during initialization and at event instants, provided a <<tunable>> <<parameter>> was changed._

>|_(13)_
|_<<discrete>> <<local>>_
|_<<discrete,`Discrete`>> variable that is computed in the FMU and cannot be used in another model._

>|_(14)_
|_<<continuous>> <<local>>_
|_<<continuous,`Continous`>> variable that is computed in the FMU and cannot be used in another model._

>|_(15)_
|_<<continuous>> <<independent>>_
|_All variables are a function of the continuous-time variable marked as <<independent>>._
_Usually, this is `time`._

>|_(16)_
|_<<fixed>> <<structuralParameter>>_
|_<<parameter,`Parameter`>> used in  `<Dimension>` element;  can be changed before initialization in *Configuration Mode*._

>|_(17)_
|_<<tunable>> <<structuralParameter>>_
|_<<parameter,`Parameter`>> used in  `<Dimension>` element;  can be changed before initialization in *Configuration Mode* and in *Reconfiguration Mode*._

>|_(18)_
|_<<clock>>_
|_Variable that defines a <<clock>>._

>|_(19)_
|_<<clock>>_
|_Variable that defines a <<clock>> that is computed in the FMU and cannot be used in another model._
|====

_How to treat <<tunable>> variables:_

_A <<parameter>> p is a variable that does not change its value during simulation, in other words, dp/dt = 0._
_If the <<parameter>> p is changing, then Dirac impulses are introduced since dp/dt of a discontinuous <<constant>> variable `p` is a Dirac impulse._
_Even if this Dirac impulse would be modeled correctly by the modeling environment, it would introduce unwanted `vibrations`._
_Furthermore, in many cases the model equations are derived under the assumption of a <<constant>> value (like mass or capacity), and the model equations would be different if `p` would be time varying._

_FMI for Model Exchange:_ +
_Therefore, "tuning a (structural) <<parameter>>" during simulation does not mean to "change the parameter online" during simulation._
_Instead, this is a short hand notation for:_

. _Stop the simulation at an event instant (usually, a <<step event>>, in other words, after a successful integration step)._

. _Change the values of the <<tunable>> (structural) <<parameter,`parameters`>>._
_For <<tunable>> <<structuralParameter,`structural parameters`>>, the *Reconfiguration Mode* must be entered before and left afterwards._

. _Compute all <<parameter,`parameters`>> (and sizes of variables, <<state,`states`>>, <<derivative,`derivatives`>>, event indicators, ...) that depend on the <<tunable>> (structural) <<parameter,`parameters`>>._

. _Newly start the simulation using as initial values previously stored values and the new values of the <<parameter,`parameters`>>._

_Basically this means that a new simulation run is started from the previous FMU state with changed <<parameter>> values._
_With this interpretation, changing <<parameter,`parameters`>> online is "clean", as long as these changes appear at an event instant._

_FMI for Co-Simulation:_
_Changing of <<tunable>> <<parameter,`parameters`>> is allowed before an <<fmi3DoStep>> call (so, whenever an <<input>> can be set with `fmi3Set{VariableType}`) and before <<fmi3ExitInitializationMode>> is called (that is before and during *Initialization Mode*)._
_The FMU internally carries out event handling if necessary.]_

Type specific properties are defined in the required choice element, where exactly one of the numeric types or an `<Enumeration>` must be present in the XML file:
<<figure-schema-Float64>>, <<figure-schema-Int32>>, <<figure-schema-Boolean>>, <<figure-schema-Binary>>, and <<figure-schema-Enumeration>>, are representative examples.

.Float64 element.
[[figure-schema-Float64]]
image::images/schema/Float64.png[width=70%, align="center"]

.Int32 element.
[[figure-schema-Int32]]
image::images/schema/Int32.png[width=70%, align="center"]

.Boolean element.
[[figure-schema-Boolean]]
image::images/schema/Boolean.png[width=70%, align="center"]

.Binary element.
[[figure-schema-Binary]]
image::images/schema/Binary.png[width=70%, align="center"]

.Enumeration element.
[[figure-schema-Enumeration]]
image::images/schema/Enumeration.png[width=70%, align="center"]

The attributes are defined in <<definition-of-types>> (`<TypeDefinitions>`), except:

[cols="1,7a", options="header"]
|====
|Attribute
|Description

|`declaredType`
|If present, name of type defined with `<TypeDefinitions><TypeDefinition>`.
The value defined in the corresponding `<TypeDefinition>` (see <<definition-of-types>>) is used as default.
_[For example, if `min` is present both in variable type element of `<TypeDefinition>` and in the concrete variable type element of the variable, then the `min` of the variable is actually used.]_
For numeric types and `<String>`, this attribute is optional.
For `<Enumeration>` it is required, because the `<Enumeration>` items are defined in `<TypeDefinitions><TypeDefinition>`.


|`start`
|
[[start,`start`]]
Initial or guess value of variable.
This value is also stored in the C functions.
_[Therefore, calling_ `fmi3Set{VariableType}` _to set <<start>> values is only necessary, if a different value as stored in the XML file is desired._
_It is not allowed to change the start values in the <<modelDescription.xml>> file of an FMU, as this would break the consistency with the hard-coded start values in the C-Code._
_This could lead to unpredictable behavior of the FMU in different importing tools, as it is not mandatory to call `fmi3Set{VariableType}` to set start values during initialization._
_Instead it is recommended to use the SSP Standard (https://ssp-standard.org/) to handle modified parameters of FMUs or different parameter sets.]_

The <<start>> is either a single value or a list of values.
The serialization of a multi-dimensional array variable is described in <<serialization-of_variables>>.
If only a single value is given for a multi-dimensional array, all values of the multi-dimensional array are equal to this value.

The interpretation of <<start>> is defined by variable attribute <<initial>>.
A different <<start>> value can be provided with an `fmi3Set{VariableType}` function before <<fmi3ExitInitializationMode>> is called (but not for variables with <<variability>> = <<constant>>).

_[The standard approach is to set the <<start>> value before <<fmi3EnterInitializationMode>>._
_However, if the initialization shall be modified in the calling environment (for example, changing from initialization of states to steady-state initialization), it is also possible to use the <<start>> value as iteration variable of an algebraic loop: using an additional condition in the environment, such as_ latexmath:[{\dot{x} = 0}] _, the actual <<start>> value is determined.]_

If <<initial>> = <<exact>> or <<approx>> or <<causality>> = <<input>>, a <<start>> value must be provided.

If <<initial>> = <<calculated>> or <<causality>> = <<independent>>, it is not allowed to provide a <<start>> value.

Variables with <<causality>> = <<parameter>> or <<input>>, as well as variables with <<variability>> = <<constant>>, must have a <<start>> value.

- If <<causality>> = <<parameter>>, the <<start>> value is the value of it.

- If <<causality>> = <<input>>, the <<start>> value is used by the model as value of the <<input>>, if the <<input>> is not set by the environment.

- If <<variability>> = <<constant>>, the <<start>> value is the value of the constant.

- If <<causality>> = <<output>> or <<local>>, then the <<start>> value is either an <<initial>> or a `guess` value, depending on the setting of attribute <<initial>>.

|`derivative`
|
[[derivative,`derivative`]]
If present, this variable is the derivative of variable with value reference `derivative`.
_[For example, if there are 10 variables and `derivative = 3` for variable 8, then variable 8 is the derivative of variable 3 with respect to the <<independent>> variable (usually time)._
_This information might be especially used if an <<input>> or an <<output>> is the derivative of another <<input>> or <<output>>, or to define the <<state,`states`>>.]_

The <<state>> <<derivative,`derivatives`>> of an FMU are listed as elements `<ModelStructure><Derivative>`.
All variables listed in this element must have attribute `derivative` (in order that the continuous-time <<state,`states`>> are uniquely defined).

|`reinit`
|[[reinit,`reinit`]]
Only for Model Exchange (if only a Co-Simulation FMU, this attribute must not be present.
If both Model Exchange and a Co-Simulation FMU, this attribute is ignored for co-simulation): +
Can only be present for a continuous-time <<state>>. +
If `true`, <<state>> can be reinitialized at an event by the FMU. +
If `false`, <<state>> will not be reinitialized at an event by the FMU.

|`min / max`
|The optional attributes `min` and `max` in element `<Enumeration>` restrict the allowed values of the enumeration.
The `min/max` definitions are information from the FMU to the environment defining the region in which the FMU is designed to operate, see also comment in <<definition-of-types>>.
_[If, for example, an `<Enumeration>` is defined with `name1 = -4`, `name2 = 1`, `name3 = 5`, `name4 = 11` and `min = -2`, `max = 5`, then only `name2` and `name3` are allowed.]_
|====

==== Definition of the Model Structure [[ModelStructure]]

The structure of the model is defined in element `<fmiModelDescription><ModelStructure>`.
This structure is with respect to the underlying model equations, independently how these model equations are solved.
_[For example, when exporting a model in more than one FMI format; then the model structure is identical in all cases._
_E.g. a Co-Simulation FMU has either an integrator included that solves the model equations, or the discretization formula of the integrator and the model equations are solved together ("inline integration")._
_In all cases the model has the same continuous-time <<state,`states`>>._
_In the case of a Model-Exchange FMU, the internal implementation is a discrete-time system, but from the outside this is still a continuous-time model that is solved with an integration method.]_

The required part defines an ordering of the <<output,`outputs`>>, the (exposed) <<derivative,`derivatives`>>, the event indicators, and the unknowns that are available during Initialization _[Therefore, when linearizing an FMU, every tool will use the same ordering for the <<output,`outputs`>>, <<state,`states`>>, and <<derivative,`derivatives`>> for the linearized model.
The ordering of the <<input,`inputs`>> should be performed in this case according to the ordering in `<ModelVariables>`.]_
A Model Exchange FMU must expose all <<derivative,`derivatives`>> of its continuous-time <<state,`states`>> in elements `<ModelStructure><Derivative>` and must expose all event indicators in elements `<EventIndicator>`.
A Co-Simulation FMU does not need to expose these state derivatives and event indicators.
_[If a Co-Simulation FMU exposes its state derivatives, they are usually not utilized for the co-simulation, but, for example, to linearize the FMU at a communication point.]_

The optional part defines in which way <<derivative,`derivatives`>>, <<output,`outputs`>>, and initial unknowns, depend on <<input,`inputs`>>, and continuous-time <<state,`states`>>, at the current super-dense time instant (ME) or at the current communication point (CS and SE).
_[The listed <<dependencies>> declare the dependencies between whole (multi-dimensional-)variables and not individual elements of the variables.]_
_[A simulation environment can utilize this information to improve the efficiency, for example, when connecting FMUs together, or when computing the partial derivative of the <<derivative,`derivatives`>> with respect to the <<state,`states`>> in the simulation engine.]_

<<figure-schema-ModelStructure>> shows the definition of `<ModelStructure>`.

.ModelStructure element.
[#figure-schema-ModelStructure]
image::images/schema/ModelStructure.png[width=90%]

Note that attribute <<dependenciesKind>> for element <<InitialUnknown>> has less enumeration values as <<dependenciesKind>> in the other lists, as detailed in <<table-model-structure-elements>>.

`<ModelStructure>` consists of the elements detailed in <<table-model-structure-elements>> (see also <<figure-schema-ModelStructure>>; the symbols of the mathematical equations describing the dependency are defined in <<math-model-exchange>>):

.ModelStructure elements.
[#table-model-structure-elements]
[cols="1,5",options="header"]
|====
|Element
|Description

|`Output`
|Ordered list of all outputs, in other words, a list of value references where every corresponding variable must have <<causality>> = <<output>> (and every variable with <<causality>> = <<output>> must be listed here).
_[Note that all <<output>> variables are listed here, especially <<discrete>> and <<continuous>> <<output,`outputs`>>._
_The ordering of the variables in this list is defined by the exporting tool._
_Usually, it is best to order according to the declaration order in the source model, since then the `<Output>` list does not change if the declaration order of <<output,`outputs`>> in the source model is not changed._
_This is for example, important for linearization, in order that the interpretation of the output vector does not change for a re-exported FMU.]_
Attribute <<dependencies>> defines the dependencies of the <<output,`outputs`>> from the knowns at the current super-dense time instant in Event and in *Continuous-Time Mode* (ME) and at the current communication point (CS and SE).
Attribute <<dependencies>> for output clocks (variables with <<causality>> = <<output>> and <<variability>> = <<clock>>) lists all known variables (including input clocks) that contribute to trigger a clock tick for that output clock.
Beside the knowns, the <<output,`outputs`>> also depend on "frozen" variables (= variables which cannot be changed in the current mode) but these "frozen" variables are not listed as <<dependencies>>.
The functional dependency is defined as (dependencies of variables that are fixed in Event and *Continuous-Time Mode* and at communication points are not shown): +
latexmath:[{(\mathbf{y}_c, \mathbf{y}_d) := \mathbf{f}_{\mathit{output}}(\mathbf{x}_c, \mathbf{u}_c, \mathbf{u}_d, t, \mathbf{p}_{\mathit{tune}})}]

|`Derivative`
|Ordered list of all state derivatives, in other words, a list of value references where every corresponding variable must be a state derivative.
_[Note that only <<continuous>> floating point variables are listed here._
_If a <<state>> or a <<derivative>> of a <<state>> shall not be exposed from the FMU, or if states are not statically associated with a variable (due to dynamic state selection), then dummy variables have to be introduced, for example, `x[4]`, or `xDynamicStateSet2[5]`._
_The ordering of the variables in this list is defined by the exporting tool._
_Usually, it is best to order according to the declaration order of the <<state,`states`>> in the source model, since then the `<ModelStructure><Derivative>` list does not change if the declaration order of states in the source model is not changed._
_This is for example, important for linearization, in order that the interpretation of the state vector does not change for a re-exported FMU.]_

The corresponding continuous-time <<state,`states`>> are defined by attribute <<derivative>> of the corresponding variable state derivative element.
_[Note that higher order derivatives must be mapped to first order derivatives but the mapping definition can be preserved due to attribute <<derivative>>._
_Example: if_ latexmath:[{\frac{\text{ds}}{\text{dt}} = v,\ \frac{\text{dv}}{\text{dt}} =f(..)}] _,then_ latexmath:[{\left\{ v,\ \frac{\text{dv}}{\text{dt}} \right\}}] _is the vector of state derivatives and attribute <<derivative>> of_ latexmath:[{v}] _references_ latexmath:[{s}] _, and attribute <<derivative>> of_ latexmath:[{\frac{\text{dv}}{\text{dt}}}] _references_ latexmath:[{v}] _.]_ +
For Co-Simulation, elements `<Derivative>` are ignored if capability flag `providesDirectionalDerivatives` has a value of `false`, in other words, it cannot be computed.
_[This is the default._
_If an FMU supports more than Model Exchange , then the `<Derivative>` elements might be present, since it is needed for Model Exchange._
_If the above flag is set to `false` for the Co-Simulation cases, then the `<Derivative>` elements are ignored for Co-Simulation._
_If "inline integration" is used for a co-simulation FMU, then the model still has continuous-time <<state,`states`>> and just a special solver is used (internally the implementation results in a discrete-time system, but from the outside, it is still a continuous-time system).]_ +
Attribute <<dependencies>> defines the dependencies of the state derivatives from the knowns at the current super-dense time instant in Event and in *Continuous-Time Mode* (ME) and at the current communication point (CS and SE).
Beside the knowns the derivatives also depend on the "frozen" variables (= variables which cannot be changed in the current mode) but these "frozen" variables are not listed as <<dependencies>>.
The functional dependency is defined as (dependencies of variables that are fixed in Event and *Continuous-Time Mode* and at communication points are not shown): +
latexmath:[{\dot{\mathbf{x}_c} := \mathbf{f}_{\mathit{der}}(\mathbf{x}_c, \mathbf{u}_c, \mathbf{u}_d, t, \mathbf{p}_{\mathit{tune}})}]

|`InitialUnknown`
|
[[InitialUnknown,`<InitialUnknown>`]]
Ordered list of all exposed unknowns in *Initialization Mode*.
This list consists of all variables with

- <<causality>> = <<output>> and (<<initial>> = <<approx>> or <<calculated>>), and

- <<causality>> = <<calculatedParameter>> and

- all continuous-time <<state,`states`>> and all state derivatives (defined with elements `<ModelStructure><Derivative>`) with <<initial>> = <<approx>> or <<calculated>> _[if a Co-Simulation FMU does not define the `<ModelStructure><Derivative>` elements, (3) cannot be present]_.

The resulting list is not allowed to have duplicates (for example, if a <<state>> is also an <<output>>, it is included only once in the list). +
Attribute <<dependencies>> defines the dependencies of the unknowns from the knowns in *Initialization Mode* at the initial time.
Beside the knowns the initial unknowns also depend on the "frozen" variables (= variables which cannot be changed in the current mode) but these "frozen" variables are not listed as <<dependencies>>.
The functional dependency is defined as:

latexmath:[{\mathbf{v}_{\mathit{initialUnknowns}} := \mathbf{f}_{\mathit{init}}(\mathbf{u}_c, \mathbf{u}_d, t_0, \mathbf{v}_{\mathit{initial=exact}})}]

Since, <<output,`outputs`>>, continuous-time <<state,`states`>> and state derivatives are either present as knowns (if <<initial>> = <<exact>>) or as unknowns (if <<initial>> = <<approx>> or <<calculated>>), they can be inquired with `fmi3Get{VariableType}` in *Initialization Mode*.

_[Example: Assume an FMU is defined in the following way:_

latexmath:[{(\mathbf{y}_{c+d}, \dot{\mathbf{x}}_c) := \mathbf{f}_{\mathit{init}}(\mathbf{x}_c, \mathbf{u}_{c+d}, t_0, \mathbf{p})}] +

latexmath:[{(\mathbf{y}_{c+d}, \dot{\mathbf{x}}_c) := \mathbf{f}_{\mathit{sim}}(\mathbf{x}_c, \mathbf{u}_{c+d}, t_i, \mathbf{p})}] +

_Therefore, the initial state latexmath:[{\mathbf{x}_c(t_0)}] has <<initial>> = <<exact>> and the initial state derivative latexmath:[{\dot{\mathbf{x}}_c(t_0)}] has <<initial>> = <<calculated>>._
_The environment can still initialize this FMU in steady-state, by using latexmath:[{\mathbf{x}_c(t_0)}] as iteration variables and adding the equations latexmath:[{\dot{\mathbf{x}}_c(t_0) = \mathbf{0}}] in the environment.]_

|`EventIndicator`
|
[[EventIndicator,`<EventIndicator>`]]
Ordered list of all event indicators, in other words, a list of value references where every corresponding variable must be a event indicator.
_[Note that only <<continuous>> floating point variables are listed here._
_If an event indicator shall not be exposed from the FMU, or if event indicators are not statically associated with a variable (due to dynamic event indicator selection), then dummy variables have to be introduced, for example, `eventIndicator[4]`._
_The ordering of the variables in this list is defined by the exporting tool.]_

For Co-Simulation, elements `<EventIndicator>` are ignored.
_[If an FMU supports both Model Exchange and Co-Simulation, then the `<EventIndicator>` elements might be present, since it is needed for Model Exchange.]_

|====

Elements `<Output>`, `<Derivative>` and `<InitialUnknown>` have the following attributes:

[cols="1,5", options="header"]
|====
|Attribute
|Description

|`valueReference`
|The value reference of the unknown latexmath:[{v_{\mathit{unknown}}}].


|`dependencies`
|
[[dependencies,`dependencies`]]
Optional attribute defining the dependencies of the unknown latexmath:[{v_{\mathit{unknown}}}] (directly or indirectly via auxiliary variables) with respect to latexmath:[{\mathbf{v}_{\mathit{known}}}].
If not present, it must be assumed that the unknown depends on all knowns.
If present as empty list, the unknown depends on none of the knowns.
Otherwise the unknown depends on the knowns defined by the given value references. +
Knowns latexmath:[{\mathbf{v}_{\mathit{known}}}] in *Event Mode* and *Continuous-Time Mode* (ME) and at communication points (CS and SE) for `<Output>` and `<Derivative>` elements:

- inputs (variables with <<causality>> = <<input>>)

- continuous-time states

- <<independent>> variable (usually time; <<causality>> = <<independent>>).

_[<<parameter,`parameters`>> and <<tunable>> <<parameter,`parameters`>> must not be listed as knowns in this mode._
_This may change in a future FMI version which implies the possibility to calculate derivatives with respect to parameters._
_The list of dependencies may include input clocks (variables with <<causality>> = <<input>> and <<variability>> = <<clock>>)._
_If an <<outputClock,`output clock`>> depends on an <<inputClock,`input clock`>>, then clock ticks of the <<inputClock,`input clock`>> in *Event Mode* may create <<outputClock,`output clock`>> ticks during this event handling.]_

`Knowns` latexmath:[{\mathbf{v}_{\mathit{known}}}] in *Initialization Mode* (for elements <<InitialUnknown>>):

- inputs (variables with <<causality>> = <<input>>)

- variables with <<initial>> = <<exact>> _[for example, <<parameter,`parameters`>> or initial <<state,`states`>>]_

- <<independent>> variable (usually time; <<causality>> = <<independent>>).

For Co-Simulation, if the capability flag `providesDirectionalDerivatives` has a value of `false`, then <<dependencies>> does not list the dependency on continuous-time.
In other words, the respective partial derivatives cannot be computed.

|`dependenciesKind`
|
[[dependenciesKind, `dependenciesKind`]]
If <<dependenciesKind>> is present, <<dependencies>> must be present and must have the same number of list elements.
If not present, it must be assumed that the unknown latexmath:[{v_{\mathit{unknow}}}}] depends on the knowns latexmath:[{\mathbf{v}_{\mathit{known}}}] without a particular structure.
Otherwise, the corresponding known latexmath:[{v_{\mathit{known},i}}] enters the equation as:

`= dependent`: no particular structure, latexmath:[{{h(..,\ v}_{\mathit{known},i}}],..)

Only for floating point type unknowns latexmath:[{v_{\mathit{unknown}}}]:

`=` <<constant>>: constant factor, latexmath:[{c \cdot v_{\mathit{known},i}}] where latexmath:[{c}] is an expression that is evaluated before <<fmi3EnterInitializationMode>> is called.

Only for floating point type unknowns latexmath:[{v_{\mathit{unknown}}}] in Event and *Continuous-Time Mode* (ME) and at communication points (CS and SE), and not for <<InitialUnknown>> for *Initialization Mode*:

`=` <<fixed>>: fixed factor, latexmath:[{p \cdot v_{\mathit{known},i}}] where latexmath:[{p}] is an expression that is evaluated before <<fmi3ExitInitializationMode>> is called.

`=` <<tunable>>: tunable factor, latexmath:[{p \cdot v_{\mathit{known},i}}] where latexmath:[{p}] is an expression that is evaluated before <<fmi3ExitInitializationMode>> is called and in *Event Mode* due to event handling (ME) or at a communication point (CS and SE)

`=` <<discrete>>: discrete factor, latexmath:[{d \cdot v_{\mathit{known},i}}] where latexmath:[{d}] is an expression that is evaluated before <<fmi3ExitInitializationMode>> is called and in *Event Mode* due to an external or internal event or at a communication point (CS and SE).
|====

_[Example 1:_

_An FMU is defined by the following equations:_

[latexmath]
++++
\begin{align*}

\frac{d}{\text{dt}}\begin{bmatrix}
x_{1} \\
x_{2} \\
x_{3} \\
\end{bmatrix}

&=

\begin{bmatrix}
f_{1}\left( x_{2} \right) \\
f_{2}\left( x_{1} \right) + 3 \cdot p^{2} \cdot x_{2} + 2 \cdot u_{1} + 3 \cdot u_{3} \\
f_{3}\left( x_{1},x_{3},u_{1},u_{2},u_{3} \right) \\
\end{bmatrix}

\\

y &= g_1(x_2, x_3)

\end{align*},
++++

_where_ latexmath:[{u_{1}}] _is a continuous-time <<input>> (<<variability>> = <<continuous>>),_ latexmath:[{u_{2}}] _is any type of <<input>>,_ latexmath:[{u_{3}}] _is a floating point discrete-time <<input>> (<<variability>> = "discrete"`), and_ latexmath:[{p}] _is a <<fixed>> <<parameter>> (<<variability>> = <<fixed>>)._
_The initialization is defined by:_

[latexmath]
++++
x_1 = 1.1, \frac{dx_2}{dt} = 0, y = 3.3,
++++

_and therefore, the initialization equations are:_

[latexmath]
++++
\begin{align*}
x_{2} &= \frac{1}{3 \cdot p^{2}} \cdot ( f_{2}\left( x_{1} \right) + 2 \cdot u_{1} + 3 \cdot u_{3} )
\\
x_{3} &= g_{1}^{- 1}( x_{2}, y)
\end{align*}
++++

_This equation system can be defined as:_

[source, xml]
----
include::examples/model_structure_example1.xml[tags=VariablesAndStructure]
----

_Example 2:_

[latexmath]
++++
y = \left\{ \begin{matrix}
2 \cdot u \ \mathrm{if} \ u > 0 \\
3 \cdot u \ \mathrm{else} \\
\end{matrix}\right.
++++

_where_ latexmath:[{u}] _is a continuous-time <<input>> with <<valueReference>> = `1` and_ latexmath:[{y}] _is a continuous-time <<output>> with <<valueReference>> = `2`._
_The definition of the model structure is then:_

[source, xml]
----
include::examples/model_structure_example2.xml[tags=ModelStructure]
----

_[Note that_ latexmath:[{y = d \cdot u}] _where_ latexmath:[{d}] _changes only during *Event Mode* (_ latexmath:[{d = 2 \cdot u}] _or_ latexmath:[{3 \cdot u\ }] _depending on relation_ latexmath:[{u > 0}] _that changes only at *Event Mode*)._
_Therefore <<dependenciesKind>> = <<discrete>>.]_

_Example 3:_

[latexmath]
++++
y = \left\{ \begin{matrix}
2\ \ \mathrm{if}\ \ u > 0 \\
3\ \ \mathrm{else} \\
\end{matrix}\right.
++++

_where_ latexmath:[{u}] _is a continuous-time <<input>> with <<valueReference>> = `1` and_ latexmath:[{y}] _is a continuous-time <<output>> with <<valueReference>> = `2`._
_The definition of the model structure is then:_

[source, xml]
----
include::examples/model_structure_example3.xml[tags=ModelStructure]
----

_[Note that_ latexmath:[{y = c}] _where_ latexmath:[{c}] _changes only during *Event Mode* (_ latexmath:[{c = 2}] _or_ latexmath:[{3\ }] _depending on relation_ latexmath:[{u > 0}] _that changes only at *Event Mode*)._
_Therefore <<dependenciesKind>> = <<dependenciesKind,`dependent`>> because it is not a linear relationship on_ latexmath:[{u}]. _]_

_Example 4:_

[latexmath]
++++
\frac{dx}{dt}=u, y=x
++++

where `u` is continuous-time input value reference `1`, `y` is a continuous-time output with value reference `2` and `dxdt` is a continuous-time derivative with value reference `4`.
The definition of the model structure is then:

[source, xml]
----
include::examples/model_structure_example4.xml[tags=VariablesAndStructure]
----

_Defining FMU features with the_ <<dependencies>> _list:_

_[Note that via the <<dependencies>> list the supported features of the FMU can be defined._
_Examples:_

- _If a state derivative `der_x` is a function of a <<parameter>> p (so of a <<start>> value of a variable with <<causality>> = <<parameter>> and <<variability>> = <<fixed>>), and the FMU does not support an iteration over `p` during *Initialization Mode* (for example, to iterate over p such that the state derivative `der_x` is zero), then the <<dependencies>> list of `der_x` should not include `p`._
_If an FMU is imported in an environment and such an iteration is set up, then the tool can figure out that the resulting algebraic system of equations is structurally singular and therefore can reject such a definition._

- _For Co-Simulation FMUs, it is common that no algebraic loops over the <<input>> / <<output>> variables nor over <<start>> values is supported._
_In such a case, all <<dependencies>> lists for <<output>> variables under the <<InitialUnknown>> element should be defined as empty lists defining that the setting of <<input,`inputs`>> and/or of <<start>> values does not influence the <<output,`outputs`>>._
_As a result, it is not possible to formulate algebraic loops of connected FMUs during *Initialization Mode*.]_

==== Variable Naming Conventions [[variableNamingConvention]]

With attribute `variableNamingConvention` in `<fmiModelDescription>`, the convention is defined how the variable names have been constructed.
If this information is known, the environment may be able to represent the names in a better way (for example, as a tree and not as a linear list).

In the following definitions, the http://en.wikipedia.org/wiki/Extended_BNF[EBNF] is used:

----
=   production rule
[ ] optional
{ } repeat zero or more times
|   or
----

The names must be unique, non-empty strings. +
_[It is recommended that the names are visually clearly different from each other; but it is not required.]_

The following conventions for scalar names are defined:

*`variableNamingConvention = flat`*

----
name = Unicode-char { Unicode-char } // identical to xs:normalizedString
Unicode-char = any Unicode character without carriage return (#xD),
line feed (#xA) nor tab (#x9)
----

*`variableNamingConvention = structured`*

Structured names are hierarchical using "." as a separator between hierarchies.
A name consists of "pass:[_]", letters and digits or may consist of any characters enclosed in single apostrophes.
A name may identify an array element on every hierarchical level using "[...]" to identify the respective array index.
If an array is a leaf node of the variable hierarchy then the array can also be represented as a single variable of type array.
A <<derivative>> of a variable is defined with `der(name)` for the first time derivative and `der(name,N)` for the N-th derivative.
Examples:

----
vehicle.engine.speed
resistor12.u
v_min
robot.axis.'motor #234'
der(pipe[3,4].T[14],2) // second time derivative of pipe[3,4].T[14]
----

The precise syntax is:

----
name            = identifier | "der(" identifier ["," unsignedInteger ] ")"
identifier      = B-name [ arrayIndices ] {"." B-name [ arrayIndices ] }
B-name          = nondigit { digit | nondigit } | Q-name
nondigit        = "pass:[_]" | letters "a" to "z" | letters "A" to "Z"
digit           = "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"
Q-name          = "'" ( Q-char | escape ) { Q-char | escape } "'"
Q-char          = nondigit | digit | "!" | "#" | "$" | "%" | "&" | "(" | ")" |
                                     "*" | "+" | "," | "-" | "." | "/" | ":" |
                                     ";" | "<" | ">" | "=" | "?" | "@" | "[" |
                                     "]" | "^" | "{" | "}" | "|" | "~" | " "
escape          = "\'" | "\"" | "\?" | "\\" | "\a" | "\b" |
                  "\f" | "\n" | "\r" | "\t" | "\v"
arrayIndices    = "[" unsignedInteger {"," unsignedInteger} "]"
unsignedInteger = digit { digit }
----

_[This definition is identical to the syntax of an identifier in Modelica version 3.2.]_

The tree of names is mapped to an ordered list of variable names in http://en.wikipedia.org/wiki/Depth-first_search[depth-first] order.
Example:

----
vehicle
  transmission
    ratio
    outputSpeed
  engine
    inputSpeed
    temperature
----

is mapped to the following list of variable names:

----
vehicle.transmission.ratio
vehicle.transmission.outputSpeed
vehicle.engine.inputSpeed
vehicle.engine.temperature
----

All flattened array elements are given in a consecutive sequence of variables.
Elements of multi-dimensional arrays are ordered according to "row major" order that is elements of the last index are given in sequence.

_[For example, the vector `centerOfMass` in body `arm1` is mapped to the following variables:_

----
robot.arm1.centerOfMass[1]
robot.arm1.centerOfMass[2]
robot.arm1.centerOfMass[3]
----

_[For example, a controller might receive 3 rpm sensors mapped to the following variables:_

----
transmission.rpms[0]
transmission.rpms[1]
transmission.rpms[2]
----

_For example, a table `T[4,3,2]` (first dimension 4 entries, second dimension 3 entries, third dimension 2 entries) is mapped to the following variables:_

----
T[1,1,1]
T[1,1,2]
T[1,2,1]
T[1,2,2]
T[1,3,1]
T[1,3,2]
T[2,1,1]
T[2,1,2]
T[2,3,1]
...
----
_]_

It might be that not all elements of an array are present.
If they are present, they are given in consecutive order in the XML file.

The `variableNamingConvention` `structured` does not define if arrays are 0-based or 1-based.

_[FMI 3.0 introduces arrays of variables to improve handling of arrays.]_
